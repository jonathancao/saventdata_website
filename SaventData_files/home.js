(()=>{var __webpack_modules__={"./node_modules/@fancyapps/fancybox/dist/jquery.fancybox.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/fancybox/dist/jquery.fancybox.js ***!
  \******************************************************************/()=>{eval('// ==================================================\n// fancyBox v3.5.7\n//\n// Licensed GPLv3 for open source use\n// or fancyBox Commercial License for commercial use\n//\n// http://fancyapps.com/fancybox/\n// Copyright 2019 fancyApps\n//\n// ==================================================\n(function (window, document, $, undefined) {\r\n  "use strict";\r\n\r\n  window.console = window.console || {\r\n    info: function (stuff) {}\r\n  };\r\n\r\n  // If there\'s no jQuery, fancyBox can\'t work\r\n  // =========================================\r\n\r\n  if (!$) {\r\n    return;\r\n  }\r\n\r\n  // Check if fancyBox is already initialized\r\n  // ========================================\r\n\r\n  if ($.fn.fancybox) {\r\n    console.info("fancyBox already initialized");\r\n\r\n    return;\r\n  }\r\n\r\n  // Private default settings\r\n  // ========================\r\n\r\n  var defaults = {\r\n    // Close existing modals\r\n    // Set this to false if you do not need to stack multiple instances\r\n    closeExisting: false,\r\n\r\n    // Enable infinite gallery navigation\r\n    loop: false,\r\n\r\n    // Horizontal space between slides\r\n    gutter: 50,\r\n\r\n    // Enable keyboard navigation\r\n    keyboard: true,\r\n\r\n    // Should allow caption to overlap the content\r\n    preventCaptionOverlap: true,\r\n\r\n    // Should display navigation arrows at the screen edges\r\n    arrows: true,\r\n\r\n    // Should display counter at the top left corner\r\n    infobar: true,\r\n\r\n    // Should display close button (using `btnTpl.smallBtn` template) over the content\r\n    // Can be true, false, "auto"\r\n    // If "auto" - will be automatically enabled for "html", "inline" or "ajax" items\r\n    smallBtn: "auto",\r\n\r\n    // Should display toolbar (buttons at the top)\r\n    // Can be true, false, "auto"\r\n    // If "auto" - will be automatically hidden if "smallBtn" is enabled\r\n    toolbar: "auto",\r\n\r\n    // What buttons should appear in the top right corner.\r\n    // Buttons will be created using templates from `btnTpl` option\r\n    // and they will be placed into toolbar (class="fancybox-toolbar"` element)\r\n    buttons: [\r\n      "zoom",\r\n      //"share",\r\n      "slideShow",\r\n      //"fullScreen",\r\n      //"download",\r\n      "thumbs",\r\n      "close"\r\n    ],\r\n\r\n    // Detect "idle" time in seconds\r\n    idleTime: 3,\r\n\r\n    // Disable right-click and use simple image protection for images\r\n    protect: false,\r\n\r\n    // Shortcut to make content "modal" - disable keyboard navigtion, hide buttons, etc\r\n    modal: false,\r\n\r\n    image: {\r\n      // Wait for images to load before displaying\r\n      //   true  - wait for image to load and then display;\r\n      //   false - display thumbnail and load the full-sized image over top,\r\n      //           requires predefined image dimensions (`data-width` and `data-height` attributes)\r\n      preload: false\r\n    },\r\n\r\n    ajax: {\r\n      // Object containing settings for ajax request\r\n      settings: {\r\n        // This helps to indicate that request comes from the modal\r\n        // Feel free to change naming\r\n        data: {\r\n          fancybox: true\r\n        }\r\n      }\r\n    },\r\n\r\n    iframe: {\r\n      // Iframe template\r\n      tpl: \'<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>\',\r\n\r\n      // Preload iframe before displaying it\r\n      // This allows to calculate iframe content width and height\r\n      // (note: Due to "Same Origin Policy", you can\'t get cross domain data).\r\n      preload: true,\r\n\r\n      // Custom CSS styling for iframe wrapping element\r\n      // You can use this to set custom iframe dimensions\r\n      css: {},\r\n\r\n      // Iframe tag attributes\r\n      attr: {\r\n        scrolling: "auto"\r\n      }\r\n    },\r\n\r\n    // For HTML5 video only\r\n    video: {\r\n      tpl: \'<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}">\' +\r\n        \'<source src="{{src}}" type="{{format}}" />\' +\r\n        \'Sorry, your browser doesn\\\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!\' +\r\n        "</video>",\r\n      format: "", // custom video format\r\n      autoStart: true\r\n    },\r\n\r\n    // Default content type if cannot be detected automatically\r\n    defaultType: "image",\r\n\r\n    // Open/close animation type\r\n    // Possible values:\r\n    //   false            - disable\r\n    //   "zoom"           - zoom images from/to thumbnail\r\n    //   "fade"\r\n    //   "zoom-in-out"\r\n    //\r\n    animationEffect: "zoom",\r\n\r\n    // Duration in ms for open/close animation\r\n    animationDuration: 366,\r\n\r\n    // Should image change opacity while zooming\r\n    // If opacity is "auto", then opacity will be changed if image and thumbnail have different aspect ratios\r\n    zoomOpacity: "auto",\r\n\r\n    // Transition effect between slides\r\n    //\r\n    // Possible values:\r\n    //   false            - disable\r\n    //   "fade\'\r\n    //   "slide\'\r\n    //   "circular\'\r\n    //   "tube\'\r\n    //   "zoom-in-out\'\r\n    //   "rotate\'\r\n    //\r\n    transitionEffect: "fade",\r\n\r\n    // Duration in ms for transition animation\r\n    transitionDuration: 366,\r\n\r\n    // Custom CSS class for slide element\r\n    slideClass: "",\r\n\r\n    // Custom CSS class for layout\r\n    baseClass: "",\r\n\r\n    // Base template for layout\r\n    baseTpl: \'<div class="fancybox-container" role="dialog" tabindex="-1">\' +\r\n      \'<div class="fancybox-bg"></div>\' +\r\n      \'<div class="fancybox-inner">\' +\r\n      \'<div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div>\' +\r\n      \'<div class="fancybox-toolbar">{{buttons}}</div>\' +\r\n      \'<div class="fancybox-navigation">{{arrows}}</div>\' +\r\n      \'<div class="fancybox-stage"></div>\' +\r\n      \'<div class="fancybox-caption"><div class="fancybox-caption__body"></div></div>\' +\r\n      "</div>" +\r\n      "</div>",\r\n\r\n    // Loading indicator template\r\n    spinnerTpl: \'<div class="fancybox-loading"></div>\',\r\n\r\n    // Error message template\r\n    errorTpl: \'<div class="fancybox-error"><p>{{ERROR}}</p></div>\',\r\n\r\n    btnTpl: {\r\n      download: \'<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;">\' +\r\n        \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg>\' +\r\n        "</a>",\r\n\r\n      zoom: \'<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}">\' +\r\n        \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg>\' +\r\n        "</button>",\r\n\r\n      close: \'<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}">\' +\r\n        \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg>\' +\r\n        "</button>",\r\n\r\n      // Arrows\r\n      arrowLeft: \'<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}">\' +\r\n        \'<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div>\' +\r\n        "</button>",\r\n\r\n      arrowRight: \'<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}">\' +\r\n        \'<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div>\' +\r\n        "</button>",\r\n\r\n      // This small close button will be appended to your html/inline/ajax content by default,\r\n      // if "smallBtn" option is not set to false\r\n      smallBtn: \'<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}">\' +\r\n        \'<svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg>\' +\r\n        "</button>"\r\n    },\r\n\r\n    // Container is injected into this element\r\n    parentEl: "body",\r\n\r\n    // Hide browser vertical scrollbars; use at your own risk\r\n    hideScrollbar: true,\r\n\r\n    // Focus handling\r\n    // ==============\r\n\r\n    // Try to focus on the first focusable element after opening\r\n    autoFocus: true,\r\n\r\n    // Put focus back to active element after closing\r\n    backFocus: true,\r\n\r\n    // Do not let user to focus on element outside modal content\r\n    trapFocus: true,\r\n\r\n    // Module specific options\r\n    // =======================\r\n\r\n    fullScreen: {\r\n      autoStart: false\r\n    },\r\n\r\n    // Set `touch: false` to disable panning/swiping\r\n    touch: {\r\n      vertical: true, // Allow to drag content vertically\r\n      momentum: true // Continue movement after releasing mouse/touch when panning\r\n    },\r\n\r\n    // Hash value when initializing manually,\r\n    // set `false` to disable hash change\r\n    hash: null,\r\n\r\n    // Customize or add new media types\r\n    // Example:\r\n    /*\r\n      media : {\r\n        youtube : {\r\n          params : {\r\n            autoplay : 0\r\n          }\r\n        }\r\n      }\r\n    */\r\n    media: {},\r\n\r\n    slideShow: {\r\n      autoStart: false,\r\n      speed: 3000\r\n    },\r\n\r\n    thumbs: {\r\n      autoStart: false, // Display thumbnails on opening\r\n      hideOnClose: true, // Hide thumbnail grid when closing animation starts\r\n      parentEl: ".fancybox-container", // Container is injected into this element\r\n      axis: "y" // Vertical (y) or horizontal (x) scrolling\r\n    },\r\n\r\n    // Use mousewheel to navigate gallery\r\n    // If \'auto\' - enabled for images only\r\n    wheel: "auto",\r\n\r\n    // Callbacks\r\n    //==========\r\n\r\n    // See Documentation/API/Events for more information\r\n    // Example:\r\n    /*\r\n      afterShow: function( instance, current ) {\r\n        console.info( \'Clicked element:\' );\r\n        console.info( current.opts.$orig );\r\n      }\r\n    */\r\n\r\n    onInit: $.noop, // When instance has been initialized\r\n\r\n    beforeLoad: $.noop, // Before the content of a slide is being loaded\r\n    afterLoad: $.noop, // When the content of a slide is done loading\r\n\r\n    beforeShow: $.noop, // Before open animation starts\r\n    afterShow: $.noop, // When content is done loading and animating\r\n\r\n    beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close.\r\n    afterClose: $.noop, // After instance has been closed\r\n\r\n    onActivate: $.noop, // When instance is brought to front\r\n    onDeactivate: $.noop, // When other instance has been activated\r\n\r\n    // Interaction\r\n    // ===========\r\n\r\n    // Use options below to customize taken action when user clicks or double clicks on the fancyBox area,\r\n    // each option can be string or method that returns value.\r\n    //\r\n    // Possible values:\r\n    //   "close"           - close instance\r\n    //   "next"            - move to next gallery item\r\n    //   "nextOrClose"     - move to next gallery item or close if gallery has only one item\r\n    //   "toggleControls"  - show/hide controls\r\n    //   "zoom"            - zoom image (if loaded)\r\n    //   false             - do nothing\r\n\r\n    // Clicked on the content\r\n    clickContent: function (current, event) {\r\n      return current.type === "image" ? "zoom" : false;\r\n    },\r\n\r\n    // Clicked on the slide\r\n    clickSlide: "close",\r\n\r\n    // Clicked on the background (backdrop) element;\r\n    // if you have not changed the layout, then most likely you need to use `clickSlide` option\r\n    clickOutside: "close",\r\n\r\n    // Same as previous two, but for double click\r\n    dblclickContent: false,\r\n    dblclickSlide: false,\r\n    dblclickOutside: false,\r\n\r\n    // Custom options when mobile device is detected\r\n    // =============================================\r\n\r\n    mobile: {\r\n      preventCaptionOverlap: false,\r\n      idleTime: false,\r\n      clickContent: function (current, event) {\r\n        return current.type === "image" ? "toggleControls" : false;\r\n      },\r\n      clickSlide: function (current, event) {\r\n        return current.type === "image" ? "toggleControls" : "close";\r\n      },\r\n      dblclickContent: function (current, event) {\r\n        return current.type === "image" ? "zoom" : false;\r\n      },\r\n      dblclickSlide: function (current, event) {\r\n        return current.type === "image" ? "zoom" : false;\r\n      }\r\n    },\r\n\r\n    // Internationalization\r\n    // ====================\r\n\r\n    lang: "en",\r\n    i18n: {\r\n      en: {\r\n        CLOSE: "Close",\r\n        NEXT: "Next",\r\n        PREV: "Previous",\r\n        ERROR: "The requested content cannot be loaded. <br/> Please try again later.",\r\n        PLAY_START: "Start slideshow",\r\n        PLAY_STOP: "Pause slideshow",\r\n        FULL_SCREEN: "Full screen",\r\n        THUMBS: "Thumbnails",\r\n        DOWNLOAD: "Download",\r\n        SHARE: "Share",\r\n        ZOOM: "Zoom"\r\n      },\r\n      de: {\r\n        CLOSE: "Schlie&szlig;en",\r\n        NEXT: "Weiter",\r\n        PREV: "Zur&uuml;ck",\r\n        ERROR: "Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",\r\n        PLAY_START: "Diaschau starten",\r\n        PLAY_STOP: "Diaschau beenden",\r\n        FULL_SCREEN: "Vollbild",\r\n        THUMBS: "Vorschaubilder",\r\n        DOWNLOAD: "Herunterladen",\r\n        SHARE: "Teilen",\r\n        ZOOM: "Vergr&ouml;&szlig;ern"\r\n      }\r\n    }\r\n  };\r\n\r\n  // Few useful variables and methods\r\n  // ================================\r\n\r\n  var $W = $(window);\r\n  var $D = $(document);\r\n\r\n  var called = 0;\r\n\r\n  // Check if an object is a jQuery object and not a native JavaScript object\r\n  // ========================================================================\r\n  var isQuery = function (obj) {\r\n    return obj && obj.hasOwnProperty && obj instanceof $;\r\n  };\r\n\r\n  // Handle multiple browsers for "requestAnimationFrame" and "cancelAnimationFrame"\r\n  // ===============================================================================\r\n  var requestAFrame = (function () {\r\n    return (\r\n      window.requestAnimationFrame ||\r\n      window.webkitRequestAnimationFrame ||\r\n      window.mozRequestAnimationFrame ||\r\n      window.oRequestAnimationFrame ||\r\n      // if all else fails, use setTimeout\r\n      function (callback) {\r\n        return window.setTimeout(callback, 1000 / 60);\r\n      }\r\n    );\r\n  })();\r\n\r\n  var cancelAFrame = (function () {\r\n    return (\r\n      window.cancelAnimationFrame ||\r\n      window.webkitCancelAnimationFrame ||\r\n      window.mozCancelAnimationFrame ||\r\n      window.oCancelAnimationFrame ||\r\n      function (id) {\r\n        window.clearTimeout(id);\r\n      }\r\n    );\r\n  })();\r\n\r\n  // Detect the supported transition-end event property name\r\n  // =======================================================\r\n  var transitionEnd = (function () {\r\n    var el = document.createElement("fakeelement"),\r\n      t;\r\n\r\n    var transitions = {\r\n      transition: "transitionend",\r\n      OTransition: "oTransitionEnd",\r\n      MozTransition: "transitionend",\r\n      WebkitTransition: "webkitTransitionEnd"\r\n    };\r\n\r\n    for (t in transitions) {\r\n      if (el.style[t] !== undefined) {\r\n        return transitions[t];\r\n      }\r\n    }\r\n\r\n    return "transitionend";\r\n  })();\r\n\r\n  // Force redraw on an element.\r\n  // This helps in cases where the browser doesn\'t redraw an updated element properly\r\n  // ================================================================================\r\n  var forceRedraw = function ($el) {\r\n    return $el && $el.length && $el[0].offsetHeight;\r\n  };\r\n\r\n  // Exclude array (`buttons`) options from deep merging\r\n  // ===================================================\r\n  var mergeOpts = function (opts1, opts2) {\r\n    var rez = $.extend(true, {}, opts1, opts2);\r\n\r\n    $.each(opts2, function (key, value) {\r\n      if ($.isArray(value)) {\r\n        rez[key] = value;\r\n      }\r\n    });\r\n\r\n    return rez;\r\n  };\r\n\r\n  // How much of an element is visible in viewport\r\n  // =============================================\r\n\r\n  var inViewport = function (elem) {\r\n    var elemCenter, rez;\r\n\r\n    if (!elem || elem.ownerDocument !== document) {\r\n      return false;\r\n    }\r\n\r\n    $(".fancybox-container").css("pointer-events", "none");\r\n\r\n    elemCenter = {\r\n      x: elem.getBoundingClientRect().left + elem.offsetWidth / 2,\r\n      y: elem.getBoundingClientRect().top + elem.offsetHeight / 2\r\n    };\r\n\r\n    rez = document.elementFromPoint(elemCenter.x, elemCenter.y) === elem;\r\n\r\n    $(".fancybox-container").css("pointer-events", "");\r\n\r\n    return rez;\r\n  };\r\n\r\n  // Class definition\r\n  // ================\r\n\r\n  var FancyBox = function (content, opts, index) {\r\n    var self = this;\r\n\r\n    self.opts = mergeOpts({\r\n      index: index\r\n    }, $.fancybox.defaults);\r\n\r\n    if ($.isPlainObject(opts)) {\r\n      self.opts = mergeOpts(self.opts, opts);\r\n    }\r\n\r\n    if ($.fancybox.isMobile) {\r\n      self.opts = mergeOpts(self.opts, self.opts.mobile);\r\n    }\r\n\r\n    self.id = self.opts.id || ++called;\r\n\r\n    self.currIndex = parseInt(self.opts.index, 10) || 0;\r\n    self.prevIndex = null;\r\n\r\n    self.prevPos = null;\r\n    self.currPos = 0;\r\n\r\n    self.firstRun = true;\r\n\r\n    // All group items\r\n    self.group = [];\r\n\r\n    // Existing slides (for current, next and previous gallery items)\r\n    self.slides = {};\r\n\r\n    // Create group elements\r\n    self.addContent(content);\r\n\r\n    if (!self.group.length) {\r\n      return;\r\n    }\r\n\r\n    self.init();\r\n  };\r\n\r\n  $.extend(FancyBox.prototype, {\r\n    // Create DOM structure\r\n    // ====================\r\n\r\n    init: function () {\r\n      var self = this,\r\n        firstItem = self.group[self.currIndex],\r\n        firstItemOpts = firstItem.opts,\r\n        $container,\r\n        buttonStr;\r\n\r\n      if (firstItemOpts.closeExisting) {\r\n        $.fancybox.close(true);\r\n      }\r\n\r\n      // Hide scrollbars\r\n      // ===============\r\n\r\n      $("body").addClass("fancybox-active");\r\n\r\n      if (\r\n        !$.fancybox.getInstance() &&\r\n        firstItemOpts.hideScrollbar !== false &&\r\n        !$.fancybox.isMobile &&\r\n        document.body.scrollHeight > window.innerHeight\r\n      ) {\r\n        $("head").append(\r\n          \'<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:\' +\r\n          (window.innerWidth - document.documentElement.clientWidth) +\r\n          "px;}</style>"\r\n        );\r\n\r\n        $("body").addClass("compensate-for-scrollbar");\r\n      }\r\n\r\n      // Build html markup and set references\r\n      // ====================================\r\n\r\n      // Build html code for buttons and insert into main template\r\n      buttonStr = "";\r\n\r\n      $.each(firstItemOpts.buttons, function (index, value) {\r\n        buttonStr += firstItemOpts.btnTpl[value] || "";\r\n      });\r\n\r\n      // Create markup from base template, it will be initially hidden to\r\n      // avoid unnecessary work like painting while initializing is not complete\r\n      $container = $(\r\n          self.translate(\r\n            self,\r\n            firstItemOpts.baseTpl\r\n            .replace("{{buttons}}", buttonStr)\r\n            .replace("{{arrows}}", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight)\r\n          )\r\n        )\r\n        .attr("id", "fancybox-container-" + self.id)\r\n        .addClass(firstItemOpts.baseClass)\r\n        .data("FancyBox", self)\r\n        .appendTo(firstItemOpts.parentEl);\r\n\r\n      // Create object holding references to jQuery wrapped nodes\r\n      self.$refs = {\r\n        container: $container\r\n      };\r\n\r\n      ["bg", "inner", "infobar", "toolbar", "stage", "caption", "navigation"].forEach(function (item) {\r\n        self.$refs[item] = $container.find(".fancybox-" + item);\r\n      });\r\n\r\n      self.trigger("onInit");\r\n\r\n      // Enable events, deactive previous instances\r\n      self.activate();\r\n\r\n      // Build slides, load and reveal content\r\n      self.jumpTo(self.currIndex);\r\n    },\r\n\r\n    // Simple i18n support - replaces object keys found in template\r\n    // with corresponding values\r\n    // ============================================================\r\n\r\n    translate: function (obj, str) {\r\n      var arr = obj.opts.i18n[obj.opts.lang] || obj.opts.i18n.en;\r\n\r\n      return str.replace(/\\{\\{(\\w+)\\}\\}/g, function (match, n) {\r\n        return arr[n] === undefined ? match : arr[n];\r\n      });\r\n    },\r\n\r\n    // Populate current group with fresh content\r\n    // Check if each object has valid type and content\r\n    // ===============================================\r\n\r\n    addContent: function (content) {\r\n      var self = this,\r\n        items = $.makeArray(content),\r\n        thumbs;\r\n\r\n      $.each(items, function (i, item) {\r\n        var obj = {},\r\n          opts = {},\r\n          $item,\r\n          type,\r\n          found,\r\n          src,\r\n          srcParts;\r\n\r\n        // Step 1 - Make sure we have an object\r\n        // ====================================\r\n\r\n        if ($.isPlainObject(item)) {\r\n          // We probably have manual usage here, something like\r\n          // $.fancybox.open( [ { src : "image.jpg", type : "image" } ] )\r\n\r\n          obj = item;\r\n          opts = item.opts || item;\r\n        } else if ($.type(item) === "object" && $(item).length) {\r\n          // Here we probably have jQuery collection returned by some selector\r\n          $item = $(item);\r\n\r\n          // Support attributes like `data-options=\'{"touch" : false}\'` and `data-touch=\'false\'`\r\n          opts = $item.data() || {};\r\n          opts = $.extend(true, {}, opts, opts.options);\r\n\r\n          // Here we store clicked element\r\n          opts.$orig = $item;\r\n\r\n          obj.src = self.opts.src || opts.src || $item.attr("href");\r\n\r\n          // Assume that simple syntax is used, for example:\r\n          //   `$.fancybox.open( $("#test"), {} );`\r\n          if (!obj.type && !obj.src) {\r\n            obj.type = "inline";\r\n            obj.src = item;\r\n          }\r\n        } else {\r\n          // Assume we have a simple html code, for example:\r\n          //   $.fancybox.open( \'<div><h1>Hi!</h1></div>\' );\r\n          obj = {\r\n            type: "html",\r\n            src: item + ""\r\n          };\r\n        }\r\n\r\n        // Each gallery object has full collection of options\r\n        obj.opts = $.extend(true, {}, self.opts, opts);\r\n\r\n        // Do not merge buttons array\r\n        if ($.isArray(opts.buttons)) {\r\n          obj.opts.buttons = opts.buttons;\r\n        }\r\n\r\n        if ($.fancybox.isMobile && obj.opts.mobile) {\r\n          obj.opts = mergeOpts(obj.opts, obj.opts.mobile);\r\n        }\r\n\r\n        // Step 2 - Make sure we have content type, if not - try to guess\r\n        // ==============================================================\r\n\r\n        type = obj.type || obj.opts.type;\r\n        src = obj.src || "";\r\n\r\n        if (!type && src) {\r\n          if ((found = src.match(/\\.(mp4|mov|ogv|webm)((\\?|#).*)?$/i))) {\r\n            type = "video";\r\n\r\n            if (!obj.opts.video.format) {\r\n              obj.opts.video.format = "video/" + (found[1] === "ogv" ? "ogg" : found[1]);\r\n            }\r\n          } else if (src.match(/(^data:image\\/[a-z0-9+\\/=]*,)|(\\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\\?|#).*)?$)/i)) {\r\n            type = "image";\r\n          } else if (src.match(/\\.(pdf)((\\?|#).*)?$/i)) {\r\n            type = "iframe";\r\n            obj = $.extend(true, obj, {\r\n              contentType: "pdf",\r\n              opts: {\r\n                iframe: {\r\n                  preload: false\r\n                }\r\n              }\r\n            });\r\n          } else if (src.charAt(0) === "#") {\r\n            type = "inline";\r\n          }\r\n        }\r\n\r\n        if (type) {\r\n          obj.type = type;\r\n        } else {\r\n          self.trigger("objectNeedsType", obj);\r\n        }\r\n\r\n        if (!obj.contentType) {\r\n          obj.contentType = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1 ? "html" : obj.type;\r\n        }\r\n\r\n        // Step 3 - Some adjustments\r\n        // =========================\r\n\r\n        obj.index = self.group.length;\r\n\r\n        if (obj.opts.smallBtn == "auto") {\r\n          obj.opts.smallBtn = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1;\r\n        }\r\n\r\n        if (obj.opts.toolbar === "auto") {\r\n          obj.opts.toolbar = !obj.opts.smallBtn;\r\n        }\r\n\r\n        // Find thumbnail image, check if exists and if is in the viewport\r\n        obj.$thumb = obj.opts.$thumb || null;\r\n\r\n        if (obj.opts.$trigger && obj.index === self.opts.index) {\r\n          obj.$thumb = obj.opts.$trigger.find("img:first");\r\n\r\n          if (obj.$thumb.length) {\r\n            obj.opts.$orig = obj.opts.$trigger;\r\n          }\r\n        }\r\n\r\n        if (!(obj.$thumb && obj.$thumb.length) && obj.opts.$orig) {\r\n          obj.$thumb = obj.opts.$orig.find("img:first");\r\n        }\r\n\r\n        if (obj.$thumb && !obj.$thumb.length) {\r\n          obj.$thumb = null;\r\n        }\r\n\r\n        obj.thumb = obj.opts.thumb || (obj.$thumb ? obj.$thumb[0].src : null);\r\n\r\n        // "caption" is a "special" option, it can be used to customize caption per gallery item\r\n        if ($.type(obj.opts.caption) === "function") {\r\n          obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);\r\n        }\r\n\r\n        if ($.type(self.opts.caption) === "function") {\r\n          obj.opts.caption = self.opts.caption.apply(item, [self, obj]);\r\n        }\r\n\r\n        // Make sure we have caption as a string or jQuery object\r\n        if (!(obj.opts.caption instanceof $)) {\r\n          obj.opts.caption = obj.opts.caption === undefined ? "" : obj.opts.caption + "";\r\n        }\r\n\r\n        // Check if url contains "filter" used to filter the content\r\n        // Example: "ajax.html #something"\r\n        if (obj.type === "ajax") {\r\n          srcParts = src.split(/\\s+/, 2);\r\n\r\n          if (srcParts.length > 1) {\r\n            obj.src = srcParts.shift();\r\n\r\n            obj.opts.filter = srcParts.shift();\r\n          }\r\n        }\r\n\r\n        // Hide all buttons and disable interactivity for modal items\r\n        if (obj.opts.modal) {\r\n          obj.opts = $.extend(true, obj.opts, {\r\n            trapFocus: true,\r\n            // Remove buttons\r\n            infobar: 0,\r\n            toolbar: 0,\r\n\r\n            smallBtn: 0,\r\n\r\n            // Disable keyboard navigation\r\n            keyboard: 0,\r\n\r\n            // Disable some modules\r\n            slideShow: 0,\r\n            fullScreen: 0,\r\n            thumbs: 0,\r\n            touch: 0,\r\n\r\n            // Disable click event handlers\r\n            clickContent: false,\r\n            clickSlide: false,\r\n            clickOutside: false,\r\n            dblclickContent: false,\r\n            dblclickSlide: false,\r\n            dblclickOutside: false\r\n          });\r\n        }\r\n\r\n        // Step 4 - Add processed object to group\r\n        // ======================================\r\n\r\n        self.group.push(obj);\r\n      });\r\n\r\n      // Update controls if gallery is already opened\r\n      if (Object.keys(self.slides).length) {\r\n        self.updateControls();\r\n\r\n        // Update thumbnails, if needed\r\n        thumbs = self.Thumbs;\r\n\r\n        if (thumbs && thumbs.isActive) {\r\n          thumbs.create();\r\n\r\n          thumbs.focus();\r\n        }\r\n      }\r\n    },\r\n\r\n    // Attach an event handler functions for:\r\n    //   - navigation buttons\r\n    //   - browser scrolling, resizing;\r\n    //   - focusing\r\n    //   - keyboard\r\n    //   - detecting inactivity\r\n    // ======================================\r\n\r\n    addEvents: function () {\r\n      var self = this;\r\n\r\n      self.removeEvents();\r\n\r\n      // Make navigation elements clickable\r\n      // ==================================\r\n\r\n      self.$refs.container\r\n        .on("click.fb-close", "[data-fancybox-close]", function (e) {\r\n          e.stopPropagation();\r\n          e.preventDefault();\r\n\r\n          self.close(e);\r\n        })\r\n        .on("touchstart.fb-prev click.fb-prev", "[data-fancybox-prev]", function (e) {\r\n          e.stopPropagation();\r\n          e.preventDefault();\r\n\r\n          self.previous();\r\n        })\r\n        .on("touchstart.fb-next click.fb-next", "[data-fancybox-next]", function (e) {\r\n          e.stopPropagation();\r\n          e.preventDefault();\r\n\r\n          self.next();\r\n        })\r\n        .on("click.fb", "[data-fancybox-zoom]", function (e) {\r\n          // Click handler for zoom button\r\n          self[self.isScaledDown() ? "scaleToActual" : "scaleToFit"]();\r\n        });\r\n\r\n      // Handle page scrolling and browser resizing\r\n      // ==========================================\r\n\r\n      $W.on("orientationchange.fb resize.fb", function (e) {\r\n        if (e && e.originalEvent && e.originalEvent.type === "resize") {\r\n          if (self.requestId) {\r\n            cancelAFrame(self.requestId);\r\n          }\r\n\r\n          self.requestId = requestAFrame(function () {\r\n            self.update(e);\r\n          });\r\n        } else {\r\n          if (self.current && self.current.type === "iframe") {\r\n            self.$refs.stage.hide();\r\n          }\r\n\r\n          setTimeout(\r\n            function () {\r\n              self.$refs.stage.show();\r\n\r\n              self.update(e);\r\n            },\r\n            $.fancybox.isMobile ? 600 : 250\r\n          );\r\n        }\r\n      });\r\n\r\n      $D.on("keydown.fb", function (e) {\r\n        var instance = $.fancybox ? $.fancybox.getInstance() : null,\r\n          current = instance.current,\r\n          keycode = e.keyCode || e.which;\r\n\r\n        // Trap keyboard focus inside of the modal\r\n        // =======================================\r\n\r\n        if (keycode == 9) {\r\n          if (current.opts.trapFocus) {\r\n            self.focus(e);\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // Enable keyboard navigation\r\n        // ==========================\r\n\r\n        if (!current.opts.keyboard || e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is("input,textarea,video,audio,select")) {\r\n          return;\r\n        }\r\n\r\n        // Backspace and Esc keys\r\n        if (keycode === 8 || keycode === 27) {\r\n          e.preventDefault();\r\n\r\n          self.close(e);\r\n\r\n          return;\r\n        }\r\n\r\n        // Left arrow and Up arrow\r\n        if (keycode === 37 || keycode === 38) {\r\n          e.preventDefault();\r\n\r\n          self.previous();\r\n\r\n          return;\r\n        }\r\n\r\n        // Righ arrow and Down arrow\r\n        if (keycode === 39 || keycode === 40) {\r\n          e.preventDefault();\r\n\r\n          self.next();\r\n\r\n          return;\r\n        }\r\n\r\n        self.trigger("afterKeydown", e, keycode);\r\n      });\r\n\r\n      // Hide controls after some inactivity period\r\n      if (self.group[self.currIndex].opts.idleTime) {\r\n        self.idleSecondsCounter = 0;\r\n\r\n        $D.on(\r\n          "mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle",\r\n          function (e) {\r\n            self.idleSecondsCounter = 0;\r\n\r\n            if (self.isIdle) {\r\n              self.showControls();\r\n            }\r\n\r\n            self.isIdle = false;\r\n          }\r\n        );\r\n\r\n        self.idleInterval = window.setInterval(function () {\r\n          self.idleSecondsCounter++;\r\n\r\n          if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {\r\n            self.isIdle = true;\r\n            self.idleSecondsCounter = 0;\r\n\r\n            self.hideControls();\r\n          }\r\n        }, 1000);\r\n      }\r\n    },\r\n\r\n    // Remove events added by the core\r\n    // ===============================\r\n\r\n    removeEvents: function () {\r\n      var self = this;\r\n\r\n      $W.off("orientationchange.fb resize.fb");\r\n      $D.off("keydown.fb .fb-idle");\r\n\r\n      this.$refs.container.off(".fb-close .fb-prev .fb-next");\r\n\r\n      if (self.idleInterval) {\r\n        window.clearInterval(self.idleInterval);\r\n\r\n        self.idleInterval = null;\r\n      }\r\n    },\r\n\r\n    // Change to previous gallery item\r\n    // ===============================\r\n\r\n    previous: function (duration) {\r\n      return this.jumpTo(this.currPos - 1, duration);\r\n    },\r\n\r\n    // Change to next gallery item\r\n    // ===========================\r\n\r\n    next: function (duration) {\r\n      return this.jumpTo(this.currPos + 1, duration);\r\n    },\r\n\r\n    // Switch to selected gallery item\r\n    // ===============================\r\n\r\n    jumpTo: function (pos, duration) {\r\n      var self = this,\r\n        groupLen = self.group.length,\r\n        firstRun,\r\n        isMoved,\r\n        loop,\r\n        current,\r\n        previous,\r\n        slidePos,\r\n        stagePos,\r\n        prop,\r\n        diff;\r\n\r\n      if (self.isDragging || self.isClosing || (self.isAnimating && self.firstRun)) {\r\n        return;\r\n      }\r\n\r\n      // Should loop?\r\n      pos = parseInt(pos, 10);\r\n      loop = self.current ? self.current.opts.loop : self.opts.loop;\r\n\r\n      if (!loop && (pos < 0 || pos >= groupLen)) {\r\n        return false;\r\n      }\r\n\r\n      // Check if opening for the first time; this helps to speed things up\r\n      firstRun = self.firstRun = !Object.keys(self.slides).length;\r\n\r\n      // Create slides\r\n      previous = self.current;\r\n\r\n      self.prevIndex = self.currIndex;\r\n      self.prevPos = self.currPos;\r\n\r\n      current = self.createSlide(pos);\r\n\r\n      if (groupLen > 1) {\r\n        if (loop || current.index < groupLen - 1) {\r\n          self.createSlide(pos + 1);\r\n        }\r\n\r\n        if (loop || current.index > 0) {\r\n          self.createSlide(pos - 1);\r\n        }\r\n      }\r\n\r\n      self.current = current;\r\n      self.currIndex = current.index;\r\n      self.currPos = current.pos;\r\n\r\n      self.trigger("beforeShow", firstRun);\r\n\r\n      self.updateControls();\r\n\r\n      // Validate duration length\r\n      current.forcedDuration = undefined;\r\n\r\n      if ($.isNumeric(duration)) {\r\n        current.forcedDuration = duration;\r\n      } else {\r\n        duration = current.opts[firstRun ? "animationDuration" : "transitionDuration"];\r\n      }\r\n\r\n      duration = parseInt(duration, 10);\r\n\r\n      // Check if user has swiped the slides or if still animating\r\n      isMoved = self.isMoved(current);\r\n\r\n      // Make sure current slide is visible\r\n      current.$slide.addClass("fancybox-slide--current");\r\n\r\n      // Fresh start - reveal container, current slide and start loading content\r\n      if (firstRun) {\r\n        if (current.opts.animationEffect && duration) {\r\n          self.$refs.container.css("transition-duration", duration + "ms");\r\n        }\r\n\r\n        self.$refs.container.addClass("fancybox-is-open").trigger("focus");\r\n\r\n        // Attempt to load content into slide\r\n        // This will later call `afterLoad` -> `revealContent`\r\n        self.loadSlide(current);\r\n\r\n        self.preload("image");\r\n\r\n        return;\r\n      }\r\n\r\n      // Get actual slide/stage positions (before cleaning up)\r\n      slidePos = $.fancybox.getTranslate(previous.$slide);\r\n      stagePos = $.fancybox.getTranslate(self.$refs.stage);\r\n\r\n      // Clean up all slides\r\n      $.each(self.slides, function (index, slide) {\r\n        $.fancybox.stop(slide.$slide, true);\r\n      });\r\n\r\n      if (previous.pos !== current.pos) {\r\n        previous.isComplete = false;\r\n      }\r\n\r\n      previous.$slide.removeClass("fancybox-slide--complete fancybox-slide--current");\r\n\r\n      // If slides are out of place, then animate them to correct position\r\n      if (isMoved) {\r\n        // Calculate horizontal swipe distance\r\n        diff = slidePos.left - (previous.pos * slidePos.width + previous.pos * previous.opts.gutter);\r\n\r\n        $.each(self.slides, function (index, slide) {\r\n          slide.$slide.removeClass("fancybox-animated").removeClass(function (index, className) {\r\n            return (className.match(/(^|\\s)fancybox-fx-\\S+/g) || []).join(" ");\r\n          });\r\n\r\n          // Make sure that each slide is in equal distance\r\n          // This is mostly needed for freshly added slides, because they are not yet positioned\r\n          var leftPos = slide.pos * slidePos.width + slide.pos * slide.opts.gutter;\r\n\r\n          $.fancybox.setTranslate(slide.$slide, {\r\n            top: 0,\r\n            left: leftPos - stagePos.left + diff\r\n          });\r\n\r\n          if (slide.pos !== current.pos) {\r\n            slide.$slide.addClass("fancybox-slide--" + (slide.pos > current.pos ? "next" : "previous"));\r\n          }\r\n\r\n          // Redraw to make sure that transition will start\r\n          forceRedraw(slide.$slide);\r\n\r\n          // Animate the slide\r\n          $.fancybox.animate(\r\n            slide.$slide, {\r\n              top: 0,\r\n              left: (slide.pos - current.pos) * slidePos.width + (slide.pos - current.pos) * slide.opts.gutter\r\n            },\r\n            duration,\r\n            function () {\r\n              slide.$slide\r\n                .css({\r\n                  transform: "",\r\n                  opacity: ""\r\n                })\r\n                .removeClass("fancybox-slide--next fancybox-slide--previous");\r\n\r\n              if (slide.pos === self.currPos) {\r\n                self.complete();\r\n              }\r\n            }\r\n          );\r\n        });\r\n      } else if (duration && current.opts.transitionEffect) {\r\n        // Set transition effect for previously active slide\r\n        prop = "fancybox-animated fancybox-fx-" + current.opts.transitionEffect;\r\n\r\n        previous.$slide.addClass("fancybox-slide--" + (previous.pos > current.pos ? "next" : "previous"));\r\n\r\n        $.fancybox.animate(\r\n          previous.$slide,\r\n          prop,\r\n          duration,\r\n          function () {\r\n            previous.$slide.removeClass(prop).removeClass("fancybox-slide--next fancybox-slide--previous");\r\n          },\r\n          false\r\n        );\r\n      }\r\n\r\n      if (current.isLoaded) {\r\n        self.revealContent(current);\r\n      } else {\r\n        self.loadSlide(current);\r\n      }\r\n\r\n      self.preload("image");\r\n    },\r\n\r\n    // Create new "slide" element\r\n    // These are gallery items  that are actually added to DOM\r\n    // =======================================================\r\n\r\n    createSlide: function (pos) {\r\n      var self = this,\r\n        $slide,\r\n        index;\r\n\r\n      index = pos % self.group.length;\r\n      index = index < 0 ? self.group.length + index : index;\r\n\r\n      if (!self.slides[pos] && self.group[index]) {\r\n        $slide = $(\'<div class="fancybox-slide"></div>\').appendTo(self.$refs.stage);\r\n\r\n        self.slides[pos] = $.extend(true, {}, self.group[index], {\r\n          pos: pos,\r\n          $slide: $slide,\r\n          isLoaded: false\r\n        });\r\n\r\n        self.updateSlide(self.slides[pos]);\r\n      }\r\n\r\n      return self.slides[pos];\r\n    },\r\n\r\n    // Scale image to the actual size of the image;\r\n    // x and y values should be relative to the slide\r\n    // ==============================================\r\n\r\n    scaleToActual: function (x, y, duration) {\r\n      var self = this,\r\n        current = self.current,\r\n        $content = current.$content,\r\n        canvasWidth = $.fancybox.getTranslate(current.$slide).width,\r\n        canvasHeight = $.fancybox.getTranslate(current.$slide).height,\r\n        newImgWidth = current.width,\r\n        newImgHeight = current.height,\r\n        imgPos,\r\n        posX,\r\n        posY,\r\n        scaleX,\r\n        scaleY;\r\n\r\n      if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {\r\n        return;\r\n      }\r\n\r\n      self.isAnimating = true;\r\n\r\n      $.fancybox.stop($content);\r\n\r\n      x = x === undefined ? canvasWidth * 0.5 : x;\r\n      y = y === undefined ? canvasHeight * 0.5 : y;\r\n\r\n      imgPos = $.fancybox.getTranslate($content);\r\n\r\n      imgPos.top -= $.fancybox.getTranslate(current.$slide).top;\r\n      imgPos.left -= $.fancybox.getTranslate(current.$slide).left;\r\n\r\n      scaleX = newImgWidth / imgPos.width;\r\n      scaleY = newImgHeight / imgPos.height;\r\n\r\n      // Get center position for original image\r\n      posX = canvasWidth * 0.5 - newImgWidth * 0.5;\r\n      posY = canvasHeight * 0.5 - newImgHeight * 0.5;\r\n\r\n      // Make sure image does not move away from edges\r\n      if (newImgWidth > canvasWidth) {\r\n        posX = imgPos.left * scaleX - (x * scaleX - x);\r\n\r\n        if (posX > 0) {\r\n          posX = 0;\r\n        }\r\n\r\n        if (posX < canvasWidth - newImgWidth) {\r\n          posX = canvasWidth - newImgWidth;\r\n        }\r\n      }\r\n\r\n      if (newImgHeight > canvasHeight) {\r\n        posY = imgPos.top * scaleY - (y * scaleY - y);\r\n\r\n        if (posY > 0) {\r\n          posY = 0;\r\n        }\r\n\r\n        if (posY < canvasHeight - newImgHeight) {\r\n          posY = canvasHeight - newImgHeight;\r\n        }\r\n      }\r\n\r\n      self.updateCursor(newImgWidth, newImgHeight);\r\n\r\n      $.fancybox.animate(\r\n        $content, {\r\n          top: posY,\r\n          left: posX,\r\n          scaleX: scaleX,\r\n          scaleY: scaleY\r\n        },\r\n        duration || 366,\r\n        function () {\r\n          self.isAnimating = false;\r\n        }\r\n      );\r\n\r\n      // Stop slideshow\r\n      if (self.SlideShow && self.SlideShow.isActive) {\r\n        self.SlideShow.stop();\r\n      }\r\n    },\r\n\r\n    // Scale image to fit inside parent element\r\n    // ========================================\r\n\r\n    scaleToFit: function (duration) {\r\n      var self = this,\r\n        current = self.current,\r\n        $content = current.$content,\r\n        end;\r\n\r\n      if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {\r\n        return;\r\n      }\r\n\r\n      self.isAnimating = true;\r\n\r\n      $.fancybox.stop($content);\r\n\r\n      end = self.getFitPos(current);\r\n\r\n      self.updateCursor(end.width, end.height);\r\n\r\n      $.fancybox.animate(\r\n        $content, {\r\n          top: end.top,\r\n          left: end.left,\r\n          scaleX: end.width / $content.width(),\r\n          scaleY: end.height / $content.height()\r\n        },\r\n        duration || 366,\r\n        function () {\r\n          self.isAnimating = false;\r\n        }\r\n      );\r\n    },\r\n\r\n    // Calculate image size to fit inside viewport\r\n    // ===========================================\r\n\r\n    getFitPos: function (slide) {\r\n      var self = this,\r\n        $content = slide.$content,\r\n        $slide = slide.$slide,\r\n        width = slide.width || slide.opts.width,\r\n        height = slide.height || slide.opts.height,\r\n        maxWidth,\r\n        maxHeight,\r\n        minRatio,\r\n        aspectRatio,\r\n        rez = {};\r\n\r\n      if (!slide.isLoaded || !$content || !$content.length) {\r\n        return false;\r\n      }\r\n\r\n      maxWidth = $.fancybox.getTranslate(self.$refs.stage).width;\r\n      maxHeight = $.fancybox.getTranslate(self.$refs.stage).height;\r\n\r\n      maxWidth -=\r\n        parseFloat($slide.css("paddingLeft")) +\r\n        parseFloat($slide.css("paddingRight")) +\r\n        parseFloat($content.css("marginLeft")) +\r\n        parseFloat($content.css("marginRight"));\r\n\r\n      maxHeight -=\r\n        parseFloat($slide.css("paddingTop")) +\r\n        parseFloat($slide.css("paddingBottom")) +\r\n        parseFloat($content.css("marginTop")) +\r\n        parseFloat($content.css("marginBottom"));\r\n\r\n      if (!width || !height) {\r\n        width = maxWidth;\r\n        height = maxHeight;\r\n      }\r\n\r\n      minRatio = Math.min(1, maxWidth / width, maxHeight / height);\r\n\r\n      width = minRatio * width;\r\n      height = minRatio * height;\r\n\r\n      // Adjust width/height to precisely fit into container\r\n      if (width > maxWidth - 0.5) {\r\n        width = maxWidth;\r\n      }\r\n\r\n      if (height > maxHeight - 0.5) {\r\n        height = maxHeight;\r\n      }\r\n\r\n      if (slide.type === "image") {\r\n        rez.top = Math.floor((maxHeight - height) * 0.5) + parseFloat($slide.css("paddingTop"));\r\n        rez.left = Math.floor((maxWidth - width) * 0.5) + parseFloat($slide.css("paddingLeft"));\r\n      } else if (slide.contentType === "video") {\r\n        // Force aspect ratio for the video\r\n        // "I say the whole world must learn of our peaceful waysâ€¦ by force!"\r\n        aspectRatio = slide.opts.width && slide.opts.height ? width / height : slide.opts.ratio || 16 / 9;\r\n\r\n        if (height > width / aspectRatio) {\r\n          height = width / aspectRatio;\r\n        } else if (width > height * aspectRatio) {\r\n          width = height * aspectRatio;\r\n        }\r\n      }\r\n\r\n      rez.width = width;\r\n      rez.height = height;\r\n\r\n      return rez;\r\n    },\r\n\r\n    // Update content size and position for all slides\r\n    // ==============================================\r\n\r\n    update: function (e) {\r\n      var self = this;\r\n\r\n      $.each(self.slides, function (key, slide) {\r\n        self.updateSlide(slide, e);\r\n      });\r\n    },\r\n\r\n    // Update slide content position and size\r\n    // ======================================\r\n\r\n    updateSlide: function (slide, e) {\r\n      var self = this,\r\n        $content = slide && slide.$content,\r\n        width = slide.width || slide.opts.width,\r\n        height = slide.height || slide.opts.height,\r\n        $slide = slide.$slide;\r\n\r\n      // First, prevent caption overlap, if needed\r\n      self.adjustCaption(slide);\r\n\r\n      // Then resize content to fit inside the slide\r\n      if ($content && (width || height || slide.contentType === "video") && !slide.hasError) {\r\n        $.fancybox.stop($content);\r\n\r\n        $.fancybox.setTranslate($content, self.getFitPos(slide));\r\n\r\n        if (slide.pos === self.currPos) {\r\n          self.isAnimating = false;\r\n\r\n          self.updateCursor();\r\n        }\r\n      }\r\n\r\n      // Then some adjustments\r\n      self.adjustLayout(slide);\r\n\r\n      if ($slide.length) {\r\n        $slide.trigger("refresh");\r\n\r\n        if (slide.pos === self.currPos) {\r\n          self.$refs.toolbar\r\n            .add(self.$refs.navigation.find(".fancybox-button--arrow_right"))\r\n            .toggleClass("compensate-for-scrollbar", $slide.get(0).scrollHeight > $slide.get(0).clientHeight);\r\n        }\r\n      }\r\n\r\n      self.trigger("onUpdate", slide, e);\r\n    },\r\n\r\n    // Horizontally center slide\r\n    // =========================\r\n\r\n    centerSlide: function (duration) {\r\n      var self = this,\r\n        current = self.current,\r\n        $slide = current.$slide;\r\n\r\n      if (self.isClosing || !current) {\r\n        return;\r\n      }\r\n\r\n      $slide.siblings().css({\r\n        transform: "",\r\n        opacity: ""\r\n      });\r\n\r\n      $slide\r\n        .parent()\r\n        .children()\r\n        .removeClass("fancybox-slide--previous fancybox-slide--next");\r\n\r\n      $.fancybox.animate(\r\n        $slide, {\r\n          top: 0,\r\n          left: 0,\r\n          opacity: 1\r\n        },\r\n        duration === undefined ? 0 : duration,\r\n        function () {\r\n          // Clean up\r\n          $slide.css({\r\n            transform: "",\r\n            opacity: ""\r\n          });\r\n\r\n          if (!current.isComplete) {\r\n            self.complete();\r\n          }\r\n        },\r\n        false\r\n      );\r\n    },\r\n\r\n    // Check if current slide is moved (swiped)\r\n    // ========================================\r\n\r\n    isMoved: function (slide) {\r\n      var current = slide || this.current,\r\n        slidePos,\r\n        stagePos;\r\n\r\n      if (!current) {\r\n        return false;\r\n      }\r\n\r\n      stagePos = $.fancybox.getTranslate(this.$refs.stage);\r\n      slidePos = $.fancybox.getTranslate(current.$slide);\r\n\r\n      return (\r\n        !current.$slide.hasClass("fancybox-animated") &&\r\n        (Math.abs(slidePos.top - stagePos.top) > 0.5 || Math.abs(slidePos.left - stagePos.left) > 0.5)\r\n      );\r\n    },\r\n\r\n    // Update cursor style depending if content can be zoomed\r\n    // ======================================================\r\n\r\n    updateCursor: function (nextWidth, nextHeight) {\r\n      var self = this,\r\n        current = self.current,\r\n        $container = self.$refs.container,\r\n        canPan,\r\n        isZoomable;\r\n\r\n      if (!current || self.isClosing || !self.Guestures) {\r\n        return;\r\n      }\r\n\r\n      $container.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan");\r\n\r\n      canPan = self.canPan(nextWidth, nextHeight);\r\n\r\n      isZoomable = canPan ? true : self.isZoomable();\r\n\r\n      $container.toggleClass("fancybox-is-zoomable", isZoomable);\r\n\r\n      $("[data-fancybox-zoom]").prop("disabled", !isZoomable);\r\n\r\n      if (canPan) {\r\n        $container.addClass("fancybox-can-pan");\r\n      } else if (\r\n        isZoomable &&\r\n        (current.opts.clickContent === "zoom" || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) == "zoom"))\r\n      ) {\r\n        $container.addClass("fancybox-can-zoomIn");\r\n      } else if (current.opts.touch && (current.opts.touch.vertical || self.group.length > 1) && current.contentType !== "video") {\r\n        $container.addClass("fancybox-can-swipe");\r\n      }\r\n    },\r\n\r\n    // Check if current slide is zoomable\r\n    // ==================================\r\n\r\n    isZoomable: function () {\r\n      var self = this,\r\n        current = self.current,\r\n        fitPos;\r\n\r\n      // Assume that slide is zoomable if:\r\n      //   - image is still loading\r\n      //   - actual size of the image is smaller than available area\r\n      if (current && !self.isClosing && current.type === "image" && !current.hasError) {\r\n        if (!current.isLoaded) {\r\n          return true;\r\n        }\r\n\r\n        fitPos = self.getFitPos(current);\r\n\r\n        if (fitPos && (current.width > fitPos.width || current.height > fitPos.height)) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    // Check if current image dimensions are smaller than actual\r\n    // =========================================================\r\n\r\n    isScaledDown: function (nextWidth, nextHeight) {\r\n      var self = this,\r\n        rez = false,\r\n        current = self.current,\r\n        $content = current.$content;\r\n\r\n      if (nextWidth !== undefined && nextHeight !== undefined) {\r\n        rez = nextWidth < current.width && nextHeight < current.height;\r\n      } else if ($content) {\r\n        rez = $.fancybox.getTranslate($content);\r\n        rez = rez.width < current.width && rez.height < current.height;\r\n      }\r\n\r\n      return rez;\r\n    },\r\n\r\n    // Check if image dimensions exceed parent element\r\n    // ===============================================\r\n\r\n    canPan: function (nextWidth, nextHeight) {\r\n      var self = this,\r\n        current = self.current,\r\n        pos = null,\r\n        rez = false;\r\n\r\n      if (current.type === "image" && (current.isComplete || (nextWidth && nextHeight)) && !current.hasError) {\r\n        rez = self.getFitPos(current);\r\n\r\n        if (nextWidth !== undefined && nextHeight !== undefined) {\r\n          pos = {\r\n            width: nextWidth,\r\n            height: nextHeight\r\n          };\r\n        } else if (current.isComplete) {\r\n          pos = $.fancybox.getTranslate(current.$content);\r\n        }\r\n\r\n        if (pos && rez) {\r\n          rez = Math.abs(pos.width - rez.width) > 1.5 || Math.abs(pos.height - rez.height) > 1.5;\r\n        }\r\n      }\r\n\r\n      return rez;\r\n    },\r\n\r\n    // Load content into the slide\r\n    // ===========================\r\n\r\n    loadSlide: function (slide) {\r\n      var self = this,\r\n        type,\r\n        $slide,\r\n        ajaxLoad;\r\n\r\n      if (slide.isLoading || slide.isLoaded) {\r\n        return;\r\n      }\r\n\r\n      slide.isLoading = true;\r\n\r\n      if (self.trigger("beforeLoad", slide) === false) {\r\n        slide.isLoading = false;\r\n\r\n        return false;\r\n      }\r\n\r\n      type = slide.type;\r\n      $slide = slide.$slide;\r\n\r\n      $slide\r\n        .off("refresh")\r\n        .trigger("onReset")\r\n        .addClass(slide.opts.slideClass);\r\n\r\n      // Create content depending on the type\r\n      switch (type) {\r\n        case "image":\r\n          self.setImage(slide);\r\n\r\n          break;\r\n\r\n        case "iframe":\r\n          self.setIframe(slide);\r\n\r\n          break;\r\n\r\n        case "html":\r\n          self.setContent(slide, slide.src || slide.content);\r\n\r\n          break;\r\n\r\n        case "video":\r\n          self.setContent(\r\n            slide,\r\n            slide.opts.video.tpl\r\n            .replace(/\\{\\{src\\}\\}/gi, slide.src)\r\n            .replace("{{format}}", slide.opts.videoFormat || slide.opts.video.format || "")\r\n            .replace("{{poster}}", slide.thumb || "")\r\n          );\r\n\r\n          break;\r\n\r\n        case "inline":\r\n          if ($(slide.src).length) {\r\n            self.setContent(slide, $(slide.src));\r\n          } else {\r\n            self.setError(slide);\r\n          }\r\n\r\n          break;\r\n\r\n        case "ajax":\r\n          self.showLoading(slide);\r\n\r\n          ajaxLoad = $.ajax(\r\n            $.extend({}, slide.opts.ajax.settings, {\r\n              url: slide.src,\r\n              success: function (data, textStatus) {\r\n                if (textStatus === "success") {\r\n                  self.setContent(slide, data);\r\n                }\r\n              },\r\n              error: function (jqXHR, textStatus) {\r\n                if (jqXHR && textStatus !== "abort") {\r\n                  self.setError(slide);\r\n                }\r\n              }\r\n            })\r\n          );\r\n\r\n          $slide.one("onReset", function () {\r\n            ajaxLoad.abort();\r\n          });\r\n\r\n          break;\r\n\r\n        default:\r\n          self.setError(slide);\r\n\r\n          break;\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    // Use thumbnail image, if possible\r\n    // ================================\r\n\r\n    setImage: function (slide) {\r\n      var self = this,\r\n        ghost;\r\n\r\n      // Check if need to show loading icon\r\n      setTimeout(function () {\r\n        var $img = slide.$image;\r\n\r\n        if (!self.isClosing && slide.isLoading && (!$img || !$img.length || !$img[0].complete) && !slide.hasError) {\r\n          self.showLoading(slide);\r\n        }\r\n      }, 50);\r\n\r\n      //Check if image has srcset\r\n      self.checkSrcset(slide);\r\n\r\n      // This will be wrapper containing both ghost and actual image\r\n      slide.$content = $(\'<div class="fancybox-content"></div>\')\r\n        .addClass("fancybox-is-hidden")\r\n        .appendTo(slide.$slide.addClass("fancybox-slide--image"));\r\n\r\n      // If we have a thumbnail, we can display it while actual image is loading\r\n      // Users will not stare at black screen and actual image will appear gradually\r\n      if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && slide.thumb) {\r\n        slide.width = slide.opts.width;\r\n        slide.height = slide.opts.height;\r\n\r\n        ghost = document.createElement("img");\r\n\r\n        ghost.onerror = function () {\r\n          $(this).remove();\r\n\r\n          slide.$ghost = null;\r\n        };\r\n\r\n        ghost.onload = function () {\r\n          self.afterLoad(slide);\r\n        };\r\n\r\n        slide.$ghost = $(ghost)\r\n          .addClass("fancybox-image")\r\n          .appendTo(slide.$content)\r\n          .attr("src", slide.thumb);\r\n      }\r\n\r\n      // Start loading actual image\r\n      self.setBigImage(slide);\r\n    },\r\n\r\n    // Check if image has srcset and get the source\r\n    // ============================================\r\n    checkSrcset: function (slide) {\r\n      var srcset = slide.opts.srcset || slide.opts.image.srcset,\r\n        found,\r\n        temp,\r\n        pxRatio,\r\n        windowWidth;\r\n\r\n      // If we have "srcset", then we need to find first matching "src" value.\r\n      // This is necessary, because when you set an src attribute, the browser will preload the image\r\n      // before any javascript or even CSS is applied.\r\n      if (srcset) {\r\n        pxRatio = window.devicePixelRatio || 1;\r\n        windowWidth = window.innerWidth * pxRatio;\r\n\r\n        temp = srcset.split(",").map(function (el) {\r\n          var ret = {};\r\n\r\n          el.trim()\r\n            .split(/\\s+/)\r\n            .forEach(function (el, i) {\r\n              var value = parseInt(el.substring(0, el.length - 1), 10);\r\n\r\n              if (i === 0) {\r\n                return (ret.url = el);\r\n              }\r\n\r\n              if (value) {\r\n                ret.value = value;\r\n                ret.postfix = el[el.length - 1];\r\n              }\r\n            });\r\n\r\n          return ret;\r\n        });\r\n\r\n        // Sort by value\r\n        temp.sort(function (a, b) {\r\n          return a.value - b.value;\r\n        });\r\n\r\n        // Ok, now we have an array of all srcset values\r\n        for (var j = 0; j < temp.length; j++) {\r\n          var el = temp[j];\r\n\r\n          if ((el.postfix === "w" && el.value >= windowWidth) || (el.postfix === "x" && el.value >= pxRatio)) {\r\n            found = el;\r\n            break;\r\n          }\r\n        }\r\n\r\n        // If not found, take the last one\r\n        if (!found && temp.length) {\r\n          found = temp[temp.length - 1];\r\n        }\r\n\r\n        if (found) {\r\n          slide.src = found.url;\r\n\r\n          // If we have default width/height values, we can calculate height for matching source\r\n          if (slide.width && slide.height && found.postfix == "w") {\r\n            slide.height = (slide.width / slide.height) * found.value;\r\n            slide.width = found.value;\r\n          }\r\n\r\n          slide.opts.srcset = srcset;\r\n        }\r\n      }\r\n    },\r\n\r\n    // Create full-size image\r\n    // ======================\r\n\r\n    setBigImage: function (slide) {\r\n      var self = this,\r\n        img = document.createElement("img"),\r\n        $img = $(img);\r\n\r\n      slide.$image = $img\r\n        .one("error", function () {\r\n          self.setError(slide);\r\n        })\r\n        .one("load", function () {\r\n          var sizes;\r\n\r\n          if (!slide.$ghost) {\r\n            self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight);\r\n\r\n            self.afterLoad(slide);\r\n          }\r\n\r\n          if (self.isClosing) {\r\n            return;\r\n          }\r\n\r\n          if (slide.opts.srcset) {\r\n            sizes = slide.opts.sizes;\r\n\r\n            if (!sizes || sizes === "auto") {\r\n              sizes =\r\n                (slide.width / slide.height > 1 && $W.width() / $W.height() > 1 ? "100" : Math.round((slide.width / slide.height) * 100)) +\r\n                "vw";\r\n            }\r\n\r\n            $img.attr("sizes", sizes).attr("srcset", slide.opts.srcset);\r\n          }\r\n\r\n          // Hide temporary image after some delay\r\n          if (slide.$ghost) {\r\n            setTimeout(function () {\r\n              if (slide.$ghost && !self.isClosing) {\r\n                slide.$ghost.hide();\r\n              }\r\n            }, Math.min(300, Math.max(1000, slide.height / 1600)));\r\n          }\r\n\r\n          self.hideLoading(slide);\r\n        })\r\n        .addClass("fancybox-image")\r\n        .attr("src", slide.src)\r\n        .appendTo(slide.$content);\r\n\r\n      if ((img.complete || img.readyState == "complete") && $img.naturalWidth && $img.naturalHeight) {\r\n        $img.trigger("load");\r\n      } else if (img.error) {\r\n        $img.trigger("error");\r\n      }\r\n    },\r\n\r\n    // Computes the slide size from image size and maxWidth/maxHeight\r\n    // ==============================================================\r\n\r\n    resolveImageSlideSize: function (slide, imgWidth, imgHeight) {\r\n      var maxWidth = parseInt(slide.opts.width, 10),\r\n        maxHeight = parseInt(slide.opts.height, 10);\r\n\r\n      // Sets the default values from the image\r\n      slide.width = imgWidth;\r\n      slide.height = imgHeight;\r\n\r\n      if (maxWidth > 0) {\r\n        slide.width = maxWidth;\r\n        slide.height = Math.floor((maxWidth * imgHeight) / imgWidth);\r\n      }\r\n\r\n      if (maxHeight > 0) {\r\n        slide.width = Math.floor((maxHeight * imgWidth) / imgHeight);\r\n        slide.height = maxHeight;\r\n      }\r\n    },\r\n\r\n    // Create iframe wrapper, iframe and bindings\r\n    // ==========================================\r\n\r\n    setIframe: function (slide) {\r\n      var self = this,\r\n        opts = slide.opts.iframe,\r\n        $slide = slide.$slide,\r\n        $iframe;\r\n\r\n      slide.$content = $(\'<div class="fancybox-content\' + (opts.preload ? " fancybox-is-hidden" : "") + \'"></div>\')\r\n        .css(opts.css)\r\n        .appendTo($slide);\r\n\r\n      $slide.addClass("fancybox-slide--" + slide.contentType);\r\n\r\n      slide.$iframe = $iframe = $(opts.tpl.replace(/\\{rnd\\}/g, new Date().getTime()))\r\n        .attr(opts.attr)\r\n        .appendTo(slide.$content);\r\n\r\n      if (opts.preload) {\r\n        self.showLoading(slide);\r\n\r\n        // Unfortunately, it is not always possible to determine if iframe is successfully loaded\r\n        // (due to browser security policy)\r\n\r\n        $iframe.on("load.fb error.fb", function (e) {\r\n          this.isReady = 1;\r\n\r\n          slide.$slide.trigger("refresh");\r\n\r\n          self.afterLoad(slide);\r\n        });\r\n\r\n        // Recalculate iframe content size\r\n        // ===============================\r\n\r\n        $slide.on("refresh.fb", function () {\r\n          var $content = slide.$content,\r\n            frameWidth = opts.css.width,\r\n            frameHeight = opts.css.height,\r\n            $contents,\r\n            $body;\r\n\r\n          if ($iframe[0].isReady !== 1) {\r\n            return;\r\n          }\r\n\r\n          try {\r\n            $contents = $iframe.contents();\r\n            $body = $contents.find("body");\r\n          } catch (ignore) {}\r\n\r\n          // Calculate content dimensions, if it is accessible\r\n          if ($body && $body.length && $body.children().length) {\r\n            // Avoid scrolling to top (if multiple instances)\r\n            $slide.css("overflow", "visible");\r\n\r\n            $content.css({\r\n              width: "100%",\r\n              "max-width": "100%",\r\n              height: "9999px"\r\n            });\r\n\r\n            if (frameWidth === undefined) {\r\n              frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true)));\r\n            }\r\n\r\n            $content.css("width", frameWidth ? frameWidth : "").css("max-width", "");\r\n\r\n            if (frameHeight === undefined) {\r\n              frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true)));\r\n            }\r\n\r\n            $content.css("height", frameHeight ? frameHeight : "");\r\n\r\n            $slide.css("overflow", "auto");\r\n          }\r\n\r\n          $content.removeClass("fancybox-is-hidden");\r\n        });\r\n      } else {\r\n        self.afterLoad(slide);\r\n      }\r\n\r\n      $iframe.attr("src", slide.src);\r\n\r\n      // Remove iframe if closing or changing gallery item\r\n      $slide.one("onReset", function () {\r\n        // This helps IE not to throw errors when closing\r\n        try {\r\n          $(this)\r\n            .find("iframe")\r\n            .hide()\r\n            .unbind()\r\n            .attr("src", "//about:blank");\r\n        } catch (ignore) {}\r\n\r\n        $(this)\r\n          .off("refresh.fb")\r\n          .empty();\r\n\r\n        slide.isLoaded = false;\r\n        slide.isRevealed = false;\r\n      });\r\n    },\r\n\r\n    // Wrap and append content to the slide\r\n    // ======================================\r\n\r\n    setContent: function (slide, content) {\r\n      var self = this;\r\n\r\n      if (self.isClosing) {\r\n        return;\r\n      }\r\n\r\n      self.hideLoading(slide);\r\n\r\n      if (slide.$content) {\r\n        $.fancybox.stop(slide.$content);\r\n      }\r\n\r\n      slide.$slide.empty();\r\n\r\n      // If content is a jQuery object, then it will be moved to the slide.\r\n      // The placeholder is created so we will know where to put it back.\r\n      if (isQuery(content) && content.parent().length) {\r\n        // Make sure content is not already moved to fancyBox\r\n        if (content.hasClass("fancybox-content") || content.parent().hasClass("fancybox-content")) {\r\n          content.parents(".fancybox-slide").trigger("onReset");\r\n        }\r\n\r\n        // Create temporary element marking original place of the content\r\n        slide.$placeholder = $("<div>")\r\n          .hide()\r\n          .insertAfter(content);\r\n\r\n        // Make sure content is visible\r\n        content.css("display", "inline-block");\r\n      } else if (!slide.hasError) {\r\n        // If content is just a plain text, try to convert it to html\r\n        if ($.type(content) === "string") {\r\n          content = $("<div>")\r\n            .append($.trim(content))\r\n            .contents();\r\n        }\r\n\r\n        // If "filter" option is provided, then filter content\r\n        if (slide.opts.filter) {\r\n          content = $("<div>")\r\n            .html(content)\r\n            .find(slide.opts.filter);\r\n        }\r\n      }\r\n\r\n      slide.$slide.one("onReset", function () {\r\n        // Pause all html5 video/audio\r\n        $(this)\r\n          .find("video,audio")\r\n          .trigger("pause");\r\n\r\n        // Put content back\r\n        if (slide.$placeholder) {\r\n          slide.$placeholder.after(content.removeClass("fancybox-content").hide()).remove();\r\n\r\n          slide.$placeholder = null;\r\n        }\r\n\r\n        // Remove custom close button\r\n        if (slide.$smallBtn) {\r\n          slide.$smallBtn.remove();\r\n\r\n          slide.$smallBtn = null;\r\n        }\r\n\r\n        // Remove content and mark slide as not loaded\r\n        if (!slide.hasError) {\r\n          $(this).empty();\r\n\r\n          slide.isLoaded = false;\r\n          slide.isRevealed = false;\r\n        }\r\n      });\r\n\r\n      $(content).appendTo(slide.$slide);\r\n\r\n      if ($(content).is("video,audio")) {\r\n        $(content).addClass("fancybox-video");\r\n\r\n        $(content).wrap("<div></div>");\r\n\r\n        slide.contentType = "video";\r\n\r\n        slide.opts.width = slide.opts.width || $(content).attr("width");\r\n        slide.opts.height = slide.opts.height || $(content).attr("height");\r\n      }\r\n\r\n      slide.$content = slide.$slide\r\n        .children()\r\n        .filter("div,form,main,video,audio,article,.fancybox-content")\r\n        .first();\r\n\r\n      slide.$content.siblings().hide();\r\n\r\n      // Re-check if there is a valid content\r\n      // (in some cases, ajax response can contain various elements or plain text)\r\n      if (!slide.$content.length) {\r\n        slide.$content = slide.$slide\r\n          .wrapInner("<div></div>")\r\n          .children()\r\n          .first();\r\n      }\r\n\r\n      slide.$content.addClass("fancybox-content");\r\n\r\n      slide.$slide.addClass("fancybox-slide--" + slide.contentType);\r\n\r\n      self.afterLoad(slide);\r\n    },\r\n\r\n    // Display error message\r\n    // =====================\r\n\r\n    setError: function (slide) {\r\n      slide.hasError = true;\r\n\r\n      slide.$slide\r\n        .trigger("onReset")\r\n        .removeClass("fancybox-slide--" + slide.contentType)\r\n        .addClass("fancybox-slide--error");\r\n\r\n      slide.contentType = "html";\r\n\r\n      this.setContent(slide, this.translate(slide, slide.opts.errorTpl));\r\n\r\n      if (slide.pos === this.currPos) {\r\n        this.isAnimating = false;\r\n      }\r\n    },\r\n\r\n    // Show loading icon inside the slide\r\n    // ==================================\r\n\r\n    showLoading: function (slide) {\r\n      var self = this;\r\n\r\n      slide = slide || self.current;\r\n\r\n      if (slide && !slide.$spinner) {\r\n        slide.$spinner = $(self.translate(self, self.opts.spinnerTpl))\r\n          .appendTo(slide.$slide)\r\n          .hide()\r\n          .fadeIn("fast");\r\n      }\r\n    },\r\n\r\n    // Remove loading icon from the slide\r\n    // ==================================\r\n\r\n    hideLoading: function (slide) {\r\n      var self = this;\r\n\r\n      slide = slide || self.current;\r\n\r\n      if (slide && slide.$spinner) {\r\n        slide.$spinner.stop().remove();\r\n\r\n        delete slide.$spinner;\r\n      }\r\n    },\r\n\r\n    // Adjustments after slide content has been loaded\r\n    // ===============================================\r\n\r\n    afterLoad: function (slide) {\r\n      var self = this;\r\n\r\n      if (self.isClosing) {\r\n        return;\r\n      }\r\n\r\n      slide.isLoading = false;\r\n      slide.isLoaded = true;\r\n\r\n      self.trigger("afterLoad", slide);\r\n\r\n      self.hideLoading(slide);\r\n\r\n      // Add small close button\r\n      if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) {\r\n        slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content);\r\n      }\r\n\r\n      // Disable right click\r\n      if (slide.opts.protect && slide.$content && !slide.hasError) {\r\n        slide.$content.on("contextmenu.fb", function (e) {\r\n          if (e.button == 2) {\r\n            e.preventDefault();\r\n          }\r\n\r\n          return true;\r\n        });\r\n\r\n        // Add fake element on top of the image\r\n        // This makes a bit harder for user to select image\r\n        if (slide.type === "image") {\r\n          $(\'<div class="fancybox-spaceball"></div>\').appendTo(slide.$content);\r\n        }\r\n      }\r\n\r\n      self.adjustCaption(slide);\r\n\r\n      self.adjustLayout(slide);\r\n\r\n      if (slide.pos === self.currPos) {\r\n        self.updateCursor();\r\n      }\r\n\r\n      self.revealContent(slide);\r\n    },\r\n\r\n    // Prevent caption overlap,\r\n    // fix css inconsistency across browsers\r\n    // =====================================\r\n\r\n    adjustCaption: function (slide) {\r\n      var self = this,\r\n        current = slide || self.current,\r\n        caption = current.opts.caption,\r\n        preventOverlap = current.opts.preventCaptionOverlap,\r\n        $caption = self.$refs.caption,\r\n        $clone,\r\n        captionH = false;\r\n\r\n      $caption.toggleClass("fancybox-caption--separate", preventOverlap);\r\n\r\n      if (preventOverlap && caption && caption.length) {\r\n        if (current.pos !== self.currPos) {\r\n          $clone = $caption.clone().appendTo($caption.parent());\r\n\r\n          $clone\r\n            .children()\r\n            .eq(0)\r\n            .empty()\r\n            .html(caption);\r\n\r\n          captionH = $clone.outerHeight(true);\r\n\r\n          $clone.empty().remove();\r\n        } else if (self.$caption) {\r\n          captionH = self.$caption.outerHeight(true);\r\n        }\r\n\r\n        current.$slide.css("padding-bottom", captionH || "");\r\n      }\r\n    },\r\n\r\n    // Simple hack to fix inconsistency across browsers, described here (affects Edge, too):\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=748518\r\n    // ====================================================================================\r\n\r\n    adjustLayout: function (slide) {\r\n      var self = this,\r\n        current = slide || self.current,\r\n        scrollHeight,\r\n        marginBottom,\r\n        inlinePadding,\r\n        actualPadding;\r\n\r\n      if (current.isLoaded && current.opts.disableLayoutFix !== true) {\r\n        current.$content.css("margin-bottom", "");\r\n\r\n        // If we would always set margin-bottom for the content,\r\n        // then it would potentially break vertical align\r\n        if (current.$content.outerHeight() > current.$slide.height() + 0.5) {\r\n          inlinePadding = current.$slide[0].style["padding-bottom"];\r\n          actualPadding = current.$slide.css("padding-bottom");\r\n\r\n          if (parseFloat(actualPadding) > 0) {\r\n            scrollHeight = current.$slide[0].scrollHeight;\r\n\r\n            current.$slide.css("padding-bottom", 0);\r\n\r\n            if (Math.abs(scrollHeight - current.$slide[0].scrollHeight) < 1) {\r\n              marginBottom = actualPadding;\r\n            }\r\n\r\n            current.$slide.css("padding-bottom", inlinePadding);\r\n          }\r\n        }\r\n\r\n        current.$content.css("margin-bottom", marginBottom);\r\n      }\r\n    },\r\n\r\n    // Make content visible\r\n    // This method is called right after content has been loaded or\r\n    // user navigates gallery and transition should start\r\n    // ============================================================\r\n\r\n    revealContent: function (slide) {\r\n      var self = this,\r\n        $slide = slide.$slide,\r\n        end = false,\r\n        start = false,\r\n        isMoved = self.isMoved(slide),\r\n        isRevealed = slide.isRevealed,\r\n        effect,\r\n        effectClassName,\r\n        duration,\r\n        opacity;\r\n\r\n      slide.isRevealed = true;\r\n\r\n      effect = slide.opts[self.firstRun ? "animationEffect" : "transitionEffect"];\r\n      duration = slide.opts[self.firstRun ? "animationDuration" : "transitionDuration"];\r\n\r\n      duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);\r\n\r\n      if (isMoved || slide.pos !== self.currPos || !duration) {\r\n        effect = false;\r\n      }\r\n\r\n      // Check if can zoom\r\n      if (effect === "zoom") {\r\n        if (slide.pos === self.currPos && duration && slide.type === "image" && !slide.hasError && (start = self.getThumbPos(slide))) {\r\n          end = self.getFitPos(slide);\r\n        } else {\r\n          effect = "fade";\r\n        }\r\n      }\r\n\r\n      // Zoom animation\r\n      // ==============\r\n      if (effect === "zoom") {\r\n        self.isAnimating = true;\r\n\r\n        end.scaleX = end.width / start.width;\r\n        end.scaleY = end.height / start.height;\r\n\r\n        // Check if we need to animate opacity\r\n        opacity = slide.opts.zoomOpacity;\r\n\r\n        if (opacity == "auto") {\r\n          opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;\r\n        }\r\n\r\n        if (opacity) {\r\n          start.opacity = 0.1;\r\n          end.opacity = 1;\r\n        }\r\n\r\n        // Draw image at start position\r\n        $.fancybox.setTranslate(slide.$content.removeClass("fancybox-is-hidden"), start);\r\n\r\n        forceRedraw(slide.$content);\r\n\r\n        // Start animation\r\n        $.fancybox.animate(slide.$content, end, duration, function () {\r\n          self.isAnimating = false;\r\n\r\n          self.complete();\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      self.updateSlide(slide);\r\n\r\n      // Simply show content if no effect\r\n      // ================================\r\n      if (!effect) {\r\n        slide.$content.removeClass("fancybox-is-hidden");\r\n\r\n        if (!isRevealed && isMoved && slide.type === "image" && !slide.hasError) {\r\n          slide.$content.hide().fadeIn("fast");\r\n        }\r\n\r\n        if (slide.pos === self.currPos) {\r\n          self.complete();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      // Prepare for CSS transiton\r\n      // =========================\r\n      $.fancybox.stop($slide);\r\n\r\n      //effectClassName = "fancybox-animated fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-fx-" + effect;\r\n      effectClassName = "fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-animated fancybox-fx-" + effect;\r\n\r\n      $slide.addClass(effectClassName).removeClass("fancybox-slide--current"); //.addClass(effectClassName);\r\n\r\n      slide.$content.removeClass("fancybox-is-hidden");\r\n\r\n      // Force reflow\r\n      forceRedraw($slide);\r\n\r\n      if (slide.type !== "image") {\r\n        slide.$content.hide().show(0);\r\n      }\r\n\r\n      $.fancybox.animate(\r\n        $slide,\r\n        "fancybox-slide--current",\r\n        duration,\r\n        function () {\r\n          $slide.removeClass(effectClassName).css({\r\n            transform: "",\r\n            opacity: ""\r\n          });\r\n\r\n          if (slide.pos === self.currPos) {\r\n            self.complete();\r\n          }\r\n        },\r\n        true\r\n      );\r\n    },\r\n\r\n    // Check if we can and have to zoom from thumbnail\r\n    //================================================\r\n\r\n    getThumbPos: function (slide) {\r\n      var rez = false,\r\n        $thumb = slide.$thumb,\r\n        thumbPos,\r\n        btw,\r\n        brw,\r\n        bbw,\r\n        blw;\r\n\r\n      if (!$thumb || !inViewport($thumb[0])) {\r\n        return false;\r\n      }\r\n\r\n      thumbPos = $.fancybox.getTranslate($thumb);\r\n\r\n      btw = parseFloat($thumb.css("border-top-width") || 0);\r\n      brw = parseFloat($thumb.css("border-right-width") || 0);\r\n      bbw = parseFloat($thumb.css("border-bottom-width") || 0);\r\n      blw = parseFloat($thumb.css("border-left-width") || 0);\r\n\r\n      rez = {\r\n        top: thumbPos.top + btw,\r\n        left: thumbPos.left + blw,\r\n        width: thumbPos.width - brw - blw,\r\n        height: thumbPos.height - btw - bbw,\r\n        scaleX: 1,\r\n        scaleY: 1\r\n      };\r\n\r\n      return thumbPos.width > 0 && thumbPos.height > 0 ? rez : false;\r\n    },\r\n\r\n    // Final adjustments after current gallery item is moved to position\r\n    // and it`s content is loaded\r\n    // ==================================================================\r\n\r\n    complete: function () {\r\n      var self = this,\r\n        current = self.current,\r\n        slides = {},\r\n        $el;\r\n\r\n      if (self.isMoved() || !current.isLoaded) {\r\n        return;\r\n      }\r\n\r\n      if (!current.isComplete) {\r\n        current.isComplete = true;\r\n\r\n        current.$slide.siblings().trigger("onReset");\r\n\r\n        self.preload("inline");\r\n\r\n        // Trigger any CSS transiton inside the slide\r\n        forceRedraw(current.$slide);\r\n\r\n        current.$slide.addClass("fancybox-slide--complete");\r\n\r\n        // Remove unnecessary slides\r\n        $.each(self.slides, function (key, slide) {\r\n          if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {\r\n            slides[slide.pos] = slide;\r\n          } else if (slide) {\r\n            $.fancybox.stop(slide.$slide);\r\n\r\n            slide.$slide.off().remove();\r\n          }\r\n        });\r\n\r\n        self.slides = slides;\r\n      }\r\n\r\n      self.isAnimating = false;\r\n\r\n      self.updateCursor();\r\n\r\n      self.trigger("afterShow");\r\n\r\n      // Autoplay first html5 video/audio\r\n      if (!!current.opts.video.autoStart) {\r\n        current.$slide\r\n          .find("video,audio")\r\n          .filter(":visible:first")\r\n          .trigger("play")\r\n          .one("ended", function () {\r\n            if (Document.exitFullscreen) {\r\n              Document.exitFullscreen();\r\n            } else if (this.webkitExitFullscreen) {\r\n              this.webkitExitFullscreen();\r\n            }\r\n\r\n            self.next();\r\n          });\r\n      }\r\n\r\n      // Try to focus on the first focusable element\r\n      if (current.opts.autoFocus && current.contentType === "html") {\r\n        // Look for the first input with autofocus attribute\r\n        $el = current.$content.find("input[autofocus]:enabled:visible:first");\r\n\r\n        if ($el.length) {\r\n          $el.trigger("focus");\r\n        } else {\r\n          self.focus(null, true);\r\n        }\r\n      }\r\n\r\n      // Avoid jumping\r\n      current.$slide.scrollTop(0).scrollLeft(0);\r\n    },\r\n\r\n    // Preload next and previous slides\r\n    // ================================\r\n\r\n    preload: function (type) {\r\n      var self = this,\r\n        prev,\r\n        next;\r\n\r\n      if (self.group.length < 2) {\r\n        return;\r\n      }\r\n\r\n      next = self.slides[self.currPos + 1];\r\n      prev = self.slides[self.currPos - 1];\r\n\r\n      if (prev && prev.type === type) {\r\n        self.loadSlide(prev);\r\n      }\r\n\r\n      if (next && next.type === type) {\r\n        self.loadSlide(next);\r\n      }\r\n    },\r\n\r\n    // Try to find and focus on the first focusable element\r\n    // ====================================================\r\n\r\n    focus: function (e, firstRun) {\r\n      var self = this,\r\n        focusableStr = [\r\n          "a[href]",\r\n          "area[href]",\r\n          \'input:not([disabled]):not([type="hidden"]):not([aria-hidden])\',\r\n          "select:not([disabled]):not([aria-hidden])",\r\n          "textarea:not([disabled]):not([aria-hidden])",\r\n          "button:not([disabled]):not([aria-hidden])",\r\n          "iframe",\r\n          "object",\r\n          "embed",\r\n          "video",\r\n          "audio",\r\n          "[contenteditable]",\r\n          \'[tabindex]:not([tabindex^="-"])\'\r\n        ].join(","),\r\n        focusableItems,\r\n        focusedItemIndex;\r\n\r\n      if (self.isClosing) {\r\n        return;\r\n      }\r\n\r\n      if (e || !self.current || !self.current.isComplete) {\r\n        // Focus on any element inside fancybox\r\n        focusableItems = self.$refs.container.find("*:visible");\r\n      } else {\r\n        // Focus inside current slide\r\n        focusableItems = self.current.$slide.find("*:visible" + (firstRun ? ":not(.fancybox-close-small)" : ""));\r\n      }\r\n\r\n      focusableItems = focusableItems.filter(focusableStr).filter(function () {\r\n        return $(this).css("visibility") !== "hidden" && !$(this).hasClass("disabled");\r\n      });\r\n\r\n      if (focusableItems.length) {\r\n        focusedItemIndex = focusableItems.index(document.activeElement);\r\n\r\n        if (e && e.shiftKey) {\r\n          // Back tab\r\n          if (focusedItemIndex < 0 || focusedItemIndex == 0) {\r\n            e.preventDefault();\r\n\r\n            focusableItems.eq(focusableItems.length - 1).trigger("focus");\r\n          }\r\n        } else {\r\n          // Outside or Forward tab\r\n          if (focusedItemIndex < 0 || focusedItemIndex == focusableItems.length - 1) {\r\n            if (e) {\r\n              e.preventDefault();\r\n            }\r\n\r\n            focusableItems.eq(0).trigger("focus");\r\n          }\r\n        }\r\n      } else {\r\n        self.$refs.container.trigger("focus");\r\n      }\r\n    },\r\n\r\n    // Activates current instance - brings container to the front and enables keyboard,\r\n    // notifies other instances about deactivating\r\n    // =================================================================================\r\n\r\n    activate: function () {\r\n      var self = this;\r\n\r\n      // Deactivate all instances\r\n      $(".fancybox-container").each(function () {\r\n        var instance = $(this).data("FancyBox");\r\n\r\n        // Skip self and closing instances\r\n        if (instance && instance.id !== self.id && !instance.isClosing) {\r\n          instance.trigger("onDeactivate");\r\n\r\n          instance.removeEvents();\r\n\r\n          instance.isVisible = false;\r\n        }\r\n      });\r\n\r\n      self.isVisible = true;\r\n\r\n      if (self.current || self.isIdle) {\r\n        self.update();\r\n\r\n        self.updateControls();\r\n      }\r\n\r\n      self.trigger("onActivate");\r\n\r\n      self.addEvents();\r\n    },\r\n\r\n    // Start closing procedure\r\n    // This will start "zoom-out" animation if needed and clean everything up afterwards\r\n    // =================================================================================\r\n\r\n    close: function (e, d) {\r\n      var self = this,\r\n        current = self.current,\r\n        effect,\r\n        duration,\r\n        $content,\r\n        domRect,\r\n        opacity,\r\n        start,\r\n        end;\r\n\r\n      var done = function () {\r\n        self.cleanUp(e);\r\n      };\r\n\r\n      if (self.isClosing) {\r\n        return false;\r\n      }\r\n\r\n      self.isClosing = true;\r\n\r\n      // If beforeClose callback prevents closing, make sure content is centered\r\n      if (self.trigger("beforeClose", e) === false) {\r\n        self.isClosing = false;\r\n\r\n        requestAFrame(function () {\r\n          self.update();\r\n        });\r\n\r\n        return false;\r\n      }\r\n\r\n      // Remove all events\r\n      // If there are multiple instances, they will be set again by "activate" method\r\n      self.removeEvents();\r\n\r\n      $content = current.$content;\r\n      effect = current.opts.animationEffect;\r\n      duration = $.isNumeric(d) ? d : effect ? current.opts.animationDuration : 0;\r\n\r\n      current.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated");\r\n\r\n      if (e !== true) {\r\n        $.fancybox.stop(current.$slide);\r\n      } else {\r\n        effect = false;\r\n      }\r\n\r\n      // Remove other slides\r\n      current.$slide\r\n        .siblings()\r\n        .trigger("onReset")\r\n        .remove();\r\n\r\n      // Trigger animations\r\n      if (duration) {\r\n        self.$refs.container\r\n          .removeClass("fancybox-is-open")\r\n          .addClass("fancybox-is-closing")\r\n          .css("transition-duration", duration + "ms");\r\n      }\r\n\r\n      // Clean up\r\n      self.hideLoading(current);\r\n\r\n      self.hideControls(true);\r\n\r\n      self.updateCursor();\r\n\r\n      // Check if possible to zoom-out\r\n      if (\r\n        effect === "zoom" &&\r\n        !($content && duration && current.type === "image" && !self.isMoved() && !current.hasError && (end = self.getThumbPos(current)))\r\n      ) {\r\n        effect = "fade";\r\n      }\r\n\r\n      if (effect === "zoom") {\r\n        $.fancybox.stop($content);\r\n\r\n        domRect = $.fancybox.getTranslate($content);\r\n\r\n        start = {\r\n          top: domRect.top,\r\n          left: domRect.left,\r\n          scaleX: domRect.width / end.width,\r\n          scaleY: domRect.height / end.height,\r\n          width: end.width,\r\n          height: end.height\r\n        };\r\n\r\n        // Check if we need to animate opacity\r\n        opacity = current.opts.zoomOpacity;\r\n\r\n        if (opacity == "auto") {\r\n          opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;\r\n        }\r\n\r\n        if (opacity) {\r\n          end.opacity = 0;\r\n        }\r\n\r\n        $.fancybox.setTranslate($content, start);\r\n\r\n        forceRedraw($content);\r\n\r\n        $.fancybox.animate($content, end, duration, done);\r\n\r\n        return true;\r\n      }\r\n\r\n      if (effect && duration) {\r\n        $.fancybox.animate(\r\n          current.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"),\r\n          "fancybox-animated fancybox-fx-" + effect,\r\n          duration,\r\n          done\r\n        );\r\n      } else {\r\n        // If skip animation\r\n        if (e === true) {\r\n          setTimeout(done, duration);\r\n        } else {\r\n          done();\r\n        }\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    // Final adjustments after removing the instance\r\n    // =============================================\r\n\r\n    cleanUp: function (e) {\r\n      var self = this,\r\n        instance,\r\n        $focus = self.current.opts.$orig,\r\n        x,\r\n        y;\r\n\r\n      self.current.$slide.trigger("onReset");\r\n\r\n      self.$refs.container.empty().remove();\r\n\r\n      self.trigger("afterClose", e);\r\n\r\n      // Place back focus\r\n      if (!!self.current.opts.backFocus) {\r\n        if (!$focus || !$focus.length || !$focus.is(":visible")) {\r\n          $focus = self.$trigger;\r\n        }\r\n\r\n        if ($focus && $focus.length) {\r\n          x = window.scrollX;\r\n          y = window.scrollY;\r\n\r\n          $focus.trigger("focus");\r\n\r\n          $("html, body")\r\n            .scrollTop(y)\r\n            .scrollLeft(x);\r\n        }\r\n      }\r\n\r\n      self.current = null;\r\n\r\n      // Check if there are other instances\r\n      instance = $.fancybox.getInstance();\r\n\r\n      if (instance) {\r\n        instance.activate();\r\n      } else {\r\n        $("body").removeClass("fancybox-active compensate-for-scrollbar");\r\n\r\n        $("#fancybox-style-noscroll").remove();\r\n      }\r\n    },\r\n\r\n    // Call callback and trigger an event\r\n    // ==================================\r\n\r\n    trigger: function (name, slide) {\r\n      var args = Array.prototype.slice.call(arguments, 1),\r\n        self = this,\r\n        obj = slide && slide.opts ? slide : self.current,\r\n        rez;\r\n\r\n      if (obj) {\r\n        args.unshift(obj);\r\n      } else {\r\n        obj = self;\r\n      }\r\n\r\n      args.unshift(self);\r\n\r\n      if ($.isFunction(obj.opts[name])) {\r\n        rez = obj.opts[name].apply(obj, args);\r\n      }\r\n\r\n      if (rez === false) {\r\n        return rez;\r\n      }\r\n\r\n      if (name === "afterClose" || !self.$refs) {\r\n        $D.trigger(name + ".fb", args);\r\n      } else {\r\n        self.$refs.container.trigger(name + ".fb", args);\r\n      }\r\n    },\r\n\r\n    // Update infobar values, navigation button states and reveal caption\r\n    // ==================================================================\r\n\r\n    updateControls: function () {\r\n      var self = this,\r\n        current = self.current,\r\n        index = current.index,\r\n        $container = self.$refs.container,\r\n        $caption = self.$refs.caption,\r\n        caption = current.opts.caption;\r\n\r\n      // Recalculate content dimensions\r\n      current.$slide.trigger("refresh");\r\n\r\n      // Set caption\r\n      if (caption && caption.length) {\r\n        self.$caption = $caption;\r\n\r\n        $caption\r\n          .children()\r\n          .eq(0)\r\n          .html(caption);\r\n      } else {\r\n        self.$caption = null;\r\n      }\r\n\r\n      if (!self.hasHiddenControls && !self.isIdle) {\r\n        self.showControls();\r\n      }\r\n\r\n      // Update info and navigation elements\r\n      $container.find("[data-fancybox-count]").html(self.group.length);\r\n      $container.find("[data-fancybox-index]").html(index + 1);\r\n\r\n      $container.find("[data-fancybox-prev]").prop("disabled", !current.opts.loop && index <= 0);\r\n      $container.find("[data-fancybox-next]").prop("disabled", !current.opts.loop && index >= self.group.length - 1);\r\n\r\n      if (current.type === "image") {\r\n        // Re-enable buttons; update download button source\r\n        $container\r\n          .find("[data-fancybox-zoom]")\r\n          .show()\r\n          .end()\r\n          .find("[data-fancybox-download]")\r\n          .attr("href", current.opts.image.src || current.src)\r\n          .show();\r\n      } else if (current.opts.toolbar) {\r\n        $container.find("[data-fancybox-download],[data-fancybox-zoom]").hide();\r\n      }\r\n\r\n      // Make sure focus is not on disabled button/element\r\n      if ($(document.activeElement).is(":hidden,[disabled]")) {\r\n        self.$refs.container.trigger("focus");\r\n      }\r\n    },\r\n\r\n    // Hide toolbar and caption\r\n    // ========================\r\n\r\n    hideControls: function (andCaption) {\r\n      var self = this,\r\n        arr = ["infobar", "toolbar", "nav"];\r\n\r\n      if (andCaption || !self.current.opts.preventCaptionOverlap) {\r\n        arr.push("caption");\r\n      }\r\n\r\n      this.$refs.container.removeClass(\r\n        arr\r\n        .map(function (i) {\r\n          return "fancybox-show-" + i;\r\n        })\r\n        .join(" ")\r\n      );\r\n\r\n      this.hasHiddenControls = true;\r\n    },\r\n\r\n    showControls: function () {\r\n      var self = this,\r\n        opts = self.current ? self.current.opts : self.opts,\r\n        $container = self.$refs.container;\r\n\r\n      self.hasHiddenControls = false;\r\n      self.idleSecondsCounter = 0;\r\n\r\n      $container\r\n        .toggleClass("fancybox-show-toolbar", !!(opts.toolbar && opts.buttons))\r\n        .toggleClass("fancybox-show-infobar", !!(opts.infobar && self.group.length > 1))\r\n        .toggleClass("fancybox-show-caption", !!self.$caption)\r\n        .toggleClass("fancybox-show-nav", !!(opts.arrows && self.group.length > 1))\r\n        .toggleClass("fancybox-is-modal", !!opts.modal);\r\n    },\r\n\r\n    // Toggle toolbar and caption\r\n    // ==========================\r\n\r\n    toggleControls: function () {\r\n      if (this.hasHiddenControls) {\r\n        this.showControls();\r\n      } else {\r\n        this.hideControls();\r\n      }\r\n    }\r\n  });\r\n\r\n  $.fancybox = {\r\n    version: "3.5.7",\r\n    defaults: defaults,\r\n\r\n    // Get current instance and execute a command.\r\n    //\r\n    // Examples of usage:\r\n    //\r\n    //   $instance = $.fancybox.getInstance();\r\n    //   $.fancybox.getInstance().jumpTo( 1 );\r\n    //   $.fancybox.getInstance( \'jumpTo\', 1 );\r\n    //   $.fancybox.getInstance( function() {\r\n    //       console.info( this.currIndex );\r\n    //   });\r\n    // ======================================================\r\n\r\n    getInstance: function (command) {\r\n      var instance = $(\'.fancybox-container:not(".fancybox-is-closing"):last\').data("FancyBox"),\r\n        args = Array.prototype.slice.call(arguments, 1);\r\n\r\n      if (instance instanceof FancyBox) {\r\n        if ($.type(command) === "string") {\r\n          instance[command].apply(instance, args);\r\n        } else if ($.type(command) === "function") {\r\n          command.apply(instance, args);\r\n        }\r\n\r\n        return instance;\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    // Create new instance\r\n    // ===================\r\n\r\n    open: function (items, opts, index) {\r\n      return new FancyBox(items, opts, index);\r\n    },\r\n\r\n    // Close current or all instances\r\n    // ==============================\r\n\r\n    close: function (all) {\r\n      var instance = this.getInstance();\r\n\r\n      if (instance) {\r\n        instance.close();\r\n\r\n        // Try to find and close next instance\r\n        if (all === true) {\r\n          this.close(all);\r\n        }\r\n      }\r\n    },\r\n\r\n    // Close all instances and unbind all events\r\n    // =========================================\r\n\r\n    destroy: function () {\r\n      this.close(true);\r\n\r\n      $D.add("body").off("click.fb-start", "**");\r\n    },\r\n\r\n    // Try to detect mobile devices\r\n    // ============================\r\n\r\n    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\r\n\r\n    // Detect if \'translate3d\' support is available\r\n    // ============================================\r\n\r\n    use3d: (function () {\r\n      var div = document.createElement("div");\r\n\r\n      return (\r\n        window.getComputedStyle &&\r\n        window.getComputedStyle(div) &&\r\n        window.getComputedStyle(div).getPropertyValue("transform") &&\r\n        !(document.documentMode && document.documentMode < 11)\r\n      );\r\n    })(),\r\n\r\n    // Helper function to get current visual state of an element\r\n    // returns array[ top, left, horizontal-scale, vertical-scale, opacity ]\r\n    // =====================================================================\r\n\r\n    getTranslate: function ($el) {\r\n      var domRect;\r\n\r\n      if (!$el || !$el.length) {\r\n        return false;\r\n      }\r\n\r\n      domRect = $el[0].getBoundingClientRect();\r\n\r\n      return {\r\n        top: domRect.top || 0,\r\n        left: domRect.left || 0,\r\n        width: domRect.width,\r\n        height: domRect.height,\r\n        opacity: parseFloat($el.css("opacity"))\r\n      };\r\n    },\r\n\r\n    // Shortcut for setting "translate3d" properties for element\r\n    // Can set be used to set opacity, too\r\n    // ========================================================\r\n\r\n    setTranslate: function ($el, props) {\r\n      var str = "",\r\n        css = {};\r\n\r\n      if (!$el || !props) {\r\n        return;\r\n      }\r\n\r\n      if (props.left !== undefined || props.top !== undefined) {\r\n        str =\r\n          (props.left === undefined ? $el.position().left : props.left) +\r\n          "px, " +\r\n          (props.top === undefined ? $el.position().top : props.top) +\r\n          "px";\r\n\r\n        if (this.use3d) {\r\n          str = "translate3d(" + str + ", 0px)";\r\n        } else {\r\n          str = "translate(" + str + ")";\r\n        }\r\n      }\r\n\r\n      if (props.scaleX !== undefined && props.scaleY !== undefined) {\r\n        str += " scale(" + props.scaleX + ", " + props.scaleY + ")";\r\n      } else if (props.scaleX !== undefined) {\r\n        str += " scaleX(" + props.scaleX + ")";\r\n      }\r\n\r\n      if (str.length) {\r\n        css.transform = str;\r\n      }\r\n\r\n      if (props.opacity !== undefined) {\r\n        css.opacity = props.opacity;\r\n      }\r\n\r\n      if (props.width !== undefined) {\r\n        css.width = props.width;\r\n      }\r\n\r\n      if (props.height !== undefined) {\r\n        css.height = props.height;\r\n      }\r\n\r\n      return $el.css(css);\r\n    },\r\n\r\n    // Simple CSS transition handler\r\n    // =============================\r\n\r\n    animate: function ($el, to, duration, callback, leaveAnimationName) {\r\n      var self = this,\r\n        from;\r\n\r\n      if ($.isFunction(duration)) {\r\n        callback = duration;\r\n        duration = null;\r\n      }\r\n\r\n      self.stop($el);\r\n\r\n      from = self.getTranslate($el);\r\n\r\n      $el.on(transitionEnd, function (e) {\r\n        // Skip events from child elements and z-index change\r\n        if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == "z-index")) {\r\n          return;\r\n        }\r\n\r\n        self.stop($el);\r\n\r\n        if ($.isNumeric(duration)) {\r\n          $el.css("transition-duration", "");\r\n        }\r\n\r\n        if ($.isPlainObject(to)) {\r\n          if (to.scaleX !== undefined && to.scaleY !== undefined) {\r\n            self.setTranslate($el, {\r\n              top: to.top,\r\n              left: to.left,\r\n              width: from.width * to.scaleX,\r\n              height: from.height * to.scaleY,\r\n              scaleX: 1,\r\n              scaleY: 1\r\n            });\r\n          }\r\n        } else if (leaveAnimationName !== true) {\r\n          $el.removeClass(to);\r\n        }\r\n\r\n        if ($.isFunction(callback)) {\r\n          callback(e);\r\n        }\r\n      });\r\n\r\n      if ($.isNumeric(duration)) {\r\n        $el.css("transition-duration", duration + "ms");\r\n      }\r\n\r\n      // Start animation by changing CSS properties or class name\r\n      if ($.isPlainObject(to)) {\r\n        if (to.scaleX !== undefined && to.scaleY !== undefined) {\r\n          delete to.width;\r\n          delete to.height;\r\n\r\n          if ($el.parent().hasClass("fancybox-slide--image")) {\r\n            $el.parent().addClass("fancybox-is-scaling");\r\n          }\r\n        }\r\n\r\n        $.fancybox.setTranslate($el, to);\r\n      } else {\r\n        $el.addClass(to);\r\n      }\r\n\r\n      // Make sure that `transitionend` callback gets fired\r\n      $el.data(\r\n        "timer",\r\n        setTimeout(function () {\r\n          $el.trigger(transitionEnd);\r\n        }, duration + 33)\r\n      );\r\n    },\r\n\r\n    stop: function ($el, callCallback) {\r\n      if ($el && $el.length) {\r\n        clearTimeout($el.data("timer"));\r\n\r\n        if (callCallback) {\r\n          $el.trigger(transitionEnd);\r\n        }\r\n\r\n        $el.off(transitionEnd).css("transition-duration", "");\r\n\r\n        $el.parent().removeClass("fancybox-is-scaling");\r\n      }\r\n    }\r\n  };\r\n\r\n  // Default click handler for "fancyboxed" links\r\n  // ============================================\r\n\r\n  function _run(e, opts) {\r\n    var items = [],\r\n      index = 0,\r\n      $target,\r\n      value,\r\n      instance;\r\n\r\n    // Avoid opening multiple times\r\n    if (e && e.isDefaultPrevented()) {\r\n      return;\r\n    }\r\n\r\n    e.preventDefault();\r\n\r\n    opts = opts || {};\r\n\r\n    if (e && e.data) {\r\n      opts = mergeOpts(e.data.options, opts);\r\n    }\r\n\r\n    $target = opts.$target || $(e.currentTarget).trigger("blur");\r\n    instance = $.fancybox.getInstance();\r\n\r\n    if (instance && instance.$trigger && instance.$trigger.is($target)) {\r\n      return;\r\n    }\r\n\r\n    if (opts.selector) {\r\n      items = $(opts.selector);\r\n    } else {\r\n      // Get all related items and find index for clicked one\r\n      value = $target.attr("data-fancybox") || "";\r\n\r\n      if (value) {\r\n        items = e.data ? e.data.items : [];\r\n        items = items.length ? items.filter(\'[data-fancybox="\' + value + \'"]\') : $(\'[data-fancybox="\' + value + \'"]\');\r\n      } else {\r\n        items = [$target];\r\n      }\r\n    }\r\n\r\n    index = $(items).index($target);\r\n\r\n    // Sometimes current item can not be found\r\n    if (index < 0) {\r\n      index = 0;\r\n    }\r\n\r\n    instance = $.fancybox.open(items, opts, index);\r\n\r\n    // Save last active element\r\n    instance.$trigger = $target;\r\n  }\r\n\r\n  // Create a jQuery plugin\r\n  // ======================\r\n\r\n  $.fn.fancybox = function (options) {\r\n    var selector;\r\n\r\n    options = options || {};\r\n    selector = options.selector || false;\r\n\r\n    if (selector) {\r\n      // Use body element instead of document so it executes first\r\n      $("body")\r\n        .off("click.fb-start", selector)\r\n        .on("click.fb-start", selector, {\r\n          options: options\r\n        }, _run);\r\n    } else {\r\n      this.off("click.fb-start").on(\r\n        "click.fb-start", {\r\n          items: this,\r\n          options: options\r\n        },\r\n        _run\r\n      );\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  // Self initializing plugin for all elements having `data-fancybox` attribute\r\n  // ==========================================================================\r\n\r\n  $D.on("click.fb-start", "[data-fancybox]", _run);\r\n\r\n  // Enable "trigger elements"\r\n  // =========================\r\n\r\n  $D.on("click.fb-start", "[data-fancybox-trigger]", function (e) {\r\n    $(\'[data-fancybox="\' + $(this).attr("data-fancybox-trigger") + \'"]\')\r\n      .eq($(this).attr("data-fancybox-index") || 0)\r\n      .trigger("click.fb-start", {\r\n        $trigger: $(this)\r\n      });\r\n  });\r\n\r\n  // Track focus event for better accessibility styling\r\n  // ==================================================\r\n  (function () {\r\n    var buttonStr = ".fancybox-button",\r\n      focusStr = "fancybox-focus",\r\n      $pressed = null;\r\n\r\n    $D.on("mousedown mouseup focus blur", buttonStr, function (e) {\r\n      switch (e.type) {\r\n        case "mousedown":\r\n          $pressed = $(this);\r\n          break;\r\n        case "mouseup":\r\n          $pressed = null;\r\n          break;\r\n        case "focusin":\r\n          $(buttonStr).removeClass(focusStr);\r\n\r\n          if (!$(this).is($pressed) && !$(this).is("[disabled]")) {\r\n            $(this).addClass(focusStr);\r\n          }\r\n          break;\r\n        case "focusout":\r\n          $(buttonStr).removeClass(focusStr);\r\n          break;\r\n      }\r\n    });\r\n  })();\r\n})(window, document, jQuery);\n// ==========================================================================\r\n//\r\n// Media\r\n// Adds additional media type support\r\n//\r\n// ==========================================================================\r\n(function ($) {\r\n  "use strict";\r\n\r\n  // Object containing properties for each media type\r\n  var defaults = {\r\n    youtube: {\r\n      matcher: /(youtube\\.com|youtu\\.be|youtube\\-nocookie\\.com)\\/(watch\\?(.*&)?v=|v\\/|u\\/|embed\\/?)?(videoseries\\?list=(.*)|[\\w-]{11}|\\?listType=(.*)&list=(.*))(.*)/i,\r\n      params: {\r\n        autoplay: 1,\r\n        autohide: 1,\r\n        fs: 1,\r\n        rel: 0,\r\n        hd: 1,\r\n        wmode: "transparent",\r\n        enablejsapi: 1,\r\n        html5: 1\r\n      },\r\n      paramPlace: 8,\r\n      type: "iframe",\r\n      url: "https://www.youtube-nocookie.com/embed/$4",\r\n      thumb: "https://img.youtube.com/vi/$4/hqdefault.jpg"\r\n    },\r\n\r\n    vimeo: {\r\n      matcher: /^.+vimeo.com\\/(.*\\/)?([\\d]+)(.*)?/,\r\n      params: {\r\n        autoplay: 1,\r\n        hd: 1,\r\n        show_title: 1,\r\n        show_byline: 1,\r\n        show_portrait: 0,\r\n        fullscreen: 1\r\n      },\r\n      paramPlace: 3,\r\n      type: "iframe",\r\n      url: "//player.vimeo.com/video/$2"\r\n    },\r\n\r\n    instagram: {\r\n      matcher: /(instagr\\.am|instagram\\.com)\\/p\\/([a-zA-Z0-9_\\-]+)\\/?/i,\r\n      type: "image",\r\n      url: "//$1/p/$2/media/?size=l"\r\n    },\r\n\r\n    // Examples:\r\n    // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16\r\n    // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z\r\n    // https://www.google.com/maps/@52.2111123,2.9237542,6.61z?hl=en\r\n    // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572\r\n    gmap_place: {\r\n      matcher: /(maps\\.)?google\\.([a-z]{2,3}(\\.[a-z]{2})?)\\/(((maps\\/(place\\/(.*)\\/)?\\@(.*),(\\d+.?\\d+?)z))|(\\?ll=))(.*)?/i,\r\n      type: "iframe",\r\n      url: function (rez) {\r\n        return (\r\n          "//maps.google." +\r\n          rez[2] +\r\n          "/?ll=" +\r\n          (rez[9] ? rez[9] + "&z=" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\\//, "&") : "") : rez[12] + "").replace(/\\?/, "&") +\r\n          "&output=" +\r\n          (rez[12] && rez[12].indexOf("layer=c") > 0 ? "svembed" : "embed")\r\n        );\r\n      }\r\n    },\r\n\r\n    // Examples:\r\n    // https://www.google.com/maps/search/Empire+State+Building/\r\n    // https://www.google.com/maps/search/?api=1&query=centurylink+field\r\n    // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393\r\n    gmap_search: {\r\n      matcher: /(maps\\.)?google\\.([a-z]{2,3}(\\.[a-z]{2})?)\\/(maps\\/search\\/)(.*)/i,\r\n      type: "iframe",\r\n      url: function (rez) {\r\n        return "//maps.google." + rez[2] + "/maps?q=" + rez[5].replace("query=", "q=").replace("api=1", "") + "&output=embed";\r\n      }\r\n    }\r\n  };\r\n\r\n  // Formats matching url to final form\r\n  var format = function (url, rez, params) {\r\n    if (!url) {\r\n      return;\r\n    }\r\n\r\n    params = params || "";\r\n\r\n    if ($.type(params) === "object") {\r\n      params = $.param(params, true);\r\n    }\r\n\r\n    $.each(rez, function (key, value) {\r\n      url = url.replace("$" + key, value || "");\r\n    });\r\n\r\n    if (params.length) {\r\n      url += (url.indexOf("?") > 0 ? "&" : "?") + params;\r\n    }\r\n\r\n    return url;\r\n  };\r\n\r\n  $(document).on("objectNeedsType.fb", function (e, instance, item) {\r\n    var url = item.src || "",\r\n      type = false,\r\n      media,\r\n      thumb,\r\n      rez,\r\n      params,\r\n      urlParams,\r\n      paramObj,\r\n      provider;\r\n\r\n    media = $.extend(true, {}, defaults, item.opts.media);\r\n\r\n    // Look for any matching media type\r\n    $.each(media, function (providerName, providerOpts) {\r\n      rez = url.match(providerOpts.matcher);\r\n\r\n      if (!rez) {\r\n        return;\r\n      }\r\n\r\n      type = providerOpts.type;\r\n      provider = providerName;\r\n      paramObj = {};\r\n\r\n      if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {\r\n        urlParams = rez[providerOpts.paramPlace];\r\n\r\n        if (urlParams[0] == "?") {\r\n          urlParams = urlParams.substring(1);\r\n        }\r\n\r\n        urlParams = urlParams.split("&");\r\n\r\n        for (var m = 0; m < urlParams.length; ++m) {\r\n          var p = urlParams[m].split("=", 2);\r\n\r\n          if (p.length == 2) {\r\n            paramObj[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, " "));\r\n          }\r\n        }\r\n      }\r\n\r\n      params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);\r\n\r\n      url =\r\n        $.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);\r\n\r\n      thumb =\r\n        $.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);\r\n\r\n      if (providerName === "youtube") {\r\n        url = url.replace(/&t=((\\d+)m)?(\\d+)s/, function (match, p1, m, s) {\r\n          return "&start=" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10));\r\n        });\r\n      } else if (providerName === "vimeo") {\r\n        url = url.replace("&%23", "#");\r\n      }\r\n\r\n      return false;\r\n    });\r\n\r\n    // If it is found, then change content type and update the url\r\n\r\n    if (type) {\r\n      if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {\r\n        item.opts.thumb = thumb;\r\n      }\r\n\r\n      if (type === "iframe") {\r\n        item.opts = $.extend(true, item.opts, {\r\n          iframe: {\r\n            preload: false,\r\n            attr: {\r\n              scrolling: "no"\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      $.extend(item, {\r\n        type: type,\r\n        src: url,\r\n        origSrc: item.src,\r\n        contentSource: provider,\r\n        contentType: type === "image" ? "image" : provider == "gmap_place" || provider == "gmap_search" ? "map" : "video"\r\n      });\r\n    } else if (url) {\r\n      item.type = item.opts.defaultType;\r\n    }\r\n  });\r\n\r\n  // Load YouTube/Video API on request to detect when video finished playing\r\n  var VideoAPILoader = {\r\n    youtube: {\r\n      src: "https://www.youtube.com/iframe_api",\r\n      class: "YT",\r\n      loading: false,\r\n      loaded: false\r\n    },\r\n\r\n    vimeo: {\r\n      src: "https://player.vimeo.com/api/player.js",\r\n      class: "Vimeo",\r\n      loading: false,\r\n      loaded: false\r\n    },\r\n\r\n    load: function (vendor) {\r\n      var _this = this,\r\n        script;\r\n\r\n      if (this[vendor].loaded) {\r\n        setTimeout(function () {\r\n          _this.done(vendor);\r\n        });\r\n        return;\r\n      }\r\n\r\n      if (this[vendor].loading) {\r\n        return;\r\n      }\r\n\r\n      this[vendor].loading = true;\r\n\r\n      script = document.createElement("script");\r\n      script.type = "text/javascript";\r\n      script.src = this[vendor].src;\r\n\r\n      if (vendor === "youtube") {\r\n        window.onYouTubeIframeAPIReady = function () {\r\n          _this[vendor].loaded = true;\r\n          _this.done(vendor);\r\n        };\r\n      } else {\r\n        script.onload = function () {\r\n          _this[vendor].loaded = true;\r\n          _this.done(vendor);\r\n        };\r\n      }\r\n\r\n      document.body.appendChild(script);\r\n    },\r\n    done: function (vendor) {\r\n      var instance, $el, player;\r\n\r\n      if (vendor === "youtube") {\r\n        delete window.onYouTubeIframeAPIReady;\r\n      }\r\n\r\n      instance = $.fancybox.getInstance();\r\n\r\n      if (instance) {\r\n        $el = instance.current.$content.find("iframe");\r\n\r\n        if (vendor === "youtube" && YT !== undefined && YT) {\r\n          player = new YT.Player($el.attr("id"), {\r\n            events: {\r\n              onStateChange: function (e) {\r\n                if (e.data == 0) {\r\n                  instance.next();\r\n                }\r\n              }\r\n            }\r\n          });\r\n        } else if (vendor === "vimeo" && Vimeo !== undefined && Vimeo) {\r\n          player = new Vimeo.Player($el);\r\n\r\n          player.on("ended", function () {\r\n            instance.next();\r\n          });\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  $(document).on({\r\n    "afterShow.fb": function (e, instance, current) {\r\n      if (instance.group.length > 1 && (current.contentSource === "youtube" || current.contentSource === "vimeo")) {\r\n        VideoAPILoader.load(current.contentSource);\r\n      }\r\n    }\r\n  });\r\n})(jQuery);\n// ==========================================================================\r\n//\r\n// Guestures\r\n// Adds touch guestures, handles click and tap events\r\n//\r\n// ==========================================================================\r\n(function (window, document, $) {\r\n  "use strict";\r\n\r\n  var requestAFrame = (function () {\r\n    return (\r\n      window.requestAnimationFrame ||\r\n      window.webkitRequestAnimationFrame ||\r\n      window.mozRequestAnimationFrame ||\r\n      window.oRequestAnimationFrame ||\r\n      // if all else fails, use setTimeout\r\n      function (callback) {\r\n        return window.setTimeout(callback, 1000 / 60);\r\n      }\r\n    );\r\n  })();\r\n\r\n  var cancelAFrame = (function () {\r\n    return (\r\n      window.cancelAnimationFrame ||\r\n      window.webkitCancelAnimationFrame ||\r\n      window.mozCancelAnimationFrame ||\r\n      window.oCancelAnimationFrame ||\r\n      function (id) {\r\n        window.clearTimeout(id);\r\n      }\r\n    );\r\n  })();\r\n\r\n  var getPointerXY = function (e) {\r\n    var result = [];\r\n\r\n    e = e.originalEvent || e || window.e;\r\n    e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];\r\n\r\n    for (var key in e) {\r\n      if (e[key].pageX) {\r\n        result.push({\r\n          x: e[key].pageX,\r\n          y: e[key].pageY\r\n        });\r\n      } else if (e[key].clientX) {\r\n        result.push({\r\n          x: e[key].clientX,\r\n          y: e[key].clientY\r\n        });\r\n      }\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\n  var distance = function (point2, point1, what) {\r\n    if (!point1 || !point2) {\r\n      return 0;\r\n    }\r\n\r\n    if (what === "x") {\r\n      return point2.x - point1.x;\r\n    } else if (what === "y") {\r\n      return point2.y - point1.y;\r\n    }\r\n\r\n    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\r\n  };\r\n\r\n  var isClickable = function ($el) {\r\n    if (\r\n      $el.is(\'a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe\') ||\r\n      $.isFunction($el.get(0).onclick) ||\r\n      $el.data("selectable")\r\n    ) {\r\n      return true;\r\n    }\r\n\r\n    // Check for attributes like data-fancybox-next or data-fancybox-close\r\n    for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {\r\n      if (atts[i].nodeName.substr(0, 14) === "data-fancybox-") {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  var hasScrollbars = function (el) {\r\n    var overflowY = window.getComputedStyle(el)["overflow-y"],\r\n      overflowX = window.getComputedStyle(el)["overflow-x"],\r\n      vertical = (overflowY === "scroll" || overflowY === "auto") && el.scrollHeight > el.clientHeight,\r\n      horizontal = (overflowX === "scroll" || overflowX === "auto") && el.scrollWidth > el.clientWidth;\r\n\r\n    return vertical || horizontal;\r\n  };\r\n\r\n  var isScrollable = function ($el) {\r\n    var rez = false;\r\n\r\n    while (true) {\r\n      rez = hasScrollbars($el.get(0));\r\n\r\n      if (rez) {\r\n        break;\r\n      }\r\n\r\n      $el = $el.parent();\r\n\r\n      if (!$el.length || $el.hasClass("fancybox-stage") || $el.is("body")) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return rez;\r\n  };\r\n\r\n  var Guestures = function (instance) {\r\n    var self = this;\r\n\r\n    self.instance = instance;\r\n\r\n    self.$bg = instance.$refs.bg;\r\n    self.$stage = instance.$refs.stage;\r\n    self.$container = instance.$refs.container;\r\n\r\n    self.destroy();\r\n\r\n    self.$container.on("touchstart.fb.touch mousedown.fb.touch", $.proxy(self, "ontouchstart"));\r\n  };\r\n\r\n  Guestures.prototype.destroy = function () {\r\n    var self = this;\r\n\r\n    self.$container.off(".fb.touch");\r\n\r\n    $(document).off(".fb.touch");\r\n\r\n    if (self.requestId) {\r\n      cancelAFrame(self.requestId);\r\n      self.requestId = null;\r\n    }\r\n\r\n    if (self.tapped) {\r\n      clearTimeout(self.tapped);\r\n      self.tapped = null;\r\n    }\r\n  };\r\n\r\n  Guestures.prototype.ontouchstart = function (e) {\r\n    var self = this,\r\n      $target = $(e.target),\r\n      instance = self.instance,\r\n      current = instance.current,\r\n      $slide = current.$slide,\r\n      $content = current.$content,\r\n      isTouchDevice = e.type == "touchstart";\r\n\r\n    // Do not respond to both (touch and mouse) events\r\n    if (isTouchDevice) {\r\n      self.$container.off("mousedown.fb.touch");\r\n    }\r\n\r\n    // Ignore right click\r\n    if (e.originalEvent && e.originalEvent.button == 2) {\r\n      return;\r\n    }\r\n\r\n    // Ignore taping on links, buttons, input elements\r\n    if (!$slide.length || !$target.length || isClickable($target) || isClickable($target.parent())) {\r\n      return;\r\n    }\r\n    // Ignore clicks on the scrollbar\r\n    if (!$target.is("img") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {\r\n      return;\r\n    }\r\n\r\n    // Ignore clicks while zooming or closing\r\n    if (!current || instance.isAnimating || current.$slide.hasClass("fancybox-animated")) {\r\n      e.stopPropagation();\r\n      e.preventDefault();\r\n\r\n      return;\r\n    }\r\n\r\n    self.realPoints = self.startPoints = getPointerXY(e);\r\n\r\n    if (!self.startPoints.length) {\r\n      return;\r\n    }\r\n\r\n    // Allow other scripts to catch touch event if "touch" is set to false\r\n    if (current.touch) {\r\n      e.stopPropagation();\r\n    }\r\n\r\n    self.startEvent = e;\r\n\r\n    self.canTap = true;\r\n    self.$target = $target;\r\n    self.$content = $content;\r\n    self.opts = current.opts.touch;\r\n\r\n    self.isPanning = false;\r\n    self.isSwiping = false;\r\n    self.isZooming = false;\r\n    self.isScrolling = false;\r\n    self.canPan = instance.canPan();\r\n\r\n    self.startTime = new Date().getTime();\r\n    self.distanceX = self.distanceY = self.distance = 0;\r\n\r\n    self.canvasWidth = Math.round($slide[0].clientWidth);\r\n    self.canvasHeight = Math.round($slide[0].clientHeight);\r\n\r\n    self.contentLastPos = null;\r\n    self.contentStartPos = $.fancybox.getTranslate(self.$content) || {\r\n      top: 0,\r\n      left: 0\r\n    };\r\n    self.sliderStartPos = $.fancybox.getTranslate($slide);\r\n\r\n    // Since position will be absolute, but we need to make it relative to the stage\r\n    self.stagePos = $.fancybox.getTranslate(instance.$refs.stage);\r\n\r\n    self.sliderStartPos.top -= self.stagePos.top;\r\n    self.sliderStartPos.left -= self.stagePos.left;\r\n\r\n    self.contentStartPos.top -= self.stagePos.top;\r\n    self.contentStartPos.left -= self.stagePos.left;\r\n\r\n    $(document)\r\n      .off(".fb.touch")\r\n      .on(isTouchDevice ? "touchend.fb.touch touchcancel.fb.touch" : "mouseup.fb.touch mouseleave.fb.touch", $.proxy(self, "ontouchend"))\r\n      .on(isTouchDevice ? "touchmove.fb.touch" : "mousemove.fb.touch", $.proxy(self, "ontouchmove"));\r\n\r\n    if ($.fancybox.isMobile) {\r\n      document.addEventListener("scroll", self.onscroll, true);\r\n    }\r\n\r\n    // Skip if clicked outside the sliding area\r\n    if (!(self.opts || self.canPan) || !($target.is(self.$stage) || self.$stage.find($target).length)) {\r\n      if ($target.is(".fancybox-image")) {\r\n        e.preventDefault();\r\n      }\r\n\r\n      if (!($.fancybox.isMobile && $target.parents(".fancybox-caption").length)) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    self.isScrollable = isScrollable($target) || isScrollable($target.parent());\r\n\r\n    // Check if element is scrollable and try to prevent default behavior (scrolling)\r\n    if (!($.fancybox.isMobile && self.isScrollable)) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    // One finger or mouse click - swipe or pan an image\r\n    if (self.startPoints.length === 1 || current.hasError) {\r\n      if (self.canPan) {\r\n        $.fancybox.stop(self.$content);\r\n\r\n        self.isPanning = true;\r\n      } else {\r\n        self.isSwiping = true;\r\n      }\r\n\r\n      self.$container.addClass("fancybox-is-grabbing");\r\n    }\r\n\r\n    // Two fingers - zoom image\r\n    if (self.startPoints.length === 2 && current.type === "image" && (current.isLoaded || current.$ghost)) {\r\n      self.canTap = false;\r\n      self.isSwiping = false;\r\n      self.isPanning = false;\r\n\r\n      self.isZooming = true;\r\n\r\n      $.fancybox.stop(self.$content);\r\n\r\n      self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft();\r\n      self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop();\r\n\r\n      self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;\r\n      self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;\r\n\r\n      self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);\r\n    }\r\n  };\r\n\r\n  Guestures.prototype.onscroll = function (e) {\r\n    var self = this;\r\n\r\n    self.isScrolling = true;\r\n\r\n    document.removeEventListener("scroll", self.onscroll, true);\r\n  };\r\n\r\n  Guestures.prototype.ontouchmove = function (e) {\r\n    var self = this;\r\n\r\n    // Make sure user has not released over iframe or disabled element\r\n    if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) {\r\n      self.ontouchend(e);\r\n      return;\r\n    }\r\n\r\n    if (self.isScrolling) {\r\n      self.canTap = false;\r\n      return;\r\n    }\r\n\r\n    self.newPoints = getPointerXY(e);\r\n\r\n    if (!(self.opts || self.canPan) || !self.newPoints.length || !self.newPoints.length) {\r\n      return;\r\n    }\r\n\r\n    if (!(self.isSwiping && self.isSwiping === true)) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    self.distanceX = distance(self.newPoints[0], self.startPoints[0], "x");\r\n    self.distanceY = distance(self.newPoints[0], self.startPoints[0], "y");\r\n\r\n    self.distance = distance(self.newPoints[0], self.startPoints[0]);\r\n\r\n    // Skip false ontouchmove events (Chrome)\r\n    if (self.distance > 0) {\r\n      if (self.isSwiping) {\r\n        self.onSwipe(e);\r\n      } else if (self.isPanning) {\r\n        self.onPan();\r\n      } else if (self.isZooming) {\r\n        self.onZoom();\r\n      }\r\n    }\r\n  };\r\n\r\n  Guestures.prototype.onSwipe = function (e) {\r\n    var self = this,\r\n      instance = self.instance,\r\n      swiping = self.isSwiping,\r\n      left = self.sliderStartPos.left || 0,\r\n      angle;\r\n\r\n    // If direction is not yet determined\r\n    if (swiping === true) {\r\n      // We need at least 10px distance to correctly calculate an angle\r\n      if (Math.abs(self.distance) > 10) {\r\n        self.canTap = false;\r\n\r\n        if (instance.group.length < 2 && self.opts.vertical) {\r\n          self.isSwiping = "y";\r\n        } else if (instance.isDragging || self.opts.vertical === false || (self.opts.vertical === "auto" && $(window).width() > 800)) {\r\n          self.isSwiping = "x";\r\n        } else {\r\n          angle = Math.abs((Math.atan2(self.distanceY, self.distanceX) * 180) / Math.PI);\r\n\r\n          self.isSwiping = angle > 45 && angle < 135 ? "y" : "x";\r\n        }\r\n\r\n        if (self.isSwiping === "y" && $.fancybox.isMobile && self.isScrollable) {\r\n          self.isScrolling = true;\r\n\r\n          return;\r\n        }\r\n\r\n        instance.isDragging = self.isSwiping;\r\n\r\n        // Reset points to avoid jumping, because we dropped first swipes to calculate the angle\r\n        self.startPoints = self.newPoints;\r\n\r\n        $.each(instance.slides, function (index, slide) {\r\n          var slidePos, stagePos;\r\n\r\n          $.fancybox.stop(slide.$slide);\r\n\r\n          slidePos = $.fancybox.getTranslate(slide.$slide);\r\n          stagePos = $.fancybox.getTranslate(instance.$refs.stage);\r\n\r\n          slide.$slide\r\n            .css({\r\n              transform: "",\r\n              opacity: "",\r\n              "transition-duration": ""\r\n            })\r\n            .removeClass("fancybox-animated")\r\n            .removeClass(function (index, className) {\r\n              return (className.match(/(^|\\s)fancybox-fx-\\S+/g) || []).join(" ");\r\n            });\r\n\r\n          if (slide.pos === instance.current.pos) {\r\n            self.sliderStartPos.top = slidePos.top - stagePos.top;\r\n            self.sliderStartPos.left = slidePos.left - stagePos.left;\r\n          }\r\n\r\n          $.fancybox.setTranslate(slide.$slide, {\r\n            top: slidePos.top - stagePos.top,\r\n            left: slidePos.left - stagePos.left\r\n          });\r\n        });\r\n\r\n        // Stop slideshow\r\n        if (instance.SlideShow && instance.SlideShow.isActive) {\r\n          instance.SlideShow.stop();\r\n        }\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // Sticky edges\r\n    if (swiping == "x") {\r\n      if (\r\n        self.distanceX > 0 &&\r\n        (self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop))\r\n      ) {\r\n        left = left + Math.pow(self.distanceX, 0.8);\r\n      } else if (\r\n        self.distanceX < 0 &&\r\n        (self.instance.group.length < 2 ||\r\n          (self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop))\r\n      ) {\r\n        left = left - Math.pow(-self.distanceX, 0.8);\r\n      } else {\r\n        left = left + self.distanceX;\r\n      }\r\n    }\r\n\r\n    self.sliderLastPos = {\r\n      top: swiping == "x" ? 0 : self.sliderStartPos.top + self.distanceY,\r\n      left: left\r\n    };\r\n\r\n    if (self.requestId) {\r\n      cancelAFrame(self.requestId);\r\n\r\n      self.requestId = null;\r\n    }\r\n\r\n    self.requestId = requestAFrame(function () {\r\n      if (self.sliderLastPos) {\r\n        $.each(self.instance.slides, function (index, slide) {\r\n          var pos = slide.pos - self.instance.currPos;\r\n\r\n          $.fancybox.setTranslate(slide.$slide, {\r\n            top: self.sliderLastPos.top,\r\n            left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter\r\n          });\r\n        });\r\n\r\n        self.$container.addClass("fancybox-is-sliding");\r\n      }\r\n    });\r\n  };\r\n\r\n  Guestures.prototype.onPan = function () {\r\n    var self = this;\r\n\r\n    // Prevent accidental movement (sometimes, when tapping casually, finger can move a bit)\r\n    if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) {\r\n      self.startPoints = self.newPoints;\r\n      return;\r\n    }\r\n\r\n    self.canTap = false;\r\n\r\n    self.contentLastPos = self.limitMovement();\r\n\r\n    if (self.requestId) {\r\n      cancelAFrame(self.requestId);\r\n    }\r\n\r\n    self.requestId = requestAFrame(function () {\r\n      $.fancybox.setTranslate(self.$content, self.contentLastPos);\r\n    });\r\n  };\r\n\r\n  // Make panning sticky to the edges\r\n  Guestures.prototype.limitMovement = function () {\r\n    var self = this;\r\n\r\n    var canvasWidth = self.canvasWidth;\r\n    var canvasHeight = self.canvasHeight;\r\n\r\n    var distanceX = self.distanceX;\r\n    var distanceY = self.distanceY;\r\n\r\n    var contentStartPos = self.contentStartPos;\r\n\r\n    var currentOffsetX = contentStartPos.left;\r\n    var currentOffsetY = contentStartPos.top;\r\n\r\n    var currentWidth = contentStartPos.width;\r\n    var currentHeight = contentStartPos.height;\r\n\r\n    var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY;\r\n\r\n    if (currentWidth > canvasWidth) {\r\n      newOffsetX = currentOffsetX + distanceX;\r\n    } else {\r\n      newOffsetX = currentOffsetX;\r\n    }\r\n\r\n    newOffsetY = currentOffsetY + distanceY;\r\n\r\n    // Slow down proportionally to traveled distance\r\n    minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);\r\n    minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);\r\n\r\n    maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);\r\n    maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5);\r\n\r\n    //   ->\r\n    if (distanceX > 0 && newOffsetX > minTranslateX) {\r\n      newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;\r\n    }\r\n\r\n    //    <-\r\n    if (distanceX < 0 && newOffsetX < maxTranslateX) {\r\n      newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;\r\n    }\r\n\r\n    //   \\/\r\n    if (distanceY > 0 && newOffsetY > minTranslateY) {\r\n      newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;\r\n    }\r\n\r\n    //   /\\\r\n    if (distanceY < 0 && newOffsetY < maxTranslateY) {\r\n      newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;\r\n    }\r\n\r\n    return {\r\n      top: newOffsetY,\r\n      left: newOffsetX\r\n    };\r\n  };\r\n\r\n  Guestures.prototype.limitPosition = function (newOffsetX, newOffsetY, newWidth, newHeight) {\r\n    var self = this;\r\n\r\n    var canvasWidth = self.canvasWidth;\r\n    var canvasHeight = self.canvasHeight;\r\n\r\n    if (newWidth > canvasWidth) {\r\n      newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;\r\n      newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;\r\n    } else {\r\n      // Center horizontally\r\n      newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);\r\n    }\r\n\r\n    if (newHeight > canvasHeight) {\r\n      newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;\r\n      newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;\r\n    } else {\r\n      // Center vertically\r\n      newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);\r\n    }\r\n\r\n    return {\r\n      top: newOffsetY,\r\n      left: newOffsetX\r\n    };\r\n  };\r\n\r\n  Guestures.prototype.onZoom = function () {\r\n    var self = this;\r\n\r\n    // Calculate current distance between points to get pinch ratio and new width and height\r\n    var contentStartPos = self.contentStartPos;\r\n\r\n    var currentWidth = contentStartPos.width;\r\n    var currentHeight = contentStartPos.height;\r\n\r\n    var currentOffsetX = contentStartPos.left;\r\n    var currentOffsetY = contentStartPos.top;\r\n\r\n    var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);\r\n\r\n    var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;\r\n\r\n    var newWidth = Math.floor(currentWidth * pinchRatio);\r\n    var newHeight = Math.floor(currentHeight * pinchRatio);\r\n\r\n    // This is the translation due to pinch-zooming\r\n    var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;\r\n    var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;\r\n\r\n    // Point between the two touches\r\n    var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) / 2 - $(window).scrollLeft();\r\n    var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) / 2 - $(window).scrollTop();\r\n\r\n    // And this is the translation due to translation of the centerpoint\r\n    // between the two fingers\r\n    var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;\r\n    var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;\r\n\r\n    // The new offset is the old/current one plus the total translation\r\n    var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);\r\n    var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);\r\n\r\n    var newPos = {\r\n      top: newOffsetY,\r\n      left: newOffsetX,\r\n      scaleX: pinchRatio,\r\n      scaleY: pinchRatio\r\n    };\r\n\r\n    self.canTap = false;\r\n\r\n    self.newWidth = newWidth;\r\n    self.newHeight = newHeight;\r\n\r\n    self.contentLastPos = newPos;\r\n\r\n    if (self.requestId) {\r\n      cancelAFrame(self.requestId);\r\n    }\r\n\r\n    self.requestId = requestAFrame(function () {\r\n      $.fancybox.setTranslate(self.$content, self.contentLastPos);\r\n    });\r\n  };\r\n\r\n  Guestures.prototype.ontouchend = function (e) {\r\n    var self = this;\r\n\r\n    var swiping = self.isSwiping;\r\n    var panning = self.isPanning;\r\n    var zooming = self.isZooming;\r\n    var scrolling = self.isScrolling;\r\n\r\n    self.endPoints = getPointerXY(e);\r\n    self.dMs = Math.max(new Date().getTime() - self.startTime, 1);\r\n\r\n    self.$container.removeClass("fancybox-is-grabbing");\r\n\r\n    $(document).off(".fb.touch");\r\n\r\n    document.removeEventListener("scroll", self.onscroll, true);\r\n\r\n    if (self.requestId) {\r\n      cancelAFrame(self.requestId);\r\n\r\n      self.requestId = null;\r\n    }\r\n\r\n    self.isSwiping = false;\r\n    self.isPanning = false;\r\n    self.isZooming = false;\r\n    self.isScrolling = false;\r\n\r\n    self.instance.isDragging = false;\r\n\r\n    if (self.canTap) {\r\n      return self.onTap(e);\r\n    }\r\n\r\n    self.speed = 100;\r\n\r\n    // Speed in px/ms\r\n    self.velocityX = (self.distanceX / self.dMs) * 0.5;\r\n    self.velocityY = (self.distanceY / self.dMs) * 0.5;\r\n\r\n    if (panning) {\r\n      self.endPanning();\r\n    } else if (zooming) {\r\n      self.endZooming();\r\n    } else {\r\n      self.endSwiping(swiping, scrolling);\r\n    }\r\n\r\n    return;\r\n  };\r\n\r\n  Guestures.prototype.endSwiping = function (swiping, scrolling) {\r\n    var self = this,\r\n      ret = false,\r\n      len = self.instance.group.length,\r\n      distanceX = Math.abs(self.distanceX),\r\n      canAdvance = swiping == "x" && len > 1 && ((self.dMs > 130 && distanceX > 10) || distanceX > 50),\r\n      speedX = 300;\r\n\r\n    self.sliderLastPos = null;\r\n\r\n    // Close if swiped vertically / navigate if horizontally\r\n    if (swiping == "y" && !scrolling && Math.abs(self.distanceY) > 50) {\r\n      // Continue vertical movement\r\n      $.fancybox.animate(\r\n        self.instance.current.$slide, {\r\n          top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150,\r\n          opacity: 0\r\n        },\r\n        200\r\n      );\r\n      ret = self.instance.close(true, 250);\r\n    } else if (canAdvance && self.distanceX > 0) {\r\n      ret = self.instance.previous(speedX);\r\n    } else if (canAdvance && self.distanceX < 0) {\r\n      ret = self.instance.next(speedX);\r\n    }\r\n\r\n    if (ret === false && (swiping == "x" || swiping == "y")) {\r\n      self.instance.centerSlide(200);\r\n    }\r\n\r\n    self.$container.removeClass("fancybox-is-sliding");\r\n  };\r\n\r\n  // Limit panning from edges\r\n  // ========================\r\n  Guestures.prototype.endPanning = function () {\r\n    var self = this,\r\n      newOffsetX,\r\n      newOffsetY,\r\n      newPos;\r\n\r\n    if (!self.contentLastPos) {\r\n      return;\r\n    }\r\n\r\n    if (self.opts.momentum === false || self.dMs > 350) {\r\n      newOffsetX = self.contentLastPos.left;\r\n      newOffsetY = self.contentLastPos.top;\r\n    } else {\r\n      // Continue movement\r\n      newOffsetX = self.contentLastPos.left + self.velocityX * 500;\r\n      newOffsetY = self.contentLastPos.top + self.velocityY * 500;\r\n    }\r\n\r\n    newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);\r\n\r\n    newPos.width = self.contentStartPos.width;\r\n    newPos.height = self.contentStartPos.height;\r\n\r\n    $.fancybox.animate(self.$content, newPos, 366);\r\n  };\r\n\r\n  Guestures.prototype.endZooming = function () {\r\n    var self = this;\r\n\r\n    var current = self.instance.current;\r\n\r\n    var newOffsetX, newOffsetY, newPos, reset;\r\n\r\n    var newWidth = self.newWidth;\r\n    var newHeight = self.newHeight;\r\n\r\n    if (!self.contentLastPos) {\r\n      return;\r\n    }\r\n\r\n    newOffsetX = self.contentLastPos.left;\r\n    newOffsetY = self.contentLastPos.top;\r\n\r\n    reset = {\r\n      top: newOffsetY,\r\n      left: newOffsetX,\r\n      width: newWidth,\r\n      height: newHeight,\r\n      scaleX: 1,\r\n      scaleY: 1\r\n    };\r\n\r\n    // Reset scalex/scaleY values; this helps for perfomance and does not break animation\r\n    $.fancybox.setTranslate(self.$content, reset);\r\n\r\n    if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {\r\n      self.instance.scaleToFit(150);\r\n    } else if (newWidth > current.width || newHeight > current.height) {\r\n      self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);\r\n    } else {\r\n      newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);\r\n\r\n      $.fancybox.animate(self.$content, newPos, 150);\r\n    }\r\n  };\r\n\r\n  Guestures.prototype.onTap = function (e) {\r\n    var self = this;\r\n    var $target = $(e.target);\r\n\r\n    var instance = self.instance;\r\n    var current = instance.current;\r\n\r\n    var endPoints = (e && getPointerXY(e)) || self.startPoints;\r\n\r\n    var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0;\r\n    var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0;\r\n\r\n    var where;\r\n\r\n    var process = function (prefix) {\r\n      var action = current.opts[prefix];\r\n\r\n      if ($.isFunction(action)) {\r\n        action = action.apply(instance, [current, e]);\r\n      }\r\n\r\n      if (!action) {\r\n        return;\r\n      }\r\n\r\n      switch (action) {\r\n        case "close":\r\n          instance.close(self.startEvent);\r\n\r\n          break;\r\n\r\n        case "toggleControls":\r\n          instance.toggleControls();\r\n\r\n          break;\r\n\r\n        case "next":\r\n          instance.next();\r\n\r\n          break;\r\n\r\n        case "nextOrClose":\r\n          if (instance.group.length > 1) {\r\n            instance.next();\r\n          } else {\r\n            instance.close(self.startEvent);\r\n          }\r\n\r\n          break;\r\n\r\n        case "zoom":\r\n          if (current.type == "image" && (current.isLoaded || current.$ghost)) {\r\n            if (instance.canPan()) {\r\n              instance.scaleToFit();\r\n            } else if (instance.isScaledDown()) {\r\n              instance.scaleToActual(tapX, tapY);\r\n            } else if (instance.group.length < 2) {\r\n              instance.close(self.startEvent);\r\n            }\r\n          }\r\n\r\n          break;\r\n      }\r\n    };\r\n\r\n    // Ignore right click\r\n    if (e.originalEvent && e.originalEvent.button == 2) {\r\n      return;\r\n    }\r\n\r\n    // Skip if clicked on the scrollbar\r\n    if (!$target.is("img") && tapX > $target[0].clientWidth + $target.offset().left) {\r\n      return;\r\n    }\r\n\r\n    // Check where is clicked\r\n    if ($target.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container")) {\r\n      where = "Outside";\r\n    } else if ($target.is(".fancybox-slide")) {\r\n      where = "Slide";\r\n    } else if (\r\n      instance.current.$content &&\r\n      instance.current.$content\r\n      .find($target)\r\n      .addBack()\r\n      .filter($target).length\r\n    ) {\r\n      where = "Content";\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    // Check if this is a double tap\r\n    if (self.tapped) {\r\n      // Stop previously created single tap\r\n      clearTimeout(self.tapped);\r\n      self.tapped = null;\r\n\r\n      // Skip if distance between taps is too big\r\n      if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {\r\n        return this;\r\n      }\r\n\r\n      // OK, now we assume that this is a double-tap\r\n      process("dblclick" + where);\r\n    } else {\r\n      // Single tap will be processed if user has not clicked second time within 300ms\r\n      // or there is no need to wait for double-tap\r\n      self.tapX = tapX;\r\n      self.tapY = tapY;\r\n\r\n      if (current.opts["dblclick" + where] && current.opts["dblclick" + where] !== current.opts["click" + where]) {\r\n        self.tapped = setTimeout(function () {\r\n          self.tapped = null;\r\n\r\n          if (!instance.isAnimating) {\r\n            process("click" + where);\r\n          }\r\n        }, 500);\r\n      } else {\r\n        process("click" + where);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  $(document)\r\n    .on("onActivate.fb", function (e, instance) {\r\n      if (instance && !instance.Guestures) {\r\n        instance.Guestures = new Guestures(instance);\r\n      }\r\n    })\r\n    .on("beforeClose.fb", function (e, instance) {\r\n      if (instance && instance.Guestures) {\r\n        instance.Guestures.destroy();\r\n      }\r\n    });\r\n})(window, document, jQuery);\n// ==========================================================================\r\n//\r\n// SlideShow\r\n// Enables slideshow functionality\r\n//\r\n// Example of usage:\r\n// $.fancybox.getInstance().SlideShow.start()\r\n//\r\n// ==========================================================================\r\n(function (document, $) {\r\n  "use strict";\r\n\r\n  $.extend(true, $.fancybox.defaults, {\r\n    btnTpl: {\r\n      slideShow: \'<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}">\' +\r\n        \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg>\' +\r\n        \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg>\' +\r\n        "</button>"\r\n    },\r\n    slideShow: {\r\n      autoStart: false,\r\n      speed: 3000,\r\n      progress: true\r\n    }\r\n  });\r\n\r\n  var SlideShow = function (instance) {\r\n    this.instance = instance;\r\n    this.init();\r\n  };\r\n\r\n  $.extend(SlideShow.prototype, {\r\n    timer: null,\r\n    isActive: false,\r\n    $button: null,\r\n\r\n    init: function () {\r\n      var self = this,\r\n        instance = self.instance,\r\n        opts = instance.group[instance.currIndex].opts.slideShow;\r\n\r\n      self.$button = instance.$refs.toolbar.find("[data-fancybox-play]").on("click", function () {\r\n        self.toggle();\r\n      });\r\n\r\n      if (instance.group.length < 2 || !opts) {\r\n        self.$button.hide();\r\n      } else if (opts.progress) {\r\n        self.$progress = $(\'<div class="fancybox-progress"></div>\').appendTo(instance.$refs.inner);\r\n      }\r\n    },\r\n\r\n    set: function (force) {\r\n      var self = this,\r\n        instance = self.instance,\r\n        current = instance.current;\r\n\r\n      // Check if reached last element\r\n      if (current && (force === true || current.opts.loop || instance.currIndex < instance.group.length - 1)) {\r\n        if (self.isActive && current.contentType !== "video") {\r\n          if (self.$progress) {\r\n            $.fancybox.animate(self.$progress.show(), {\r\n              scaleX: 1\r\n            }, current.opts.slideShow.speed);\r\n          }\r\n\r\n          self.timer = setTimeout(function () {\r\n            if (!instance.current.opts.loop && instance.current.index == instance.group.length - 1) {\r\n              instance.jumpTo(0);\r\n            } else {\r\n              instance.next();\r\n            }\r\n          }, current.opts.slideShow.speed);\r\n        }\r\n      } else {\r\n        self.stop();\r\n        instance.idleSecondsCounter = 0;\r\n        instance.showControls();\r\n      }\r\n    },\r\n\r\n    clear: function () {\r\n      var self = this;\r\n\r\n      clearTimeout(self.timer);\r\n\r\n      self.timer = null;\r\n\r\n      if (self.$progress) {\r\n        self.$progress.removeAttr("style").hide();\r\n      }\r\n    },\r\n\r\n    start: function () {\r\n      var self = this,\r\n        current = self.instance.current;\r\n\r\n      if (current) {\r\n        self.$button\r\n          .attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_STOP)\r\n          .removeClass("fancybox-button--play")\r\n          .addClass("fancybox-button--pause");\r\n\r\n        self.isActive = true;\r\n\r\n        if (current.isComplete) {\r\n          self.set(true);\r\n        }\r\n\r\n        self.instance.trigger("onSlideShowChange", true);\r\n      }\r\n    },\r\n\r\n    stop: function () {\r\n      var self = this,\r\n        current = self.instance.current;\r\n\r\n      self.clear();\r\n\r\n      self.$button\r\n        .attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_START)\r\n        .removeClass("fancybox-button--pause")\r\n        .addClass("fancybox-button--play");\r\n\r\n      self.isActive = false;\r\n\r\n      self.instance.trigger("onSlideShowChange", false);\r\n\r\n      if (self.$progress) {\r\n        self.$progress.removeAttr("style").hide();\r\n      }\r\n    },\r\n\r\n    toggle: function () {\r\n      var self = this;\r\n\r\n      if (self.isActive) {\r\n        self.stop();\r\n      } else {\r\n        self.start();\r\n      }\r\n    }\r\n  });\r\n\r\n  $(document).on({\r\n    "onInit.fb": function (e, instance) {\r\n      if (instance && !instance.SlideShow) {\r\n        instance.SlideShow = new SlideShow(instance);\r\n      }\r\n    },\r\n\r\n    "beforeShow.fb": function (e, instance, current, firstRun) {\r\n      var SlideShow = instance && instance.SlideShow;\r\n\r\n      if (firstRun) {\r\n        if (SlideShow && current.opts.slideShow.autoStart) {\r\n          SlideShow.start();\r\n        }\r\n      } else if (SlideShow && SlideShow.isActive) {\r\n        SlideShow.clear();\r\n      }\r\n    },\r\n\r\n    "afterShow.fb": function (e, instance, current) {\r\n      var SlideShow = instance && instance.SlideShow;\r\n\r\n      if (SlideShow && SlideShow.isActive) {\r\n        SlideShow.set();\r\n      }\r\n    },\r\n\r\n    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {\r\n      var SlideShow = instance && instance.SlideShow;\r\n\r\n      // "P" or Spacebar\r\n      if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is("button,a,input")) {\r\n        keypress.preventDefault();\r\n\r\n        SlideShow.toggle();\r\n      }\r\n    },\r\n\r\n    "beforeClose.fb onDeactivate.fb": function (e, instance) {\r\n      var SlideShow = instance && instance.SlideShow;\r\n\r\n      if (SlideShow) {\r\n        SlideShow.stop();\r\n      }\r\n    }\r\n  });\r\n\r\n  // Page Visibility API to pause slideshow when window is not active\r\n  $(document).on("visibilitychange", function () {\r\n    var instance = $.fancybox.getInstance(),\r\n      SlideShow = instance && instance.SlideShow;\r\n\r\n    if (SlideShow && SlideShow.isActive) {\r\n      if (document.hidden) {\r\n        SlideShow.clear();\r\n      } else {\r\n        SlideShow.set();\r\n      }\r\n    }\r\n  });\r\n})(document, jQuery);\n// ==========================================================================\r\n//\r\n// FullScreen\r\n// Adds fullscreen functionality\r\n//\r\n// ==========================================================================\r\n(function (document, $) {\r\n  "use strict";\r\n\r\n  // Collection of methods supported by user browser\r\n  var fn = (function () {\r\n    var fnMap = [\r\n      ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],\r\n      // new WebKit\r\n      [\r\n        "webkitRequestFullscreen",\r\n        "webkitExitFullscreen",\r\n        "webkitFullscreenElement",\r\n        "webkitFullscreenEnabled",\r\n        "webkitfullscreenchange",\r\n        "webkitfullscreenerror"\r\n      ],\r\n      // old WebKit (Safari 5.1)\r\n      [\r\n        "webkitRequestFullScreen",\r\n        "webkitCancelFullScreen",\r\n        "webkitCurrentFullScreenElement",\r\n        "webkitCancelFullScreen",\r\n        "webkitfullscreenchange",\r\n        "webkitfullscreenerror"\r\n      ],\r\n      [\r\n        "mozRequestFullScreen",\r\n        "mozCancelFullScreen",\r\n        "mozFullScreenElement",\r\n        "mozFullScreenEnabled",\r\n        "mozfullscreenchange",\r\n        "mozfullscreenerror"\r\n      ],\r\n      ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]\r\n    ];\r\n\r\n    var ret = {};\r\n\r\n    for (var i = 0; i < fnMap.length; i++) {\r\n      var val = fnMap[i];\r\n\r\n      if (val && val[1] in document) {\r\n        for (var j = 0; j < val.length; j++) {\r\n          ret[fnMap[0][j]] = val[j];\r\n        }\r\n\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  })();\r\n\r\n  if (fn) {\r\n    var FullScreen = {\r\n      request: function (elem) {\r\n        elem = elem || document.documentElement;\r\n\r\n        elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);\r\n      },\r\n      exit: function () {\r\n        document[fn.exitFullscreen]();\r\n      },\r\n      toggle: function (elem) {\r\n        elem = elem || document.documentElement;\r\n\r\n        if (this.isFullscreen()) {\r\n          this.exit();\r\n        } else {\r\n          this.request(elem);\r\n        }\r\n      },\r\n      isFullscreen: function () {\r\n        return Boolean(document[fn.fullscreenElement]);\r\n      },\r\n      enabled: function () {\r\n        return Boolean(document[fn.fullscreenEnabled]);\r\n      }\r\n    };\r\n\r\n    $.extend(true, $.fancybox.defaults, {\r\n      btnTpl: {\r\n        fullScreen: \'<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}">\' +\r\n          \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>\' +\r\n          \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg>\' +\r\n          "</button>"\r\n      },\r\n      fullScreen: {\r\n        autoStart: false\r\n      }\r\n    });\r\n\r\n    $(document).on(fn.fullscreenchange, function () {\r\n      var isFullscreen = FullScreen.isFullscreen(),\r\n        instance = $.fancybox.getInstance();\r\n\r\n      if (instance) {\r\n        // If image is zooming, then force to stop and reposition properly\r\n        if (instance.current && instance.current.type === "image" && instance.isAnimating) {\r\n          instance.isAnimating = false;\r\n\r\n          instance.update(true, true, 0);\r\n\r\n          if (!instance.isComplete) {\r\n            instance.complete();\r\n          }\r\n        }\r\n\r\n        instance.trigger("onFullscreenChange", isFullscreen);\r\n\r\n        instance.$refs.container.toggleClass("fancybox-is-fullscreen", isFullscreen);\r\n\r\n        instance.$refs.toolbar\r\n          .find("[data-fancybox-fullscreen]")\r\n          .toggleClass("fancybox-button--fsenter", !isFullscreen)\r\n          .toggleClass("fancybox-button--fsexit", isFullscreen);\r\n      }\r\n    });\r\n  }\r\n\r\n  $(document).on({\r\n    "onInit.fb": function (e, instance) {\r\n      var $container;\r\n\r\n      if (!fn) {\r\n        instance.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();\r\n\r\n        return;\r\n      }\r\n\r\n      if (instance && instance.group[instance.currIndex].opts.fullScreen) {\r\n        $container = instance.$refs.container;\r\n\r\n        $container.on("click.fb-fullscreen", "[data-fancybox-fullscreen]", function (e) {\r\n          e.stopPropagation();\r\n          e.preventDefault();\r\n\r\n          FullScreen.toggle();\r\n        });\r\n\r\n        if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {\r\n          FullScreen.request();\r\n        }\r\n\r\n        // Expose API\r\n        instance.FullScreen = FullScreen;\r\n      } else if (instance) {\r\n        instance.$refs.toolbar.find("[data-fancybox-fullscreen]").hide();\r\n      }\r\n    },\r\n\r\n    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {\r\n      // "F"\r\n      if (instance && instance.FullScreen && keycode === 70) {\r\n        keypress.preventDefault();\r\n\r\n        instance.FullScreen.toggle();\r\n      }\r\n    },\r\n\r\n    "beforeClose.fb": function (e, instance) {\r\n      if (instance && instance.FullScreen && instance.$refs.container.hasClass("fancybox-is-fullscreen")) {\r\n        FullScreen.exit();\r\n      }\r\n    }\r\n  });\r\n})(document, jQuery);\n// ==========================================================================\r\n//\r\n// Thumbs\r\n// Displays thumbnails in a grid\r\n//\r\n// ==========================================================================\r\n(function (document, $) {\r\n  "use strict";\r\n\r\n  var CLASS = "fancybox-thumbs",\r\n    CLASS_ACTIVE = CLASS + "-active";\r\n\r\n  // Make sure there are default values\r\n  $.fancybox.defaults = $.extend(\r\n    true, {\r\n      btnTpl: {\r\n        thumbs: \'<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}">\' +\r\n          \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg>\' +\r\n          "</button>"\r\n      },\r\n      thumbs: {\r\n        autoStart: false, // Display thumbnails on opening\r\n        hideOnClose: true, // Hide thumbnail grid when closing animation starts\r\n        parentEl: ".fancybox-container", // Container is injected into this element\r\n        axis: "y" // Vertical (y) or horizontal (x) scrolling\r\n      }\r\n    },\r\n    $.fancybox.defaults\r\n  );\r\n\r\n  var FancyThumbs = function (instance) {\r\n    this.init(instance);\r\n  };\r\n\r\n  $.extend(FancyThumbs.prototype, {\r\n    $button: null,\r\n    $grid: null,\r\n    $list: null,\r\n    isVisible: false,\r\n    isActive: false,\r\n\r\n    init: function (instance) {\r\n      var self = this,\r\n        group = instance.group,\r\n        enabled = 0;\r\n\r\n      self.instance = instance;\r\n      self.opts = group[instance.currIndex].opts.thumbs;\r\n\r\n      instance.Thumbs = self;\r\n\r\n      self.$button = instance.$refs.toolbar.find("[data-fancybox-thumbs]");\r\n\r\n      // Enable thumbs if at least two group items have thumbnails\r\n      for (var i = 0, len = group.length; i < len; i++) {\r\n        if (group[i].thumb) {\r\n          enabled++;\r\n        }\r\n\r\n        if (enabled > 1) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (enabled > 1 && !!self.opts) {\r\n        self.$button.removeAttr("style").on("click", function () {\r\n          self.toggle();\r\n        });\r\n\r\n        self.isActive = true;\r\n      } else {\r\n        self.$button.hide();\r\n      }\r\n    },\r\n\r\n    create: function () {\r\n      var self = this,\r\n        instance = self.instance,\r\n        parentEl = self.opts.parentEl,\r\n        list = [],\r\n        src;\r\n\r\n      if (!self.$grid) {\r\n        // Create main element\r\n        self.$grid = $(\'<div class="\' + CLASS + " " + CLASS + "-" + self.opts.axis + \'"></div>\').appendTo(\r\n          instance.$refs.container\r\n          .find(parentEl)\r\n          .addBack()\r\n          .filter(parentEl)\r\n        );\r\n\r\n        // Add "click" event that performs gallery navigation\r\n        self.$grid.on("click", "a", function () {\r\n          instance.jumpTo($(this).attr("data-index"));\r\n        });\r\n      }\r\n\r\n      // Build the list\r\n      if (!self.$list) {\r\n        self.$list = $(\'<div class="\' + CLASS + \'__list">\').appendTo(self.$grid);\r\n      }\r\n\r\n      $.each(instance.group, function (i, item) {\r\n        src = item.thumb;\r\n\r\n        if (!src && item.type === "image") {\r\n          src = item.src;\r\n        }\r\n\r\n        list.push(\r\n          \'<a href="javascript:;" tabindex="0" data-index="\' +\r\n          i +\r\n          \'"\' +\r\n          (src && src.length ? \' style="background-image:url(\' + src + \')"\' : \'class="fancybox-thumbs-missing"\') +\r\n          "></a>"\r\n        );\r\n      });\r\n\r\n      self.$list[0].innerHTML = list.join("");\r\n\r\n      if (self.opts.axis === "x") {\r\n        // Set fixed width for list element to enable horizontal scrolling\r\n        self.$list.width(\r\n          parseInt(self.$grid.css("padding-right"), 10) +\r\n          instance.group.length *\r\n          self.$list\r\n          .children()\r\n          .eq(0)\r\n          .outerWidth(true)\r\n        );\r\n      }\r\n    },\r\n\r\n    focus: function (duration) {\r\n      var self = this,\r\n        $list = self.$list,\r\n        $grid = self.$grid,\r\n        thumb,\r\n        thumbPos;\r\n\r\n      if (!self.instance.current) {\r\n        return;\r\n      }\r\n\r\n      thumb = $list\r\n        .children()\r\n        .removeClass(CLASS_ACTIVE)\r\n        .filter(\'[data-index="\' + self.instance.current.index + \'"]\')\r\n        .addClass(CLASS_ACTIVE);\r\n\r\n      thumbPos = thumb.position();\r\n\r\n      // Check if need to scroll to make current thumb visible\r\n      if (self.opts.axis === "y" && (thumbPos.top < 0 || thumbPos.top > $list.height() - thumb.outerHeight())) {\r\n        $list.stop().animate({\r\n            scrollTop: $list.scrollTop() + thumbPos.top\r\n          },\r\n          duration\r\n        );\r\n      } else if (\r\n        self.opts.axis === "x" &&\r\n        (thumbPos.left < $grid.scrollLeft() || thumbPos.left > $grid.scrollLeft() + ($grid.width() - thumb.outerWidth()))\r\n      ) {\r\n        $list\r\n          .parent()\r\n          .stop()\r\n          .animate({\r\n              scrollLeft: thumbPos.left\r\n            },\r\n            duration\r\n          );\r\n      }\r\n    },\r\n\r\n    update: function () {\r\n      var that = this;\r\n      that.instance.$refs.container.toggleClass("fancybox-show-thumbs", this.isVisible);\r\n\r\n      if (that.isVisible) {\r\n        if (!that.$grid) {\r\n          that.create();\r\n        }\r\n\r\n        that.instance.trigger("onThumbsShow");\r\n\r\n        that.focus(0);\r\n      } else if (that.$grid) {\r\n        that.instance.trigger("onThumbsHide");\r\n      }\r\n\r\n      // Update content position\r\n      that.instance.update();\r\n    },\r\n\r\n    hide: function () {\r\n      this.isVisible = false;\r\n      this.update();\r\n    },\r\n\r\n    show: function () {\r\n      this.isVisible = true;\r\n      this.update();\r\n    },\r\n\r\n    toggle: function () {\r\n      this.isVisible = !this.isVisible;\r\n      this.update();\r\n    }\r\n  });\r\n\r\n  $(document).on({\r\n    "onInit.fb": function (e, instance) {\r\n      var Thumbs;\r\n\r\n      if (instance && !instance.Thumbs) {\r\n        Thumbs = new FancyThumbs(instance);\r\n\r\n        if (Thumbs.isActive && Thumbs.opts.autoStart === true) {\r\n          Thumbs.show();\r\n        }\r\n      }\r\n    },\r\n\r\n    "beforeShow.fb": function (e, instance, item, firstRun) {\r\n      var Thumbs = instance && instance.Thumbs;\r\n\r\n      if (Thumbs && Thumbs.isVisible) {\r\n        Thumbs.focus(firstRun ? 0 : 250);\r\n      }\r\n    },\r\n\r\n    "afterKeydown.fb": function (e, instance, current, keypress, keycode) {\r\n      var Thumbs = instance && instance.Thumbs;\r\n\r\n      // "G"\r\n      if (Thumbs && Thumbs.isActive && keycode === 71) {\r\n        keypress.preventDefault();\r\n\r\n        Thumbs.toggle();\r\n      }\r\n    },\r\n\r\n    "beforeClose.fb": function (e, instance) {\r\n      var Thumbs = instance && instance.Thumbs;\r\n\r\n      if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {\r\n        Thumbs.$grid.hide();\r\n      }\r\n    }\r\n  });\r\n})(document, jQuery);\n//// ==========================================================================\r\n//\r\n// Share\r\n// Displays simple form for sharing current url\r\n//\r\n// ==========================================================================\r\n(function (document, $) {\r\n  "use strict";\r\n\r\n  $.extend(true, $.fancybox.defaults, {\r\n    btnTpl: {\r\n      share: \'<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}">\' +\r\n        \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg>\' +\r\n        "</button>"\r\n    },\r\n    share: {\r\n      url: function (instance, item) {\r\n        return (\r\n          (!instance.currentHash && !(item.type === "inline" || item.type === "html") ? item.origSrc || item.src : false) || window.location\r\n        );\r\n      },\r\n      tpl: \'<div class="fancybox-share">\' +\r\n        "<h1>{{SHARE}}</h1>" +\r\n        "<p>" +\r\n        \'<a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}">\' +\r\n        \'<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg>\' +\r\n        "<span>Facebook</span>" +\r\n        "</a>" +\r\n        \'<a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}">\' +\r\n        \'<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg>\' +\r\n        "<span>Twitter</span>" +\r\n        "</a>" +\r\n        \'<a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}">\' +\r\n        \'<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg>\' +\r\n        "<span>Pinterest</span>" +\r\n        "</a>" +\r\n        "</p>" +\r\n        \'<p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" /></p>\' +\r\n        "</div>"\r\n    }\r\n  });\r\n\r\n  function escapeHtml(string) {\r\n    var entityMap = {\r\n      "&": "&amp;",\r\n      "<": "&lt;",\r\n      ">": "&gt;",\r\n      \'"\': "&quot;",\r\n      "\'": "&#39;",\r\n      "/": "&#x2F;",\r\n      "`": "&#x60;",\r\n      "=": "&#x3D;"\r\n    };\r\n\r\n    return String(string).replace(/[&<>"\'`=\\/]/g, function (s) {\r\n      return entityMap[s];\r\n    });\r\n  }\r\n\r\n  $(document).on("click", "[data-fancybox-share]", function () {\r\n    var instance = $.fancybox.getInstance(),\r\n      current = instance.current || null,\r\n      url,\r\n      tpl;\r\n\r\n    if (!current) {\r\n      return;\r\n    }\r\n\r\n    if ($.type(current.opts.share.url) === "function") {\r\n      url = current.opts.share.url.apply(current, [instance, current]);\r\n    }\r\n\r\n    tpl = current.opts.share.tpl\r\n      .replace(/\\{\\{media\\}\\}/g, current.type === "image" ? encodeURIComponent(current.src) : "")\r\n      .replace(/\\{\\{url\\}\\}/g, encodeURIComponent(url))\r\n      .replace(/\\{\\{url_raw\\}\\}/g, escapeHtml(url))\r\n      .replace(/\\{\\{descr\\}\\}/g, instance.$caption ? encodeURIComponent(instance.$caption.text()) : "");\r\n\r\n    $.fancybox.open({\r\n      src: instance.translate(instance, tpl),\r\n      type: "html",\r\n      opts: {\r\n        touch: false,\r\n        animationEffect: false,\r\n        afterLoad: function (shareInstance, shareCurrent) {\r\n          // Close self if parent instance is closing\r\n          instance.$refs.container.one("beforeClose.fb", function () {\r\n            shareInstance.close(null, 0);\r\n          });\r\n\r\n          // Opening links in a popup window\r\n          shareCurrent.$content.find(".fancybox-share__button").click(function () {\r\n            window.open(this.href, "Share", "width=550, height=450");\r\n            return false;\r\n          });\r\n        },\r\n        mobile: {\r\n          autoFocus: false\r\n        }\r\n      }\r\n    });\r\n  });\r\n})(document, jQuery);\n// ==========================================================================\r\n//\r\n// Hash\r\n// Enables linking to each modal\r\n//\r\n// ==========================================================================\r\n(function (window, document, $) {\r\n  "use strict";\r\n\r\n  // Simple $.escapeSelector polyfill (for jQuery prior v3)\r\n  if (!$.escapeSelector) {\r\n    $.escapeSelector = function (sel) {\r\n      var rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g;\r\n      var fcssescape = function (ch, asCodePoint) {\r\n        if (asCodePoint) {\r\n          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\r\n          if (ch === "\\0") {\r\n            return "\\uFFFD";\r\n          }\r\n\r\n          // Control characters and (dependent upon position) numbers get escaped as code points\r\n          return ch.slice(0, -1) + "\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";\r\n        }\r\n\r\n        // Other potentially-special ASCII characters get backslash-escaped\r\n        return "\\\\" + ch;\r\n      };\r\n\r\n      return (sel + "").replace(rcssescape, fcssescape);\r\n    };\r\n  }\r\n\r\n  // Get info about gallery name and current index from url\r\n  function parseUrl() {\r\n    var hash = window.location.hash.substr(1),\r\n      rez = hash.split("-"),\r\n      index = rez.length > 1 && /^\\+?\\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1,\r\n      gallery = rez.join("-");\r\n\r\n    return {\r\n      hash: hash,\r\n      /* Index is starting from 1 */\r\n      index: index < 1 ? 1 : index,\r\n      gallery: gallery\r\n    };\r\n  }\r\n\r\n  // Trigger click evnt on links to open new fancyBox instance\r\n  function triggerFromUrl(url) {\r\n    if (url.gallery !== "") {\r\n      // If we can find element matching \'data-fancybox\' atribute,\r\n      // then triggering click event should start fancyBox\r\n      $("[data-fancybox=\'" + $.escapeSelector(url.gallery) + "\']")\r\n        .eq(url.index - 1)\r\n        .focus()\r\n        .trigger("click.fb-start");\r\n    }\r\n  }\r\n\r\n  // Get gallery name from current instance\r\n  function getGalleryID(instance) {\r\n    var opts, ret;\r\n\r\n    if (!instance) {\r\n      return false;\r\n    }\r\n\r\n    opts = instance.current ? instance.current.opts : instance.opts;\r\n    ret = opts.hash || (opts.$orig ? opts.$orig.data("fancybox") || opts.$orig.data("fancybox-trigger") : "");\r\n\r\n    return ret === "" ? false : ret;\r\n  }\r\n\r\n  // Start when DOM becomes ready\r\n  $(function () {\r\n    // Check if user has disabled this module\r\n    if ($.fancybox.defaults.hash === false) {\r\n      return;\r\n    }\r\n\r\n    // Update hash when opening/closing fancyBox\r\n    $(document).on({\r\n      "onInit.fb": function (e, instance) {\r\n        var url, gallery;\r\n\r\n        if (instance.group[instance.currIndex].opts.hash === false) {\r\n          return;\r\n        }\r\n\r\n        url = parseUrl();\r\n        gallery = getGalleryID(instance);\r\n\r\n        // Make sure gallery start index matches index from hash\r\n        if (gallery && url.gallery && gallery == url.gallery) {\r\n          instance.currIndex = url.index - 1;\r\n        }\r\n      },\r\n\r\n      "beforeShow.fb": function (e, instance, current, firstRun) {\r\n        var gallery;\r\n\r\n        if (!current || current.opts.hash === false) {\r\n          return;\r\n        }\r\n\r\n        // Check if need to update window hash\r\n        gallery = getGalleryID(instance);\r\n\r\n        if (!gallery) {\r\n          return;\r\n        }\r\n\r\n        // Variable containing last hash value set by fancyBox\r\n        // It will be used to determine if fancyBox needs to close after hash change is detected\r\n        instance.currentHash = gallery + (instance.group.length > 1 ? "-" + (current.index + 1) : "");\r\n\r\n        // If current hash is the same (this instance most likely is opened by hashchange), then do nothing\r\n        if (window.location.hash === "#" + instance.currentHash) {\r\n          return;\r\n        }\r\n\r\n        if (firstRun && !instance.origHash) {\r\n          instance.origHash = window.location.hash;\r\n        }\r\n\r\n        if (instance.hashTimer) {\r\n          clearTimeout(instance.hashTimer);\r\n        }\r\n\r\n        // Update hash\r\n        instance.hashTimer = setTimeout(function () {\r\n          if ("replaceState" in window.history) {\r\n            window.history[firstRun ? "pushState" : "replaceState"]({},\r\n              document.title,\r\n              window.location.pathname + window.location.search + "#" + instance.currentHash\r\n            );\r\n\r\n            if (firstRun) {\r\n              instance.hasCreatedHistory = true;\r\n            }\r\n          } else {\r\n            window.location.hash = instance.currentHash;\r\n          }\r\n\r\n          instance.hashTimer = null;\r\n        }, 300);\r\n      },\r\n\r\n      "beforeClose.fb": function (e, instance, current) {\r\n        if (!current || current.opts.hash === false) {\r\n          return;\r\n        }\r\n\r\n        clearTimeout(instance.hashTimer);\r\n\r\n        // Goto previous history entry\r\n        if (instance.currentHash && instance.hasCreatedHistory) {\r\n          window.history.back();\r\n        } else if (instance.currentHash) {\r\n          if ("replaceState" in window.history) {\r\n            window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || ""));\r\n          } else {\r\n            window.location.hash = instance.origHash;\r\n          }\r\n        }\r\n\r\n        instance.currentHash = null;\r\n      }\r\n    });\r\n\r\n    // Check if need to start/close after url has changed\r\n    $(window).on("hashchange.fb", function () {\r\n      var url = parseUrl(),\r\n        fb = null;\r\n\r\n      // Find last fancyBox instance that has "hash"\r\n      $.each(\r\n        $(".fancybox-container")\r\n        .get()\r\n        .reverse(),\r\n        function (index, value) {\r\n          var tmp = $(value).data("FancyBox");\r\n\r\n          if (tmp && tmp.currentHash) {\r\n            fb = tmp;\r\n            return false;\r\n          }\r\n        }\r\n      );\r\n\r\n      if (fb) {\r\n        // Now, compare hash values\r\n        if (fb.currentHash !== url.gallery + "-" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) {\r\n          fb.currentHash = null;\r\n\r\n          fb.close();\r\n        }\r\n      } else if (url.gallery !== "") {\r\n        triggerFromUrl(url);\r\n      }\r\n    });\r\n\r\n    // Check current hash and trigger click event on matching element to start fancyBox, if needed\r\n    setTimeout(function () {\r\n      if (!$.fancybox.getInstance()) {\r\n        triggerFromUrl(parseUrl());\r\n      }\r\n    }, 50);\r\n  });\r\n})(window, document, jQuery);\n// ==========================================================================\r\n//\r\n// Wheel\r\n// Basic mouse weheel support for gallery navigation\r\n//\r\n// ==========================================================================\r\n(function (document, $) {\r\n  "use strict";\r\n\r\n  var prevTime = new Date().getTime();\r\n\r\n  $(document).on({\r\n    "onInit.fb": function (e, instance, current) {\r\n      instance.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll", function (e) {\r\n        var current = instance.current,\r\n          currTime = new Date().getTime();\r\n\r\n        if (instance.group.length < 2 || current.opts.wheel === false || (current.opts.wheel === "auto" && current.type !== "image")) {\r\n          return;\r\n        }\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        if (current.$slide.hasClass("fancybox-animated")) {\r\n          return;\r\n        }\r\n\r\n        e = e.originalEvent || e;\r\n\r\n        if (currTime - prevTime < 250) {\r\n          return;\r\n        }\r\n\r\n        prevTime = currTime;\r\n\r\n        instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? "next" : "previous"]();\r\n      });\r\n    }\r\n  });\r\n})(document, jQuery);\n\n//# sourceURL=webpack://saasymail/./node_modules/@fancyapps/fancybox/dist/jquery.fancybox.js?')},"./build/scripts/components/general.js":
/*!*********************************************!*\
  !*** ./build/scripts/components/general.js ***!
  \*********************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (($, gsap) => {\n  $(function () {\n    // HOME EMAILS\n    // gsap.to('#email-grid .saasy-column', {\n    //     \"y\":0,\n    //     \"opacity\":1,\n    //     \"duration\":.4,\n    //     \"ease\": \"power1.inOut\",\n    //     // \"stagger\":.08\n    // });\n    // $('#email-grid').hover(function() {\n    //     gsap.to('#email-grid .saasy-column', {\n    //         \"y\":0,\n    //         \"opacity\":1,\n    //         \"duration\":.4,\n    //         \"ease\": \"power1.inOut\",\n    //         // \"stagger\":.08\n    //     });\n    // }, function() {\n    //\n    // });\n    // TOOLTIPS\n    $('[data-toggle=\"tooltip\"]').tooltip();\n    $('.tooltipit').tooltip();\n    // POPOVERS\n    $('.popoverit').popover();\n    // SCROLL LINK\n    $(\"a.scroll-link\").click(function (e) {\n      e.preventDefault();\n      let target = $(this).attr(\"href\");\n      if ($('body').hasClass('page-template-soctwo')) {\n        $('a.scroll-link.active').removeClass('active');\n        $(this).addClass('active');\n        gsap.to(window, {\n          duration: 1,\n          scrollTo: $(target).offset().top - 60\n        });\n      } else {\n        gsap.to(window, {\n          duration: 1,\n          scrollTo: $(target).offset().top - 40\n        });\n      }\n    });\n    $(\".related-resources\").owlCarousel({\n      items: 3,\n      loop: true,\n      margin: 30,\n      dots: false,\n      nav: true,\n      autoplay: false,\n      fluidSpeed: true,\n      smartSpeed: 1200,\n      singleItem: true,\n      responsive: {\n        0: {\n          items: 1,\n          nav: false,\n          dots: true\n        },\n        600: {\n          items: 2,\n          nav: false,\n          dots: true\n        },\n        1000: {\n          items: 3,\n          nav: true,\n          dots: false\n        }\n      }\n    });\n    document.addEventListener('scroll', showScrollbar);\n    document.addEventListener('resize', showScrollbar);\n    function showScrollbar() {\n      if (window.outerWidth > 1000) {\n        let scrollbar = document.getElementById('scrollbar');\n        if (window.scrollY > window.outerHeight + 100) {\n          scrollbar.style.display = 'flex';\n        } else {\n          scrollbar.style.display = 'none';\n        }\n      } else {\n        scrollbar.style.display = 'none';\n      }\n    }\n  });\n});\n\n//# sourceURL=webpack://saasymail/./build/scripts/components/general.js?")},"./build/scripts/home.js":
/*!*******************************!*\
  !*** ./build/scripts/home.js ***!
  \*******************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.js");\n/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bootstrap__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _fancyapps_fancybox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fancyapps/fancybox */ "./node_modules/@fancyapps/fancybox/dist/jquery.fancybox.js");\n/* harmony import */ var _fancyapps_fancybox__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_fancyapps_fancybox__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var jquery_cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery.cookie */ "./node_modules/jquery.cookie/jquery.cookie.js");\n/* harmony import */ var jquery_cookie__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_cookie__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! owl.carousel */ "./node_modules/owl.carousel/dist/owl.carousel.js");\n/* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(owl_carousel__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _vendor_gsap_src_all__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/gsap/src/all */ "./build/scripts/vendor/gsap/src/all.js");\n/* harmony import */ var _vendor_gsap_src_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vendor/gsap/src/ScrollToPlugin */ "./build/scripts/vendor/gsap/src/ScrollToPlugin.js");\n/* harmony import */ var _vendor_gsap_src_ScrollTrigger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vendor/gsap/src/ScrollTrigger */ "./build/scripts/vendor/gsap/src/ScrollTrigger.js");\n/* harmony import */ var _components_general__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/general */ "./build/scripts/components/general.js");\n/* harmony import */ var _templates_home__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./templates/home */ "./build/scripts/templates/home.js");\n/* harmony import */ var _parts_menu__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parts/menu */ "./build/scripts/parts/menu.js");\n\n\n\n\n\n\n\n_vendor_gsap_src_all__WEBPACK_IMPORTED_MODULE_4__.gsap.registerPlugin(_vendor_gsap_src_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_5__.ScrollToPlugin, _vendor_gsap_src_ScrollTrigger__WEBPACK_IMPORTED_MODULE_6__.ScrollTrigger);\n\n\n\nwindow.jQuery($ => {\n  (0,_components_general__WEBPACK_IMPORTED_MODULE_7__["default"])($, _vendor_gsap_src_all__WEBPACK_IMPORTED_MODULE_4__.gsap);\n  (0,_templates_home__WEBPACK_IMPORTED_MODULE_8__["default"])(window, $);\n  (0,_parts_menu__WEBPACK_IMPORTED_MODULE_9__["default"])(window, $);\n});\n\n//# sourceURL=webpack://saasymail/./build/scripts/home.js?')},"./build/scripts/parts/menu.js":
/*!*************************************!*\
  !*** ./build/scripts/parts/menu.js ***!
  \*************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((window, $) => {\n  $(function () {\n    $(".js-menu_toggle").click(function (e) {\n      $("#header").toggleClass("active");\n      $(this).toggleClass("active");\n    });\n    $(window).resize(function () {\n      $("#header").removeClass("active");\n      $(".js-menu_toggle").removeClass("active");\n    });\n    $(".header__mobile-navigation > ul > li > a").click(function (e) {\n      if ($(this).hasClass("has-menu")) {\n        e.preventDefault();\n      }\n      $(this).parent("li").toggleClass("active").siblings().removeClass("active");\n    });\n  });\n});\n\n//# sourceURL=webpack://saasymail/./build/scripts/parts/menu.js?')},"./build/scripts/templates/home.js":
/*!*****************************************!*\
  !*** ./build/scripts/templates/home.js ***!
  \*****************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((window, $) => {\n  $(document).ready(function () {\n    $(".customer-carousel").owlCarousel({\n      items: 12,\n      loop: true,\n      margin: 30,\n      dots: false,\n      nav: false,\n      autoplay: true,\n      fluidSpeed: true,\n      smartSpeed: 800,\n      responsive: {\n        0: {\n          items: 3,\n          nav: false,\n          dots: true\n        },\n        600: {\n          items: 6,\n          nav: false,\n          dots: true\n        },\n        1000: {\n          items: 10,\n          nav: false,\n          dots: false\n        }\n      }\n    });\n  });\n});\n\n//# sourceURL=webpack://saasymail/./build/scripts/templates/home.js?')},"./build/scripts/vendor/gsap/src/CSSPlugin.js":
/*!****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/CSSPlugin.js ***!
  \****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSPlugin: () => (/* binding */ CSSPlugin),\n/* harmony export */   _createElement: () => (/* binding */ _createElement),\n/* harmony export */   _getBBox: () => (/* binding */ _getBBox),\n/* harmony export */   checkPrefix: () => (/* binding */ _checkPropPrefix),\n/* harmony export */   "default": () => (/* binding */ CSSPlugin)\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./build/scripts/vendor/gsap/src/gsap-core.js");\n/*!\n * CSSPlugin 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet _win,\n  _doc,\n  _docElement,\n  _pluginInitted,\n  _tempDiv,\n  _tempDivStyler,\n  _recentSetterPlugin,\n  _windowExists = () => typeof window !== "undefined",\n  _transformProps = {},\n  _RAD2DEG = 180 / Math.PI,\n  _DEG2RAD = Math.PI / 180,\n  _atan2 = Math.atan2,\n  _bigNum = 1e8,\n  _capsExp = /([A-Z])/g,\n  _horizontalExp = /(?:left|right|width|margin|padding|x)/i,\n  _complexExp = /[\\s,\\(]\\S/,\n  _propertyAliases = {\n    autoAlpha: "opacity,visibility",\n    scale: "scaleX,scaleY",\n    alpha: "opacity"\n  },\n  _renderCSSProp = (ratio, data) => data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data),\n  _renderPropWithEnd = (ratio, data) => data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data),\n  _renderCSSPropWithBeginning = (ratio, data) => data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data),\n  //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n  _renderRoundedCSSProp = (ratio, data) => {\n    let value = data.s + data.c * ratio;\n    data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n  },\n  _renderNonTweeningValue = (ratio, data) => data.set(data.t, data.p, ratio ? data.e : data.b, data),\n  _renderNonTweeningValueOnlyAtEnd = (ratio, data) => data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data),\n  _setterCSSStyle = (target, property, value) => target.style[property] = value,\n  _setterCSSProp = (target, property, value) => target.style.setProperty(property, value),\n  _setterTransform = (target, property, value) => target._gsap[property] = value,\n  _setterScale = (target, property, value) => target._gsap.scaleX = target._gsap.scaleY = value,\n  _setterScaleWithRender = (target, property, value, data, ratio) => {\n    let cache = target._gsap;\n    cache.scaleX = cache.scaleY = value;\n    cache.renderTransform(ratio, cache);\n  },\n  _setterTransformWithRender = (target, property, value, data, ratio) => {\n    let cache = target._gsap;\n    cache[property] = value;\n    cache.renderTransform(ratio, cache);\n  },\n  _transformProp = "transform",\n  _transformOriginProp = _transformProp + "Origin",\n  _supports3D,\n  _createElement = (type, ns) => {\n    let e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.\n    return e.style ? e : _doc.createElement(type); //some environments won\'t allow access to the element\'s style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won\'t allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n  },\n  _getComputedProperty = (target, property, skipPrefixFallback) => {\n    let cs = getComputedStyle(target);\n    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.\n  },\n  _prefixes = "O,Moz,ms,Ms,Webkit".split(","),\n  _checkPropPrefix = (property, element, preferPrefix) => {\n    let e = element || _tempDiv,\n      s = e.style,\n      i = 5;\n    if (property in s && !preferPrefix) {\n      return property;\n    }\n    property = property.charAt(0).toUpperCase() + property.substr(1);\n    while (i-- && !(_prefixes[i] + property in s)) {}\n    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;\n  },\n  _initCore = () => {\n    if (_windowExists() && window.document) {\n      _win = window;\n      _doc = _win.document;\n      _docElement = _doc.documentElement;\n      _tempDiv = _createElement("div") || {\n        style: {}\n      };\n      _tempDivStyler = _createElement("div");\n      _transformProp = _checkPropPrefix(_transformProp);\n      _transformOriginProp = _transformProp + "Origin";\n      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n      _supports3D = !!_checkPropPrefix("perspective");\n      _pluginInitted = 1;\n    }\n  },\n  _getBBoxHack = function (swapIfPossible) {\n    //works around issues in some browsers (like Firefox) that don\'t correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it\'s definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don\'t need it).\n    let svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),\n      oldParent = this.parentNode,\n      oldSibling = this.nextSibling,\n      oldCSS = this.style.cssText,\n      bbox;\n    _docElement.appendChild(svg);\n    svg.appendChild(this);\n    this.style.display = "block";\n    if (swapIfPossible) {\n      try {\n        bbox = this.getBBox();\n        this._gsapBBox = this.getBBox; //store the original\n        this.getBBox = _getBBoxHack;\n      } catch (e) {}\n    } else if (this._gsapBBox) {\n      bbox = this._gsapBBox();\n    }\n    if (oldParent) {\n      if (oldSibling) {\n        oldParent.insertBefore(this, oldSibling);\n      } else {\n        oldParent.appendChild(this);\n      }\n    }\n    _docElement.removeChild(svg);\n    this.style.cssText = oldCSS;\n    return bbox;\n  },\n  _getAttributeFallbacks = (target, attributesArray) => {\n    let i = attributesArray.length;\n    while (i--) {\n      if (target.hasAttribute(attributesArray[i])) {\n        return target.getAttribute(attributesArray[i]);\n      }\n    }\n  },\n  _getBBox = target => {\n    let bounds;\n    try {\n      bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that\'s not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n    } catch (error) {\n      bounds = _getBBoxHack.call(target, true);\n    }\n    bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));\n    //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it\'s at x:0, y:0), thus we need to manually grab the position in that case.\n    return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,\n      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,\n      width: 0,\n      height: 0\n    } : bounds;\n  },\n  _isSVG = e => !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e)),\n  //reports if the element is an SVG on which getBBox() actually works\n  _removeProperty = (target, property) => {\n    if (property) {\n      let style = target.style;\n      if (property in _transformProps && property !== _transformOriginProp) {\n        property = _transformProp;\n      }\n      if (style.removeProperty) {\n        if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {\n          //Microsoft and some Webkit browsers don\'t conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it\'s correct (otherwise it\'d be "ms-transform" instead of "-ms-transform" for IE9, for example)\n          property = "-" + property;\n        }\n        style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());\n      } else {\n        //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"\n        style.removeAttribute(property);\n      }\n    }\n  },\n  _addNonTweeningPT = (plugin, target, property, beginning, end, onlySetAtEnd) => {\n    let pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n    plugin._pt = pt;\n    pt.b = beginning;\n    pt.e = end;\n    plugin._props.push(property);\n    return pt;\n  },\n  _nonConvertibleUnits = {\n    deg: 1,\n    rad: 1,\n    turn: 1\n  },\n  //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.\n  _convertToUnit = (target, property, value, unit) => {\n    let curValue = parseFloat(value) || 0,\n      curUnit = (value + "").trim().substr((curValue + "").length) || "px",\n      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n      style = _tempDiv.style,\n      horizontal = _horizontalExp.test(property),\n      isRootSVG = target.tagName.toLowerCase() === "svg",\n      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),\n      amount = 100,\n      toPixels = unit === "px",\n      toPercent = unit === "%",\n      px,\n      parent,\n      cache,\n      isSVG;\n    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n      return curValue;\n    }\n    curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));\n    isSVG = target.getCTM && _isSVG(target);\n    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {\n      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];\n      return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);\n    }\n    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);\n    parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;\n    if (isSVG) {\n      parent = (target.ownerSVGElement || {}).parentNode;\n    }\n    if (!parent || parent === _doc || !parent.appendChild) {\n      parent = _doc.body;\n    }\n    cache = parent._gsap;\n    if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {\n      return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);\n    } else {\n      (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));\n      parent === target && (style.position = "static"); // like for borderRadius, if it\'s a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it\'d go up the chain until it finds its offsetParent (bad). position: static protects against that.\n      parent.appendChild(_tempDiv);\n      px = _tempDiv[measureProperty];\n      parent.removeChild(_tempDiv);\n      style.position = "absolute";\n      if (horizontal && toPercent) {\n        cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);\n        cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;\n        cache.width = parent[measureProperty];\n      }\n    }\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n  },\n  _get = (target, property, unit, uncache) => {\n    let value;\n    _pluginInitted || _initCore();\n    if (property in _propertyAliases && property !== "transform") {\n      property = _propertyAliases[property];\n      if (~property.indexOf(",")) {\n        property = property.split(",")[0];\n      }\n    }\n    if (_transformProps[property] && property !== "transform") {\n      value = _parseTransform(target, uncache);\n      value = property !== "transformOrigin" ? value[property] : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";\n    } else {\n      value = target.style[property];\n      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {\n        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don\'t report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n      }\n    }\n    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;\n  },\n  _tweenComplexCSSString = function (target, prop, start, end) {\n    //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n    if (!start || start === "none") {\n      // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it\'s set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n      let p = _checkPropPrefix(prop, target, 1),\n        s = p && _getComputedProperty(target, p, 1);\n      if (s && s !== start) {\n        prop = p;\n        start = s;\n      } else if (prop === "borderColor") {\n        start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n      }\n    }\n    let pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),\n      index = 0,\n      matchIndex = 0,\n      a,\n      result,\n      startValues,\n      startNum,\n      color,\n      startValue,\n      endValue,\n      endNum,\n      chunk,\n      endUnit,\n      startUnit,\n      relative,\n      endValues;\n    pt.b = start;\n    pt.e = end;\n    start += ""; //ensure values are strings\n    end += "";\n    if (end === "auto") {\n      target.style[prop] = end;\n      end = _getComputedProperty(target, prop) || end;\n      target.style[prop] = start;\n    }\n    a = [start, end];\n    (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n    start = a[0];\n    end = a[1];\n    startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];\n    if (endValues.length) {\n      while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {\n        endValue = result[0];\n        chunk = end.substring(index, result.index);\n        if (color) {\n          color = (color + 1) % 5;\n        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {\n          color = 1;\n        }\n        if (endValue !== (startValue = startValues[matchIndex++] || "")) {\n          startNum = parseFloat(startValue) || 0;\n          startUnit = startValue.substr((startNum + "").length);\n          relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;\n          if (relative) {\n            endValue = endValue.substr(2);\n          }\n          endNum = parseFloat(endValue);\n          endUnit = endValue.substr((endNum + "").length);\n          index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;\n          if (!endUnit) {\n            //if something like "perspective:300" is passed in and we must add a unit to the end\n            endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;\n            if (index === end.length) {\n              end += endUnit;\n              pt.e += endUnit;\n            }\n          }\n          if (startUnit !== endUnit) {\n            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n          }\n          //these nested PropTweens are handled in a special way - we\'ll never actually call a render or setter method on them. We\'ll just loop through them in the parent complex string PropTween\'s render method.\n          pt._pt = {\n            _next: pt._pt,\n            p: chunk || matchIndex === 1 ? chunk : ",",\n            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n            s: startNum,\n            c: relative ? relative * endNum : endNum - startNum,\n            m: color && color < 4 || prop === "zIndex" ? Math.round : 0\n          };\n        }\n      }\n      pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)\n    } else {\n      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n    }\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don\'t actually set it to the string with += or -= characters (forces it to use the calculated value).\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it\'s scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.\n    return pt;\n  },\n  _keywordToPercent = {\n    top: "0%",\n    bottom: "100%",\n    left: "0%",\n    right: "100%",\n    center: "50%"\n  },\n  _convertKeywordsToPercentages = value => {\n    let split = value.split(" "),\n      x = split[0],\n      y = split[1] || "50%";\n    if (x === "top" || x === "bottom" || y === "left" || y === "right") {\n      //the user provided them in the wrong order, so flip them\n      value = x;\n      x = y;\n      y = value;\n    }\n    split[0] = _keywordToPercent[x] || x;\n    split[1] = _keywordToPercent[y] || y;\n    return split.join(" ");\n  },\n  _renderClearProps = (ratio, data) => {\n    if (data.tween && data.tween._time === data.tween._dur) {\n      let target = data.t,\n        style = target.style,\n        props = data.u,\n        cache = target._gsap,\n        prop,\n        clearTransforms,\n        i;\n      if (props === "all" || props === true) {\n        style.cssText = "";\n        clearTransforms = 1;\n      } else {\n        props = props.split(",");\n        i = props.length;\n        while (--i > -1) {\n          prop = props[i];\n          if (_transformProps[prop]) {\n            clearTransforms = 1;\n            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;\n          }\n          _removeProperty(target, prop);\n        }\n      }\n      if (clearTransforms) {\n        _removeProperty(target, _transformProp);\n        if (cache) {\n          cache.svg && target.removeAttribute("transform");\n          _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there\'s another tween that\'s already set to render transforms on this element, it could display the wrong values.\n          cache.uncache = 1;\n        }\n      }\n    }\n  },\n  // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n  _specialProps = {\n    clearProps(plugin, target, property, endValue, tween) {\n      if (tween.data !== "isFromStart") {\n        let pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n        pt.u = endValue;\n        pt.pr = -10;\n        pt.tween = tween;\n        plugin._props.push(property);\n        return 1;\n      }\n    }\n    /* className feature (about 0.4kb gzipped).\n    , className(plugin, target, property, endValue, tween) {\n    \tlet _renderClassName = (ratio, data) => {\n    \t\t\tdata.css.render(ratio, data.css);\n    \t\t\tif (!ratio || ratio === 1) {\n    \t\t\t\tlet inline = data.rmv,\n    \t\t\t\t\ttarget = data.t,\n    \t\t\t\t\tp;\n    \t\t\t\ttarget.setAttribute("class", ratio ? data.e : data.b);\n    \t\t\t\tfor (p in inline) {\n    \t\t\t\t\t_removeProperty(target, p);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t},\n    \t\t_getAllStyles = (target) => {\n    \t\t\tlet styles = {},\n    \t\t\t\tcomputed = getComputedStyle(target),\n    \t\t\t\tp;\n    \t\t\tfor (p in computed) {\n    \t\t\t\tif (isNaN(p) && p !== "cssText" && p !== "length") {\n    \t\t\t\t\tstyles[p] = computed[p];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t_setDefaults(styles, _parseTransform(target, 1));\n    \t\t\treturn styles;\n    \t\t},\n    \t\tstartClassList = target.getAttribute("class"),\n    \t\tstyle = target.style,\n    \t\tcssText = style.cssText,\n    \t\tcache = target._gsap,\n    \t\tclassPT = cache.classPT,\n    \t\tinlineToRemoveAtEnd = {},\n    \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\\\s|^)" + endValue.substr(2) + "(?![\\\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},\n    \t\tchangingVars = {},\n    \t\tstartVars = _getAllStyles(target),\n    \t\ttransformRelated = /(transform|perspective)/i,\n    \t\tendVars, p;\n    \tif (classPT) {\n    \t\tclassPT.r(1, classPT.d);\n    \t\t_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");\n    \t}\n    \ttarget.setAttribute("class", data.e);\n    \tendVars = _getAllStyles(target, true);\n    \ttarget.setAttribute("class", startClassList);\n    \tfor (p in endVars) {\n    \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\n    \t\t\tchangingVars[p] = endVars[p];\n    \t\t\tif (!style[p] && style[p] !== "0") {\n    \t\t\t\tinlineToRemoveAtEnd[p] = 1;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);\n    \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that\'s pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\n    \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can\'t override properties we\'ve directly set on the target\'s style object due to specificity).\n    \t}\n    \t_parseTransform(target, true); //to clear the caching of transforms\n    \tdata.css = new gsap.plugins.css();\n    \tdata.css.init(target, changingVars, tween);\n    \tplugin._props.push(...data.css._props);\n    \treturn 1;\n    }\n    */\n  },\n  /*\n   * --------------------------------------------------------------------------------------\n   * TRANSFORMS\n   * --------------------------------------------------------------------------------------\n   */\n  _identity2DMatrix = [1, 0, 0, 1, 0, 0],\n  _rotationalProperties = {},\n  _isNullTransform = value => value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value,\n  _getComputedTransformMatrixAsArray = target => {\n    let matrixString = _getComputedProperty(target, _transformProp);\n    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);\n  },\n  _getMatrix = (target, force2D) => {\n    let cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),\n      style = target.style,\n      matrix = _getComputedTransformMatrixAsArray(target),\n      parent,\n      nextSibling,\n      temp,\n      addedToDOM;\n    if (cache.svg && target.getAttribute("transform")) {\n      temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.\n      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;\n    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n      //note: if offsetParent is null, that means the element isn\'t in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n      //browsers don\'t report transforms accurately unless the element is in the DOM and has a display value that\'s not "none". Firefox and Microsoft browsers have a partial bug where they\'ll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it\'s translate(0, 8px).\n      temp = style.display;\n      style.display = "block";\n      parent = target.parentNode;\n      if (!parent || !target.offsetParent) {\n        // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn\'t adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375\n        addedToDOM = 1; //flag\n        nextSibling = target.nextSibling;\n        _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n      }\n      matrix = _getComputedTransformMatrixAsArray(target);\n      temp ? style.display = temp : _removeProperty(target, "display");\n      if (addedToDOM) {\n        nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n      }\n    }\n    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n  },\n  _applySVGOrigin = (target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) => {\n    let cache = target._gsap,\n      matrix = matrixArray || _getMatrix(target, true),\n      xOriginOld = cache.xOrigin || 0,\n      yOriginOld = cache.yOrigin || 0,\n      xOffsetOld = cache.xOffset || 0,\n      yOffsetOld = cache.yOffset || 0,\n      a = matrix[0],\n      b = matrix[1],\n      c = matrix[2],\n      d = matrix[3],\n      tx = matrix[4],\n      ty = matrix[5],\n      originSplit = origin.split(" "),\n      xOrigin = parseFloat(originSplit[0]) || 0,\n      yOrigin = parseFloat(originSplit[1]) || 0,\n      bounds,\n      determinant,\n      x,\n      y;\n    if (!originIsAbsolute) {\n      bounds = _getBBox(target);\n      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);\n      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);\n    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n      //if it\'s zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n      xOrigin = x;\n      yOrigin = y;\n    }\n    if (smooth || smooth !== false && cache.smooth) {\n      tx = xOrigin - xOriginOld;\n      ty = yOrigin - yOriginOld;\n      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n    } else {\n      cache.xOffset = cache.yOffset = 0;\n    }\n    cache.xOrigin = xOrigin;\n    cache.yOrigin = yOrigin;\n    cache.smooth = !!smooth;\n    cache.origin = origin;\n    cache.originIsAbsolute = !!originIsAbsolute;\n    target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we\'re baking the origin into the matrix() value).\n    if (pluginToAddPropTweensTo) {\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);\n      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);\n    }\n    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);\n  },\n  _parseTransform = (target, uncache) => {\n    let cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);\n    if ("x" in cache && !uncache && !cache.uncache) {\n      return cache;\n    }\n    let style = target.style,\n      invertedScaleX = cache.scaleX < 0,\n      px = "px",\n      deg = "deg",\n      origin = _getComputedProperty(target, _transformOriginProp) || "0",\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      rotation,\n      rotationX,\n      rotationY,\n      skewX,\n      skewY,\n      perspective,\n      xOrigin,\n      yOrigin,\n      matrix,\n      angle,\n      cos,\n      sin,\n      a,\n      b,\n      c,\n      d,\n      a12,\n      a22,\n      t1,\n      t2,\n      t3,\n      a13,\n      a23,\n      a33,\n      a42,\n      a43,\n      a32;\n    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n    scaleX = scaleY = 1;\n    cache.svg = !!(target.getCTM && _isSVG(target));\n    matrix = _getMatrix(target, cache.svg);\n    if (cache.svg) {\n      t1 = !cache.uncache && !uncache && target.getAttribute("data-svg-origin");\n      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n    }\n    xOrigin = cache.xOrigin || 0;\n    yOrigin = cache.yOrigin || 0;\n    if (matrix !== _identity2DMatrix) {\n      a = matrix[0]; //a11\n      b = matrix[1]; //a21\n      c = matrix[2]; //a31\n      d = matrix[3]; //a41\n      x = a12 = matrix[4];\n      y = a22 = matrix[5];\n\n      //2D matrix\n      if (matrix.length === 6) {\n        scaleX = Math.sqrt(a * a + b * b);\n        scaleY = Math.sqrt(d * d + c * c);\n        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn\'t exist).\n        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n        if (cache.svg) {\n          x -= xOrigin - (xOrigin * a + yOrigin * c);\n          y -= yOrigin - (xOrigin * b + yOrigin * d);\n        }\n\n        //3D matrix\n      } else {\n        a32 = matrix[6];\n        a42 = matrix[7];\n        a13 = matrix[8];\n        a23 = matrix[9];\n        a33 = matrix[10];\n        a43 = matrix[11];\n        x = matrix[12];\n        y = matrix[13];\n        z = matrix[14];\n        angle = _atan2(a32, a33);\n        rotationX = angle * _RAD2DEG;\n        //rotationX\n        if (angle) {\n          cos = Math.cos(-angle);\n          sin = Math.sin(-angle);\n          t1 = a12 * cos + a13 * sin;\n          t2 = a22 * cos + a23 * sin;\n          t3 = a32 * cos + a33 * sin;\n          a13 = a12 * -sin + a13 * cos;\n          a23 = a22 * -sin + a23 * cos;\n          a33 = a32 * -sin + a33 * cos;\n          a43 = a42 * -sin + a43 * cos;\n          a12 = t1;\n          a22 = t2;\n          a32 = t3;\n        }\n        //rotationY\n        angle = _atan2(-c, a33);\n        rotationY = angle * _RAD2DEG;\n        if (angle) {\n          cos = Math.cos(-angle);\n          sin = Math.sin(-angle);\n          t1 = a * cos - a13 * sin;\n          t2 = b * cos - a23 * sin;\n          t3 = c * cos - a33 * sin;\n          a43 = d * sin + a43 * cos;\n          a = t1;\n          b = t2;\n          c = t3;\n        }\n        //rotationZ\n        angle = _atan2(b, a);\n        rotation = angle * _RAD2DEG;\n        if (angle) {\n          cos = Math.cos(angle);\n          sin = Math.sin(angle);\n          t1 = a * cos + b * sin;\n          t2 = a12 * cos + a22 * sin;\n          b = b * cos - a * sin;\n          a22 = a22 * cos - a12 * sin;\n          a = t1;\n          a12 = t2;\n        }\n        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n          //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n          rotationX = rotation = 0;\n          rotationY = 180 - rotationY;\n        }\n        scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));\n        scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));\n        angle = _atan2(a12, a22);\n        skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n      }\n      if (cache.svg) {\n        //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can\'t just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n        t1 = target.getAttribute("transform");\n        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n        t1 && target.setAttribute("transform", t1);\n      }\n    }\n    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n      if (invertedScaleX) {\n        scaleX *= -1;\n        skewX += rotation <= 0 ? 180 : -180;\n        rotation += rotation <= 0 ? 180 : -180;\n      } else {\n        scaleY *= -1;\n        skewX += skewX <= 0 ? 180 : -180;\n      }\n    }\n    cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n    cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n    cache.z = z + px;\n    cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);\n    cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);\n    cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;\n    cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;\n    cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;\n    cache.skewX = skewX + deg;\n    cache.skewY = skewY + deg;\n    cache.transformPerspective = perspective + px;\n    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {\n      style[_transformOriginProp] = _firstTwoOnly(origin);\n    }\n    cache.xOffset = cache.yOffset = 0;\n    cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;\n    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n    cache.uncache = 0;\n    return cache;\n  },\n  _firstTwoOnly = value => (value = value.split(" "))[0] + " " + value[1],\n  //for handling transformOrigin values, stripping out the 3rd dimension\n  _addPxTranslate = (target, start, value) => {\n    let unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);\n    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;\n  },\n  _renderNon3DTransforms = (ratio, cache) => {\n    cache.z = "0px";\n    cache.rotationY = cache.rotationX = "0deg";\n    cache.force3D = 0;\n    _renderCSSTransforms(ratio, cache);\n  },\n  _zeroDeg = "0deg",\n  _zeroPx = "0px",\n  _endParenthesis = ") ",\n  _renderCSSTransforms = function (ratio, cache) {\n    let {\n        xPercent,\n        yPercent,\n        x,\n        y,\n        z,\n        rotation,\n        rotationY,\n        rotationX,\n        skewX,\n        skewY,\n        scaleX,\n        scaleY,\n        transformPerspective,\n        force3D,\n        target,\n        zOrigin\n      } = cache || this,\n      transforms = "",\n      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;\n\n    // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n      let angle = parseFloat(rotationY) * _DEG2RAD,\n        a13 = Math.sin(angle),\n        a33 = Math.cos(angle),\n        cos;\n      angle = parseFloat(rotationX) * _DEG2RAD;\n      cos = Math.cos(angle);\n      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n    }\n    if (transformPerspective !== _zeroPx) {\n      transforms += "perspective(" + transformPerspective + _endParenthesis;\n    }\n    if (xPercent || yPercent) {\n      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";\n    }\n    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;\n    }\n    if (rotation !== _zeroDeg) {\n      transforms += "rotate(" + rotation + _endParenthesis;\n    }\n    if (rotationY !== _zeroDeg) {\n      transforms += "rotateY(" + rotationY + _endParenthesis;\n    }\n    if (rotationX !== _zeroDeg) {\n      transforms += "rotateX(" + rotationX + _endParenthesis;\n    }\n    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;\n    }\n    if (scaleX !== 1 || scaleY !== 1) {\n      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;\n    }\n    target.style[_transformProp] = transforms || "translate(0, 0)";\n  },\n  _renderSVGTransforms = function (ratio, cache) {\n    let {\n        xPercent,\n        yPercent,\n        x,\n        y,\n        rotation,\n        skewX,\n        skewY,\n        scaleX,\n        scaleY,\n        target,\n        xOrigin,\n        yOrigin,\n        xOffset,\n        yOffset,\n        forceCSS\n      } = cache || this,\n      tx = parseFloat(x),\n      ty = parseFloat(y),\n      a11,\n      a21,\n      a12,\n      a22,\n      temp;\n    rotation = parseFloat(rotation);\n    skewX = parseFloat(skewX);\n    skewY = parseFloat(skewY);\n    if (skewY) {\n      //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n      skewY = parseFloat(skewY);\n      skewX += skewY;\n      rotation += skewY;\n    }\n    if (rotation || skewX) {\n      rotation *= _DEG2RAD;\n      skewX *= _DEG2RAD;\n      a11 = Math.cos(rotation) * scaleX;\n      a21 = Math.sin(rotation) * scaleX;\n      a12 = Math.sin(rotation - skewX) * -scaleY;\n      a22 = Math.cos(rotation - skewX) * scaleY;\n      if (skewX) {\n        skewY *= _DEG2RAD;\n        temp = Math.tan(skewX - skewY);\n        temp = Math.sqrt(1 + temp * temp);\n        a12 *= temp;\n        a22 *= temp;\n        if (skewY) {\n          temp = Math.tan(skewY);\n          temp = Math.sqrt(1 + temp * temp);\n          a11 *= temp;\n          a21 *= temp;\n        }\n      }\n      a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);\n      a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);\n      a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);\n      a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);\n    } else {\n      a11 = scaleX;\n      a22 = scaleY;\n      a21 = a12 = 0;\n    }\n    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {\n      tx = _convertToUnit(target, "x", x, "px");\n      ty = _convertToUnit(target, "y", y, "px");\n    }\n    if (xOrigin || yOrigin || xOffset || yOffset) {\n      tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n      ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n    }\n    if (xPercent || yPercent) {\n      //The SVG spec doesn\'t support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.\n      temp = target.getBBox();\n      tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);\n      ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);\n    }\n    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";\n    target.setAttribute("transform", temp);\n    forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won\'t render the  transform attribute changes!)\n  },\n  _addRotationalPropTween = function (plugin, target, property, startNum, endValue, relative) {\n    let cap = 360,\n      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),\n      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),\n      change = relative ? endNum * relative : endNum - startNum,\n      finalValue = startNum + change + "deg",\n      direction,\n      pt;\n    if (isString) {\n      direction = endValue.split("_")[1];\n      if (direction === "short") {\n        change %= cap;\n        if (change !== change % (cap / 2)) {\n          change += change < 0 ? cap : -cap;\n        }\n      }\n      if (direction === "cw" && change < 0) {\n        change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n      } else if (direction === "ccw" && change > 0) {\n        change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n      }\n    }\n    plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    pt.u = "deg";\n    plugin._props.push(property);\n    return pt;\n  },\n  _assign = (target, source) => {\n    // Internet Explorer doesn\'t have Object.assign(), so we recreate it here.\n    for (let p in source) {\n      target[p] = source[p];\n    }\n    return target;\n  },\n  _addRawTransformPTs = (plugin, transforms, target) => {\n    //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"\n    let startCache = _assign({}, target._gsap),\n      exclude = "perspective,force3D,transformOrigin,svgOrigin",\n      style = target.style,\n      endCache,\n      p,\n      startValue,\n      endValue,\n      startNum,\n      endNum,\n      startUnit,\n      endUnit;\n    if (startCache.svg) {\n      startValue = target.getAttribute("transform");\n      target.setAttribute("transform", "");\n      style[_transformProp] = transforms;\n      endCache = _parseTransform(target, 1);\n      _removeProperty(target, _transformProp);\n      target.setAttribute("transform", startValue);\n    } else {\n      startValue = getComputedStyle(target)[_transformProp];\n      style[_transformProp] = transforms;\n      endCache = _parseTransform(target, 1);\n      style[_transformProp] = startValue;\n    }\n    for (p in _transformProps) {\n      startValue = startCache[p];\n      endValue = endCache[p];\n      if (startValue !== endValue && exclude.indexOf(p) < 0) {\n        //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n        startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n        endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n        endNum = parseFloat(endValue);\n        plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n        plugin._pt.u = endUnit || 0;\n        plugin._props.push(p);\n      }\n    }\n    _assign(endCache, startCache);\n  };\n\n// handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won\'t report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", (name, index) => {\n  let t = "Top",\n    r = "Right",\n    b = "Bottom",\n    l = "Left",\n    props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(side => index < 2 ? name + side : "border" + side + name);\n  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {\n    let a, vars;\n    if (arguments.length < 4) {\n      // getter, passed target, property, and unit (from _get())\n      a = props.map(prop => _get(plugin, prop, property));\n      vars = a.join(" ");\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\n    }\n    a = (endValue + "").split(" ");\n    vars = {};\n    props.forEach((prop, i) => vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0]);\n    plugin.init(target, vars, tween);\n  };\n});\nconst CSSPlugin = {\n  name: "css",\n  register: _initCore,\n  targetTest(target) {\n    return target.style && target.nodeType;\n  },\n  init(target, vars, tween, index, targets) {\n    let props = this._props,\n      style = target.style,\n      startAt = tween.vars.startAt,\n      startValue,\n      endValue,\n      endNum,\n      startNum,\n      type,\n      specialProp,\n      p,\n      startUnit,\n      endUnit,\n      relative,\n      isTransformRelated,\n      transformPropTween,\n      cache,\n      smooth,\n      hasPriority;\n    _pluginInitted || _initCore();\n    for (p in vars) {\n      if (p === "autoRound") {\n        continue;\n      }\n      endValue = vars[p];\n      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {\n        // plugins\n        continue;\n      }\n      type = typeof endValue;\n      specialProp = _specialProps[p];\n      if (type === "function") {\n        endValue = endValue.call(tween, index, target, targets);\n        type = typeof endValue;\n      }\n      if (type === "string" && ~endValue.indexOf("random(")) {\n        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);\n      }\n      if (specialProp) {\n        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n      } else if (p.substr(0, 2) === "--") {\n        //CSS variable\n        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();\n        endValue += "";\n        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;\n        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {\n          // colors don\'t have units\n          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);\n          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);\n        }\n        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);\n      } else if (type !== "undefined") {\n        if (startAt && p in startAt) {\n          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it\'d use the computed value (always in px)\n          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n          p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue) && (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p]); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won\'t work.\n          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can\'t work with relative values\n        } else {\n          startValue = _get(target, p);\n        }\n        startNum = parseFloat(startValue);\n        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;\n        relative && (endValue = endValue.substr(2));\n        endNum = parseFloat(endValue);\n        if (p in _propertyAliases) {\n          if (p === "autoAlpha") {\n            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {\n              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)\n              startNum = 0;\n            }\n            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);\n          }\n          if (p !== "scale" && p !== "transform") {\n            p = _propertyAliases[p];\n            ~p.indexOf(",") && (p = p.split(",")[0]);\n          }\n        }\n        isTransformRelated = p in _transformProps;\n\n        //--- TRANSFORM-RELATED ---\n        if (isTransformRelated) {\n          if (!transformPropTween) {\n            cache = target._gsap;\n            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn\'t parse the transform, thus cache.renderTransform won\'t be set yet so force the parsing of the transform here.\n            smooth = vars.smoothOrigin !== false && cache.smooth;\n            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n          }\n          if (p === "scale") {\n            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, relative ? relative * endNum : endNum - cache.scaleY);\n            props.push("scaleY", p);\n            p += "X";\n          } else if (p === "transformOrigin") {\n            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.\n            if (cache.svg) {\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n            } else {\n              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!\n              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);\n              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n            }\n            continue;\n          } else if (p === "svgOrigin") {\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n            continue;\n          } else if (p in _rotationalProperties) {\n            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);\n            continue;\n          } else if (p === "smoothOrigin") {\n            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);\n            continue;\n          } else if (p === "force3D") {\n            cache[p] = endValue;\n            continue;\n          } else if (p === "transform") {\n            _addRawTransformPTs(this, endValue, target);\n            continue;\n          }\n        } else if (!(p in style)) {\n          p = _checkPropPrefix(p) || p;\n        }\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n          startUnit = (startValue + "").substr((startNum + "").length);\n          endNum || (endNum = 0); // protect against NaN\n          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);\n          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n          this._pt.u = endUnit || 0;\n          if (startUnit !== endUnit) {\n            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)\n            this._pt.b = startValue;\n            this._pt.r = _renderCSSPropWithBeginning;\n          }\n        } else if (!(p in style)) {\n          if (p in target) {\n            //maybe it\'s not a style - it could be a property added directly to an element in which case we\'ll try to animate that.\n            this.add(target, p, target[p], endValue, index, targets);\n          } else {\n            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);\n            continue;\n          }\n        } else {\n          _tweenComplexCSSString.call(this, target, p, startValue, endValue);\n        }\n        props.push(p);\n      }\n    }\n    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);\n  },\n  get: _get,\n  aliases: _propertyAliases,\n  getSetter(target, property, plugin) {\n    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren\'t as simple as target.style.property = value because they\'ve got to be applied to a proxy object and then merged into a transform string in a renderer.\n    let p = _propertyAliases[property];\n    p && p.indexOf(",") < 0 && (property = p);\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);\n  },\n  core: {\n    _removeProperty,\n    _getMatrix\n  }\n};\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;\n(function (positionAndScale, rotation, others, aliases) {\n  let all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, name => {\n    _transformProps[name] = 1;\n  });\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, name => {\n    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";\n    _rotationalProperties[name] = 1;\n  });\n  _propertyAliases[all[13]] = positionAndScale + "," + rotation;\n  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, name => {\n    let split = name.split(":");\n    _propertyAliases[split[1]] = all[split[0]];\n  });\n})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");\n(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", name => {\n  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";\n});\n_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/CSSPlugin.js?')},"./build/scripts/vendor/gsap/src/CSSRulePlugin.js":
/*!********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/CSSRulePlugin.js ***!
  \********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSRulePlugin: () => (/* binding */ CSSRulePlugin),\n/* harmony export */   "default": () => (/* binding */ CSSRulePlugin)\n/* harmony export */ });\n/*!\n * CSSRulePlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _win,\n  _doc,\n  CSSPlugin,\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _checkRegister = () => {\n    if (!_coreInitted) {\n      _initCore();\n      if (!CSSPlugin) {\n        console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)");\n      }\n    }\n    return _coreInitted;\n  },\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (_windowExists()) {\n      _win = window;\n      _doc = document;\n    }\n    if (gsap) {\n      CSSPlugin = gsap.plugins.css;\n      if (CSSPlugin) {\n        _coreInitted = 1;\n      }\n    }\n  };\nconst CSSRulePlugin = {\n  version: "3.6.1",\n  name: "cssRule",\n  init(target, value, tween, index, targets) {\n    if (!_checkRegister() || typeof target.cssText === "undefined") {\n      return false;\n    }\n    let div = target._gsProxy = target._gsProxy || _doc.createElement("div");\n    this.ss = target;\n    this.style = div.style;\n    div.style.cssText = target.cssText;\n    CSSPlugin.prototype.init.call(this, div, value, tween, index, targets); //we just offload all the work to the regular CSSPlugin and then copy the cssText back over to the rule in the render() method. This allows us to have all of the updates to CSSPlugin automatically flow through to CSSRulePlugin instead of having to maintain both\n  },\n  render(ratio, data) {\n    let pt = data._pt,\n      style = data.style,\n      ss = data.ss,\n      i;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n    i = style.length;\n    while (--i > -1) {\n      ss[style[i]] = style[style[i]];\n    }\n  },\n  getRule(selector) {\n    _checkRegister();\n    let ruleProp = _doc.all ? "rules" : "cssRules",\n      styleSheets = _doc.styleSheets,\n      i = styleSheets.length,\n      pseudo = selector.charAt(0) === ":",\n      j,\n      curSS,\n      cs,\n      a;\n    selector = (pseudo ? "" : ",") + selector.split("::").join(":").toLowerCase() + ","; //note: old versions of IE report tag name selectors as upper case, so we just change everything to lowercase.\n    if (pseudo) {\n      a = [];\n    }\n    while (i--) {\n      //Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.\n      try {\n        curSS = styleSheets[i][ruleProp];\n        if (!curSS) {\n          continue;\n        }\n        j = curSS.length;\n      } catch (e) {\n        console.warn(e);\n        continue;\n      }\n      while (--j > -1) {\n        cs = curSS[j];\n        if (cs.selectorText && ("," + cs.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(selector) !== -1) {\n          //note: IE adds an extra ":" to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.\n          if (pseudo) {\n            a.push(cs.style);\n          } else {\n            return cs.style;\n          }\n        }\n      }\n    }\n    return a;\n  },\n  register: _initCore\n};\n_getGSAP() && gsap.registerPlugin(CSSRulePlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/CSSRulePlugin.js?')},"./build/scripts/vendor/gsap/src/CustomBounce.js":
/*!*******************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/CustomBounce.js ***!
  \*******************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomBounce: () => (/* binding */ CustomBounce),\n/* harmony export */   "default": () => (/* binding */ CustomBounce)\n/* harmony export */ });\n/*!\n * CustomBounce 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  createCustomEase,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _initCore = required => {\n    gsap = _getGSAP();\n    createCustomEase = gsap && gsap.parseEase("_CE");\n    if (createCustomEase) {\n      _coreInitted = 1;\n      gsap.parseEase("bounce").config = vars => typeof vars === "object" ? _create("", vars) : _create("bounce(" + vars + ")", {\n        strength: +vars\n      });\n    } else {\n      required && console.warn("Please gsap.registerPlugin(CustomEase, CustomBounce)");\n    }\n  },\n  _normalizeX = a => {\n    //scales all the x values in an array [x, y, x, y...] AND rounds them to the closest hundredth (decimal)\n    let l = a.length,\n      s = 1 / a[l - 2],\n      rnd = 1000,\n      i;\n    for (i = 2; i < l; i += 2) {\n      a[i] = ~~(a[i] * s * rnd) / rnd;\n    }\n    a[l - 2] = 1; //in case there are any rounding errors. x should always end at 1.\n  },\n  _bonusValidated = 1,\n  //<name>CustomBounce</name>\n  _create = (id, vars) => {\n    if (!_coreInitted) {\n      _initCore(1);\n    }\n    vars = vars || {};\n    if (_bonusValidated) {\n      let max = 0.999,\n        decay = Math.min(max, vars.strength || 0.7),\n        // Math.min(0.999, 1 - 0.3 / (vars.strength || 1)),\n        decayX = decay,\n        gap = (vars.squash || 0) / 100,\n        originalGap = gap,\n        slope = 1 / 0.03,\n        w = 0.2,\n        h = 1,\n        prevX = 0.1,\n        path = [0, 0, 0.07, 0, 0.1, 1, 0.1, 1],\n        squashPath = [0, 0, 0, 0, 0.1, 0, 0.1, 0],\n        cp1,\n        cp2,\n        x,\n        y,\n        i,\n        nextX,\n        squishMagnitude;\n      for (i = 0; i < 200; i++) {\n        w *= decayX * ((decayX + 1) / 2);\n        h *= decay * decay;\n        nextX = prevX + w;\n        x = prevX + w * 0.49;\n        y = 1 - h;\n        cp1 = prevX + h / slope;\n        cp2 = x + (x - cp1) * 0.8;\n        if (gap) {\n          prevX += gap;\n          cp1 += gap;\n          x += gap;\n          cp2 += gap;\n          nextX += gap;\n          squishMagnitude = gap / originalGap;\n          squashPath.push(prevX - gap, 0, prevX - gap, squishMagnitude, prevX - gap / 2, squishMagnitude,\n          //center peak anchor\n          prevX, squishMagnitude, prevX, 0, prevX, 0,\n          //base anchor\n          prevX, squishMagnitude * -0.6, prevX + (nextX - prevX) / 6, 0, nextX, 0);\n          path.push(prevX - gap, 1, prevX, 1, prevX, 1);\n          gap *= decay * decay;\n        }\n        path.push(prevX, 1, cp1, y, x, y, cp2, y, nextX, 1, nextX, 1);\n        decay *= 0.95;\n        slope = h / (nextX - cp2);\n        prevX = nextX;\n        if (y > max) {\n          break;\n        }\n      }\n      if (vars.endAtStart && vars.endAtStart !== "false") {\n        x = -0.1;\n        path.unshift(x, 1, x, 1, -0.07, 0);\n        if (originalGap) {\n          gap = originalGap * 2.5; //make the initial anticipation squash longer (more realistic)\n          x -= gap;\n          path.unshift(x, 1, x, 1, x, 1);\n          squashPath.splice(0, 6);\n          squashPath.unshift(x, 0, x, 0, x, 1, x + gap / 2, 1, x + gap, 1, x + gap, 0, x + gap, 0, x + gap, -0.6, x + gap + 0.033, 0);\n          for (i = 0; i < squashPath.length; i += 2) {\n            squashPath[i] -= x;\n          }\n        }\n        for (i = 0; i < path.length; i += 2) {\n          path[i] -= x;\n          path[i + 1] = 1 - path[i + 1];\n        }\n      }\n      if (gap) {\n        _normalizeX(squashPath);\n        squashPath[2] = "C" + squashPath[2];\n        createCustomEase(vars.squashID || id + "-squash", "M" + squashPath.join(","));\n      }\n      _normalizeX(path);\n      path[2] = "C" + path[2];\n      return createCustomEase(id, "M" + path.join(","));\n    }\n  };\nclass CustomBounce {\n  constructor(id, vars) {\n    this.ease = _create(id, vars);\n  }\n  static create(id, vars) {\n    return _create(id, vars);\n  }\n  static register(core) {\n    gsap = core;\n    _initCore();\n  }\n}\n_getGSAP() && gsap.registerPlugin(CustomBounce);\nCustomBounce.version = "3.6.1";\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/CustomBounce.js?')},"./build/scripts/vendor/gsap/src/CustomEase.js":
/*!*****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/CustomEase.js ***!
  \*****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomEase: () => (/* binding */ CustomEase),\n/* harmony export */   "default": () => (/* binding */ CustomEase)\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ "./build/scripts/vendor/gsap/src/utils/paths.js");\n/*!\n * CustomEase 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet gsap,\n  _coreInitted,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _initCore = () => {\n    gsap = _getGSAP();\n    if (gsap) {\n      gsap.registerEase("_CE", CustomEase.create);\n      _coreInitted = 1;\n    } else {\n      console.warn("Please gsap.registerPlugin(CustomEase)");\n    }\n  },\n  _bigNum = 1e20,\n  _round = value => ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000,\n  _bonusValidated = 1,\n  //<name>CustomEase</name>\n  _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n  _needsParsingExp = /[cLlsSaAhHvVtTqQ]/g,\n  _findMinimum = values => {\n    let l = values.length,\n      min = _bigNum,\n      i;\n    for (i = 1; i < l; i += 6) {\n      +values[i] < min && (min = +values[i]);\n    }\n    return min;\n  },\n  //takes all the points and translates/scales them so that the x starts at 0 and ends at 1.\n  _normalize = (values, height, originY) => {\n    if (!originY && originY !== 0) {\n      originY = Math.max(+values[values.length - 1], +values[1]);\n    }\n    let tx = +values[0] * -1,\n      ty = -originY,\n      l = values.length,\n      sx = 1 / (+values[l - 2] + tx),\n      sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty),\n      i;\n    if (sy) {\n      //typically y ends at 1 (so that the end values are reached)\n      sy = 1 / sy;\n    } else {\n      //in case the ease returns to its beginning value, scale everything proportionally\n      sy = -sx;\n    }\n    for (i = 0; i < l; i += 2) {\n      values[i] = (+values[i] + tx) * sx;\n      values[i + 1] = (+values[i + 1] + ty) * sy;\n    }\n  },\n  //note that this function returns point objects like {x, y} rather than working with segments which are arrays with alternating x, y values as in the similar function in paths.js\n  _bezierToPoints = function (x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n    let x12 = (x1 + x2) / 2,\n      y12 = (y1 + y2) / 2,\n      x23 = (x2 + x3) / 2,\n      y23 = (y2 + y3) / 2,\n      x34 = (x3 + x4) / 2,\n      y34 = (y3 + y4) / 2,\n      x123 = (x12 + x23) / 2,\n      y123 = (y12 + y23) / 2,\n      x234 = (x23 + x34) / 2,\n      y234 = (y23 + y34) / 2,\n      x1234 = (x123 + x234) / 2,\n      y1234 = (y123 + y234) / 2,\n      dx = x4 - x1,\n      dy = y4 - y1,\n      d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),\n      d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),\n      length;\n    if (!points) {\n      points = [{\n        x: x1,\n        y: y1\n      }, {\n        x: x4,\n        y: y4\n      }];\n      index = 1;\n    }\n    points.splice(index || points.length - 1, 0, {\n      x: x1234,\n      y: y1234\n    });\n    if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n      length = points.length;\n      _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n      _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));\n    }\n    return points;\n  };\nclass CustomEase {\n  constructor(id, data, config) {\n    _coreInitted || _initCore();\n    this.id = id;\n    _bonusValidated && this.setData(data, config);\n  }\n  setData(data, config) {\n    config = config || {};\n    data = data || "0,0,1,1";\n    let values = data.match(_numExp),\n      closest = 1,\n      points = [],\n      lookup = [],\n      precision = config.precision || 1,\n      fast = precision <= 1,\n      l,\n      a1,\n      a2,\n      i,\n      inc,\n      j,\n      point,\n      prevPoint,\n      p;\n    this.data = data;\n    if (_needsParsingExp.test(data) || ~data.indexOf("M") && data.indexOf("C") < 0) {\n      values = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(data)[0];\n    }\n    l = values.length;\n    if (l === 4) {\n      values.unshift(0, 0);\n      values.push(1, 1);\n      l = 8;\n    } else if ((l - 2) % 6) {\n      throw "Invalid CustomEase";\n    }\n    if (+values[0] !== 0 || +values[l - 2] !== 1) {\n      _normalize(values, config.height, config.originY);\n    }\n    this.segment = values;\n    for (i = 2; i < l; i += 6) {\n      a1 = {\n        x: +values[i - 2],\n        y: +values[i - 1]\n      };\n      a2 = {\n        x: +values[i + 4],\n        y: +values[i + 5]\n      };\n      points.push(a1, a2);\n      _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);\n    }\n    l = points.length;\n    for (i = 0; i < l; i++) {\n      point = points[i];\n      prevPoint = points[i - 1] || point;\n      if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {\n        //if a point goes BACKWARD in time or is a duplicate, just drop it. Also it shouldn\'t go past 1 on the x axis, as could happen in a string like "M0,0 C0,0 0.12,0.68 0.18,0.788 0.195,0.845 0.308,1 0.32,1 0.403,1.005 0.398,1 0.5,1 0.602,1 0.816,1.005 0.9,1 0.91,1 0.948,0.69 0.962,0.615 1.003,0.376 1,0 1,0".\n        prevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)\n        prevPoint.cy = point.y - prevPoint.y;\n        prevPoint.n = point;\n        prevPoint.nx = point.x; //next point\'s x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it\'s either this point or the very next one (never beyond that)\n        if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {\n          //if there\'s a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don\'t want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.\n          fast = 0;\n        }\n        if (prevPoint.cx < closest) {\n          if (!prevPoint.cx) {\n            prevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)\n            if (i === l - 1) {\n              //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.\n              prevPoint.x -= 0.001;\n              closest = Math.min(closest, 0.001);\n              fast = 0;\n            }\n          } else {\n            closest = prevPoint.cx;\n          }\n        }\n      } else {\n        points.splice(i--, 1);\n        l--;\n      }\n    }\n    l = 1 / closest + 1 | 0;\n    inc = 1 / l;\n    j = 0;\n    point = points[0];\n    if (fast) {\n      for (i = 0; i < l; i++) {\n        //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don\'t land on the sampling points, but for the vast majority of eases it\'s excellent (and fast).\n        p = i * inc;\n        if (point.nx < p) {\n          point = points[++j];\n        }\n        a1 = point.y + (p - point.x) / point.cx * point.cy;\n        lookup[i] = {\n          x: p,\n          cx: inc,\n          y: a1,\n          cy: 0,\n          nx: 9\n        };\n        if (i) {\n          lookup[i - 1].cy = a1 - lookup[i - 1].y;\n        }\n      }\n      lookup[l - 1].cy = points[points.length - 1].y - a1;\n    } else {\n      //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.\n      for (i = 0; i < l; i++) {\n        //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it\'ll either be that point or the very next one). We\'ll look up based on the linear progress. So it\'s it\'s 0.5 and the lookup table has 100 elements, it\'d be like lookup[Math.floor(0.5 * 100)]\n        if (point.nx < i * inc) {\n          point = points[++j];\n        }\n        lookup[i] = point;\n      }\n      if (j < points.length - 1) {\n        lookup[i - 1] = points[points.length - 2];\n      }\n    }\n    //this._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don\'t run into floating point errors. As long as we\'re starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.\n\n    this.ease = p => {\n      let point = lookup[p * l | 0] || lookup[l - 1];\n      if (point.nx < p) {\n        point = point.n;\n      }\n      return point.y + (p - point.x) / point.cx * point.cy;\n    };\n    this.ease.custom = this;\n    this.id && gsap.registerEase(this.id, this.ease);\n    return this;\n  }\n  getSVGData(config) {\n    return CustomEase.getSVGData(this, config);\n  }\n  static create(id, data, config) {\n    return new CustomEase(id, data, config).ease;\n  }\n  static register(core) {\n    gsap = core;\n    _initCore();\n  }\n  static get(id) {\n    return gsap.parseEase(id);\n  }\n  static getSVGData(ease, config) {\n    config = config || {};\n    let width = config.width || 100,\n      height = config.height || 100,\n      x = config.x || 0,\n      y = (config.y || 0) + height,\n      e = gsap.utils.toArray(config.path)[0],\n      a,\n      slope,\n      i,\n      inc,\n      tx,\n      ty,\n      precision,\n      threshold,\n      prevX,\n      prevY;\n    if (config.invert) {\n      height = -height;\n      y = 0;\n    }\n    if (typeof ease === "string") {\n      ease = gsap.parseEase(ease);\n    }\n    if (ease.custom) {\n      ease = ease.custom;\n    }\n    if (ease instanceof CustomEase) {\n      a = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)([ease.segment], width, 0, 0, -height, x, y));\n    } else {\n      a = [x, y];\n      precision = Math.max(5, (config.precision || 1) * 200);\n      inc = 1 / precision;\n      precision += 2;\n      threshold = 5 / precision;\n      prevX = _round(x + inc * width);\n      prevY = _round(y + ease(inc) * -height);\n      slope = (prevY - y) / (prevX - x);\n      for (i = 2; i < precision; i++) {\n        tx = _round(x + i * inc * width);\n        ty = _round(y + ease(i * inc) * -height);\n        if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {\n          //only add points when the slope changes beyond the threshold\n          a.push(prevX, prevY);\n          slope = (ty - prevY) / (tx - prevX);\n        }\n        prevX = tx;\n        prevY = ty;\n      }\n      a = "M" + a.join(",");\n    }\n    e && e.setAttribute("d", a);\n    return a;\n  }\n}\n_getGSAP() && gsap.registerPlugin(CustomEase);\nCustomEase.version = "3.6.1";\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/CustomEase.js?')},"./build/scripts/vendor/gsap/src/CustomWiggle.js":
/*!*******************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/CustomWiggle.js ***!
  \*******************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomWiggle: () => (/* binding */ CustomWiggle),\n/* harmony export */   "default": () => (/* binding */ CustomWiggle)\n/* harmony export */ });\n/*!\n * CustomWiggle 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  createCustomEase,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _eases = {\n    easeOut: "M0,1,C0.7,1,0.6,0,1,0",\n    easeInOut: "M0,0,C0.1,0,0.24,1,0.444,1,0.644,1,0.6,0,1,0",\n    anticipate: "M0,0,C0,0.222,0.024,0.386,0,0.4,0.18,0.455,0.65,0.646,0.7,0.67,0.9,0.76,1,0.846,1,1",\n    uniform: "M0,0,C0,0.95,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0"\n  },\n  _linearEase = p => p,\n  _initCore = required => {\n    if (!_coreInitted) {\n      gsap = _getGSAP();\n      createCustomEase = gsap && gsap.parseEase("_CE");\n      if (createCustomEase) {\n        for (let p in _eases) {\n          _eases[p] = createCustomEase("", _eases[p]);\n        }\n        _coreInitted = 1;\n        _create("wiggle").config = vars => typeof vars === "object" ? _create("", vars) : _create("wiggle(" + vars + ")", {\n          wiggles: +vars\n        });\n      } else {\n        required && console.warn("Please gsap.registerPlugin(CustomEase, CustomWiggle)");\n      }\n    }\n  },\n  _parseEase = (ease, invertNonCustomEases) => {\n    if (typeof ease !== "function") {\n      ease = gsap.parseEase(ease) || createCustomEase("", ease);\n    }\n    return ease.custom || !invertNonCustomEases ? ease : p => 1 - ease(p);\n  },\n  _bonusValidated = 1,\n  //<name>CustomWiggle</name>\n  _create = (id, vars) => {\n    if (!_coreInitted) {\n      _initCore(1);\n    }\n    vars = vars || {};\n    let wiggles = (vars.wiggles || 10) | 0,\n      inc = 1 / wiggles,\n      x = inc / 2,\n      anticipate = vars.type === "anticipate",\n      yEase = _eases[vars.type] || _eases.easeOut,\n      xEase = _linearEase,\n      rnd = 1000,\n      nextX,\n      nextY,\n      angle,\n      handleX,\n      handleY,\n      easedX,\n      y,\n      path,\n      i;\n    if (_bonusValidated) {\n      if (anticipate) {\n        //the anticipate ease is actually applied on the x-axis (timing) and uses easeOut for amplitude.\n        xEase = yEase;\n        yEase = _eases.easeOut;\n      }\n      if (vars.timingEase) {\n        xEase = _parseEase(vars.timingEase);\n      }\n      if (vars.amplitudeEase) {\n        yEase = _parseEase(vars.amplitudeEase, true);\n      }\n      easedX = xEase(x);\n      y = anticipate ? -yEase(x) : yEase(x);\n      path = [0, 0, easedX / 4, 0, easedX / 2, y, easedX, y];\n      if (vars.type === "random") {\n        //if we just select random values on the y-axis and plug them into the "normal" algorithm, since the control points are always straight horizontal, it creates a bit of a slowdown at each anchor which just didn\'t seem as desirable, so we switched to an algorithm that bends the control points to be more in line with their context.\n        path.length = 4;\n        nextX = xEase(inc);\n        nextY = Math.random() * 2 - 1;\n        for (i = 2; i < wiggles; i++) {\n          x = nextX;\n          y = nextY;\n          nextX = xEase(inc * i);\n          nextY = Math.random() * 2 - 1;\n          angle = Math.atan2(nextY - path[path.length - 3], nextX - path[path.length - 4]);\n          handleX = Math.cos(angle) * inc;\n          handleY = Math.sin(angle) * inc;\n          path.push(x - handleX, y - handleY, x, y, x + handleX, y + handleY);\n        }\n        path.push(nextX, 0, 1, 0);\n      } else {\n        for (i = 1; i < wiggles; i++) {\n          path.push(xEase(x + inc / 2), y);\n          x += inc;\n          y = (y > 0 ? -1 : 1) * yEase(i * inc);\n          easedX = xEase(x);\n          path.push(xEase(x - inc / 2), y, easedX, y);\n        }\n        path.push(xEase(x + inc / 4), y, xEase(x + inc / 4), 0, 1, 0);\n      }\n      i = path.length;\n      while (--i > -1) {\n        path[i] = ~~(path[i] * rnd) / rnd; //round values to avoid odd strings for super tiny values\n      }\n      path[2] = "C" + path[2];\n      return createCustomEase(id, "M" + path.join(","));\n    }\n  };\nclass CustomWiggle {\n  constructor(id, vars) {\n    this.ease = _create(id, vars);\n  }\n  static create(id, vars) {\n    return _create(id, vars);\n  }\n  static register(core) {\n    gsap = core;\n    _initCore();\n  }\n}\n_getGSAP() && gsap.registerPlugin(CustomWiggle);\nCustomWiggle.version = "3.6.1";\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/CustomWiggle.js?')},"./build/scripts/vendor/gsap/src/Draggable.js":
/*!****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/Draggable.js ***!
  \****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   "default": () => (/* binding */ Draggable)\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ "./build/scripts/vendor/gsap/src/utils/matrix.js");\n/*!\n * Draggable 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n */\n/* eslint-disable */\n\n\nlet gsap,\n  _win,\n  _doc,\n  _docElement,\n  _body,\n  _tempDiv,\n  _placeholderDiv,\n  _coreInitted,\n  _checkPrefix,\n  _toArray,\n  _supportsPassive,\n  _isTouchDevice,\n  _touchEventLookup,\n  _dragCount,\n  _isMultiTouching,\n  _isAndroid,\n  InertiaPlugin,\n  _defaultCursor,\n  _supportsPointer,\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isFunction = value => typeof value === "function",\n  _isObject = value => typeof value === "object",\n  _isUndefined = value => typeof value === "undefined",\n  _emptyFunc = () => false,\n  _transformProp = "transform",\n  _transformOriginProp = "transformOrigin",\n  _round = value => Math.round(value * 10000) / 10000,\n  _isArray = Array.isArray,\n  _createElement = (type, ns) => {\n    let e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.\n    return e.style ? e : _doc.createElement(type); //some environments won\'t allow access to the element\'s style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won\'t allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n  },\n  _RAD2DEG = 180 / Math.PI,\n  _bigNum = 1e20,\n  _identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(),\n  _getTime = Date.now || (() => new Date().getTime()),\n  _renderQueue = [],\n  _lookup = {},\n  //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.\n  _lookupCount = 0,\n  _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,\n  _lastDragTime = 0,\n  _temp1 = {},\n  // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.\n  _windowProxy = {},\n  //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.\n  _copy = (obj, factor) => {\n    let copy = {},\n      p;\n    for (p in obj) {\n      copy[p] = factor ? obj[p] * factor : obj[p];\n    }\n    return copy;\n  },\n  _extend = (obj, defaults) => {\n    for (let p in defaults) {\n      if (!(p in obj)) {\n        obj[p] = defaults[p];\n      }\n    }\n    return obj;\n  },\n  _setTouchActionForAllDescendants = (elements, value) => {\n    let i = elements.length,\n      children;\n    while (i--) {\n      value ? elements[i].style.touchAction = value : elements[i].style.removeProperty("touch-action");\n      children = elements[i].children;\n      children && children.length && _setTouchActionForAllDescendants(children, value);\n    }\n  },\n  _renderQueueTick = () => _renderQueue.forEach(func => func()),\n  _addToRenderQueue = func => {\n    _renderQueue.push(func);\n    if (_renderQueue.length === 1) {\n      gsap.ticker.add(_renderQueueTick);\n    }\n  },\n  _renderQueueTimeout = () => !_renderQueue.length && gsap.ticker.remove(_renderQueueTick),\n  _removeFromRenderQueue = func => {\n    let i = _renderQueue.length;\n    while (i--) {\n      if (_renderQueue[i] === func) {\n        _renderQueue.splice(i, 1);\n      }\n    }\n    gsap.to(_renderQueueTimeout, {\n      overwrite: true,\n      delay: 15,\n      duration: 0,\n      onComplete: _renderQueueTimeout,\n      data: "_draggable"\n    }); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn\'t deliver optimal speed, and we also don\'t want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).\n  },\n  _setDefaults = (obj, defaults) => {\n    for (let p in defaults) {\n      if (!(p in obj)) {\n        obj[p] = defaults[p];\n      }\n    }\n    return obj;\n  },\n  _addListener = (element, type, func, capture) => {\n    if (element.addEventListener) {\n      let touchType = _touchEventLookup[type];\n      capture = capture || (_supportsPassive ? {\n        passive: false\n      } : null);\n      element.addEventListener(touchType || type, func, capture);\n      touchType && type !== touchType && element.addEventListener(type, func, capture); //some browsers actually support both, so must we. But pointer events cover all.\n    }\n  },\n  _removeListener = (element, type, func) => {\n    if (element.removeEventListener) {\n      let touchType = _touchEventLookup[type];\n      element.removeEventListener(touchType || type, func);\n      touchType && type !== touchType && element.removeEventListener(type, func);\n    }\n  },\n  _preventDefault = event => {\n    event.preventDefault && event.preventDefault();\n    event.preventManipulation && event.preventManipulation(); //for some Microsoft browsers\n  },\n  _hasTouchID = (list, ID) => {\n    let i = list.length;\n    while (i--) {\n      if (list[i].identifier === ID) {\n        return true;\n      }\n    }\n  },\n  _onMultiTouchDocumentEnd = event => {\n    _isMultiTouching = event.touches && _dragCount < event.touches.length;\n    _removeListener(event.target, "touchend", _onMultiTouchDocumentEnd);\n  },\n  _onMultiTouchDocument = event => {\n    _isMultiTouching = event.touches && _dragCount < event.touches.length;\n    _addListener(event.target, "touchend", _onMultiTouchDocumentEnd);\n  },\n  _getDocScrollTop = doc => _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0,\n  _getDocScrollLeft = doc => _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0,\n  _addScrollListener = (e, callback) => {\n    _addListener(e, "scroll", callback);\n    if (!_isRoot(e.parentNode)) {\n      _addScrollListener(e.parentNode, callback);\n    }\n  },\n  _removeScrollListener = (e, callback) => {\n    _removeListener(e, "scroll", callback);\n    if (!_isRoot(e.parentNode)) {\n      _removeScrollListener(e.parentNode, callback);\n    }\n  },\n  _isRoot = e => !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode),\n  _getMaxScroll = (element, axis) => {\n    let dim = axis === "x" ? "Width" : "Height",\n      scroll = "scroll" + dim,\n      client = "client" + dim;\n    return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win["inner" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);\n  },\n  _recordMaxScrolls = (e, skipCurrent) => {\n    //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.\n    let x = _getMaxScroll(e, "x"),\n      y = _getMaxScroll(e, "y");\n    if (_isRoot(e)) {\n      e = _windowProxy;\n    } else {\n      _recordMaxScrolls(e.parentNode, skipCurrent);\n    }\n    e._gsMaxScrollX = x;\n    e._gsMaxScrollY = y;\n    if (!skipCurrent) {\n      e._gsScrollX = e.scrollLeft || 0;\n      e._gsScrollY = e.scrollTop || 0;\n    }\n  },\n  _setStyle = (element, property, value) => {\n    let style = element.style;\n    if (!style) {\n      return;\n    }\n    if (_isUndefined(style[property])) {\n      property = _checkPrefix(property, element) || property;\n    }\n    if (value == null) {\n      style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());\n    } else {\n      style[property] = value;\n    }\n  },\n  _getComputedStyle = element => _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element),\n  //the "host" stuff helps to accommodate ShadowDom objects.\n\n  _tempRect = {},\n  //reuse to reduce garbage collection tasks\n  _parseRect = e => {\n    //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties\n    if (e === _win) {\n      _tempRect.left = _tempRect.top = 0;\n      _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;\n      _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;\n      return _tempRect;\n    }\n    let doc = e.ownerDocument || _doc,\n      r = !_isUndefined(e.pageX) ? {\n        left: e.pageX - _getDocScrollLeft(doc),\n        top: e.pageY - _getDocScrollTop(doc),\n        right: e.pageX - _getDocScrollLeft(doc) + 1,\n        bottom: e.pageY - _getDocScrollTop(doc) + 1\n      } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();\n    if (_isUndefined(r.right) && !_isUndefined(r.width)) {\n      r.right = r.left + r.width;\n      r.bottom = r.top + r.height;\n    } else if (_isUndefined(r.width)) {\n      //some browsers don\'t include width and height properties. We can\'t just set them directly on r because some browsers throw errors, so create a new generic object.\n      r = {\n        width: r.right - r.left,\n        height: r.bottom - r.top,\n        right: r.right,\n        left: r.left,\n        bottom: r.bottom,\n        top: r.top\n      };\n    }\n    return r;\n  },\n  _dispatchEvent = (target, type, callbackName) => {\n    let vars = target.vars,\n      callback = vars[callbackName],\n      listeners = target._listeners[type],\n      result;\n    if (_isFunction(callback)) {\n      result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);\n    }\n    if (listeners && target.dispatchEvent(type) === false) {\n      result = false;\n    }\n    return result;\n  },\n  _getBounds = (target, context) => {\n    //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.\n    let e = _toArray(target)[0],\n      top,\n      left,\n      offset;\n    if (!e.nodeType && e !== _win) {\n      if (!_isUndefined(target.left)) {\n        offset = {\n          x: 0,\n          y: 0\n        }; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin\n        return {\n          left: target.left - offset.x,\n          top: target.top - offset.y,\n          width: target.width,\n          height: target.height\n        };\n      }\n      left = target.min || target.minX || target.minRotation || 0;\n      top = target.min || target.minY || 0;\n      return {\n        left: left,\n        top: top,\n        width: (target.max || target.maxX || target.maxRotation || 0) - left,\n        height: (target.max || target.maxY || 0) - top\n      };\n    }\n    return _getElementBounds(e, context);\n  },\n  _point1 = {},\n  //we reuse to minimize garbage collection tasks.\n  _getElementBounds = (element, context) => {\n    context = _toArray(context)[0];\n    let isSVG = element.getBBox && element.ownerSVGElement,\n      doc = element.ownerDocument || _doc,\n      left,\n      right,\n      top,\n      bottom,\n      matrix,\n      p1,\n      p2,\n      p3,\n      p4,\n      bbox,\n      width,\n      height,\n      cs,\n      contextParent;\n    if (element === _win) {\n      top = _getDocScrollTop(doc);\n      left = _getDocScrollLeft(doc);\n      right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);\n      bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.\n    } else if (context === _win || _isUndefined(context)) {\n      return element.getBoundingClientRect();\n    } else {\n      left = top = 0;\n      if (isSVG) {\n        bbox = element.getBBox();\n        width = bbox.width;\n        height = bbox.height;\n      } else {\n        if (element.viewBox && (bbox = element.viewBox.baseVal)) {\n          left = bbox.x || 0;\n          top = bbox.y || 0;\n          width = bbox.width;\n          height = bbox.height;\n        }\n        if (!width) {\n          cs = _getComputedStyle(element);\n          bbox = cs.boxSizing === "border-box";\n          width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));\n          height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));\n        }\n      }\n      right = width;\n      bottom = height;\n    }\n    if (element === context) {\n      return {\n        left: left,\n        top: top,\n        width: right - left,\n        height: bottom - top\n      };\n    }\n    matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element));\n    p1 = matrix.apply({\n      x: left,\n      y: top\n    });\n    p2 = matrix.apply({\n      x: right,\n      y: top\n    });\n    p3 = matrix.apply({\n      x: right,\n      y: bottom\n    });\n    p4 = matrix.apply({\n      x: left,\n      y: bottom\n    });\n    left = Math.min(p1.x, p2.x, p3.x, p4.x);\n    top = Math.min(p1.y, p2.y, p3.y, p4.y);\n    contextParent = context.parentNode || {};\n    return {\n      left: left + (contextParent.scrollLeft || 0),\n      top: top + (contextParent.scrollTop || 0),\n      width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,\n      height: Math.max(p1.y, p2.y, p3.y, p4.y) - top\n    };\n  },\n  _parseInertia = (draggable, snap, max, min, factor, forceZeroVelocity) => {\n    let vars = {},\n      a,\n      i,\n      l;\n    if (snap) {\n      if (factor !== 1 && snap instanceof Array) {\n        //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.\n        vars.end = a = [];\n        l = snap.length;\n        if (_isObject(snap[0])) {\n          //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we\'ll mess up the originals and the user may reuse it elsewhere.\n          for (i = 0; i < l; i++) {\n            a[i] = _copy(snap[i], factor);\n          }\n        } else {\n          for (i = 0; i < l; i++) {\n            a[i] = snap[i] * factor;\n          }\n        }\n        max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$(\'#menu\').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.\n        min -= 1.1;\n      } else if (_isFunction(snap)) {\n        vars.end = value => {\n          let result = snap.call(draggable, value),\n            copy,\n            p;\n          if (factor !== 1) {\n            if (_isObject(result)) {\n              copy = {};\n              for (p in result) {\n                copy[p] = result[p] * factor;\n              }\n              result = copy;\n            } else {\n              result *= factor;\n            }\n          }\n          return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.\n        };\n      } else {\n        vars.end = snap;\n      }\n    }\n    if (max || max === 0) {\n      vars.max = max;\n    }\n    if (min || min === 0) {\n      vars.min = min;\n    }\n    if (forceZeroVelocity) {\n      vars.velocity = 0;\n    }\n    return vars;\n  },\n  _isClickable = element => {\n    //sometimes it\'s convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won\'t preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).\n    let data;\n    return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute("data-clickable")) === "true" || data !== "false" && (element.onclick || _clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true") ? true : _isClickable(element.parentNode);\n  },\n  _setSelectable = (elements, selectable) => {\n    let i = elements.length,\n      e;\n    while (i--) {\n      e = elements[i];\n      e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;\n      gsap.set(e, {\n        lazy: true,\n        userSelect: selectable ? "text" : "none"\n      });\n    }\n  },\n  _isFixed = element => {\n    if (_getComputedStyle(element).position === "fixed") {\n      return true;\n    }\n    element = element.parentNode;\n    if (element && element.nodeType === 1) {\n      // avoid document fragments which will throw an error.\n      return _isFixed(element);\n    }\n  },\n  _supports3D,\n  _addPaddingBR,\n  //The ScrollProxy class wraps an element\'s contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it\'ll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn\'t work - it\'d look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it\'ll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.\n  ScrollProxy = function (element, vars) {\n    element = gsap.utils.toArray(element)[0];\n    vars = vars || {};\n    let content = document.createElement("div"),\n      style = content.style,\n      node = element.firstChild,\n      offsetTop = 0,\n      offsetLeft = 0,\n      prevTop = element.scrollTop,\n      prevLeft = element.scrollLeft,\n      scrollWidth = element.scrollWidth,\n      scrollHeight = element.scrollHeight,\n      extraPadRight = 0,\n      maxLeft = 0,\n      maxTop = 0,\n      elementWidth,\n      elementHeight,\n      contentHeight,\n      nextNode,\n      transformStart,\n      transformEnd;\n    if (_supports3D && vars.force3D !== false) {\n      transformStart = "translate3d(";\n      transformEnd = "px,0px)";\n    } else if (_transformProp) {\n      transformStart = "translate(";\n      transformEnd = "px)";\n    }\n    this.scrollTop = function (value, force) {\n      if (!arguments.length) {\n        return -this.top();\n      }\n      this.top(-value, force);\n    };\n    this.scrollLeft = function (value, force) {\n      if (!arguments.length) {\n        return -this.left();\n      }\n      this.left(-value, force);\n    };\n    this.left = function (value, force) {\n      if (!arguments.length) {\n        return -(element.scrollLeft + offsetLeft);\n      }\n      let dif = element.scrollLeft - prevLeft,\n        oldOffset = offsetLeft;\n      if ((dif > 2 || dif < -2) && !force) {\n        //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n        prevLeft = element.scrollLeft;\n        gsap.killTweensOf(this, {\n          left: 1,\n          scrollLeft: 1\n        });\n        this.left(-prevLeft);\n        if (vars.onKill) {\n          vars.onKill();\n        }\n        return;\n      }\n      value = -value; //invert because scrolling works in the opposite direction\n      if (value < 0) {\n        offsetLeft = value - 0.5 | 0;\n        value = 0;\n      } else if (value > maxLeft) {\n        offsetLeft = value - maxLeft | 0;\n        value = maxLeft;\n      } else {\n        offsetLeft = 0;\n      }\n      if (offsetLeft || oldOffset) {\n        if (!this._skip) {\n          style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;\n        }\n        if (offsetLeft + extraPadRight >= 0) {\n          style.paddingRight = offsetLeft + extraPadRight + "px";\n        }\n      }\n      element.scrollLeft = value | 0;\n      prevLeft = element.scrollLeft; //don\'t merge this with the line above because some browsers adjust the scrollLeft after it\'s set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.\n    };\n    this.top = function (value, force) {\n      if (!arguments.length) {\n        return -(element.scrollTop + offsetTop);\n      }\n      let dif = element.scrollTop - prevTop,\n        oldOffset = offsetTop;\n      if ((dif > 2 || dif < -2) && !force) {\n        //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.\n        prevTop = element.scrollTop;\n        gsap.killTweensOf(this, {\n          top: 1,\n          scrollTop: 1\n        });\n        this.top(-prevTop);\n        if (vars.onKill) {\n          vars.onKill();\n        }\n        return;\n      }\n      value = -value; //invert because scrolling works in the opposite direction\n      if (value < 0) {\n        offsetTop = value - 0.5 | 0;\n        value = 0;\n      } else if (value > maxTop) {\n        offsetTop = value - maxTop | 0;\n        value = maxTop;\n      } else {\n        offsetTop = 0;\n      }\n      if (offsetTop || oldOffset) {\n        if (!this._skip) {\n          style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;\n        }\n      }\n      element.scrollTop = value | 0;\n      prevTop = element.scrollTop;\n    };\n    this.maxScrollTop = () => maxTop;\n    this.maxScrollLeft = () => maxLeft;\n    this.disable = function () {\n      node = content.firstChild;\n      while (node) {\n        nextNode = node.nextSibling;\n        element.appendChild(node);\n        node = nextNode;\n      }\n      if (element === content.parentNode) {\n        //in case disable() is called when it\'s already disabled.\n        element.removeChild(content);\n      }\n    };\n    this.enable = function () {\n      node = element.firstChild;\n      if (node === content) {\n        return;\n      }\n      while (node) {\n        nextNode = node.nextSibling;\n        content.appendChild(node);\n        node = nextNode;\n      }\n      element.appendChild(content);\n      this.calibrate();\n    };\n    this.calibrate = function (force) {\n      let widthMatches = element.clientWidth === elementWidth,\n        cs,\n        x,\n        y;\n      prevTop = element.scrollTop;\n      prevLeft = element.scrollLeft;\n      if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {\n        return; //no need to recalculate things if the width and height haven\'t changed.\n      }\n      if (offsetTop || offsetLeft) {\n        x = this.left();\n        y = this.top();\n        this.left(-element.scrollLeft);\n        this.top(-element.scrollTop);\n      }\n      cs = _getComputedStyle(element);\n      //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it\'s wider than the containing element. If so, we\'ve got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don\'t flow the content correctly)\n      if (!widthMatches || force) {\n        style.display = "block";\n        style.width = "auto";\n        style.paddingRight = "0px";\n        extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);\n        //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.\n        if (extraPadRight) {\n          extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);\n        }\n      }\n      style.display = "inline-block";\n      style.position = "relative";\n      style.overflow = "visible";\n      style.verticalAlign = "top";\n      style.boxSizing = "content-box";\n      style.width = "100%";\n      style.paddingRight = extraPadRight + "px";\n      //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error\n      if (_addPaddingBR) {\n        style.paddingBottom = cs.paddingBottom;\n      }\n      elementWidth = element.clientWidth;\n      elementHeight = element.clientHeight;\n      scrollWidth = element.scrollWidth;\n      scrollHeight = element.scrollHeight;\n      maxLeft = element.scrollWidth - elementWidth;\n      maxTop = element.scrollHeight - elementHeight;\n      contentHeight = content.offsetHeight;\n      style.display = "block";\n      if (x || y) {\n        this.left(x);\n        this.top(y);\n      }\n    };\n    this.content = content;\n    this.element = element;\n    this._skip = false;\n    this.enable();\n  },\n  _initCore = required => {\n    if (_windowExists() && document.body) {\n      let nav = window && window.navigator;\n      _win = window;\n      _doc = document;\n      _docElement = _doc.documentElement;\n      _body = _doc.body;\n      _tempDiv = _createElement("div");\n      _supportsPointer = !!window.PointerEvent;\n      _placeholderDiv = _createElement("div");\n      _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";\n      _defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";\n      _isAndroid = nav && nav.userAgent.toLowerCase().indexOf("android") !== -1; //Android handles touch events in an odd way and it\'s virtually impossible to "feature test" so we resort to UA sniffing\n      _isTouchDevice = "ontouchstart" in _docElement && "orientation" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);\n      _addPaddingBR = function () {\n        //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn\'t normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it\'s a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).\n        let div = _createElement("div"),\n          child = _createElement("div"),\n          childStyle = child.style,\n          parent = _body,\n          val;\n        childStyle.display = "inline-block";\n        childStyle.position = "relative";\n        div.style.cssText = child.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";\n        div.appendChild(child);\n        parent.appendChild(div);\n        val = child.offsetHeight + 18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.\n        parent.removeChild(div);\n        return val;\n      }();\n      _touchEventLookup = function (types) {\n        //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we\'re in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.\n        let standard = types.split(","),\n          converted = ("onpointerdown" in _tempDiv ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in _tempDiv ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),\n          obj = {},\n          i = 4;\n        while (--i > -1) {\n          obj[standard[i]] = converted[i];\n          obj[converted[i]] = standard[i];\n        }\n        //to avoid problems in iOS 9, test to see if the browser supports the "passive" option on addEventListener().\n        try {\n          _docElement.addEventListener("test", null, Object.defineProperty({}, "passive", {\n            get: function () {\n              _supportsPassive = 1;\n            }\n          }));\n        } catch (e) {}\n        return obj;\n      }("touchstart,touchmove,touchend,touchcancel");\n      _addListener(_doc, "touchcancel", _emptyFunc); //some older Android devices intermittently stop dispatching "touchmove" events if we don\'t listen for "touchcancel" on the document. Very strange indeed.\n      _addListener(_win, "touchmove", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.\n      _body && _body.addEventListener("touchstart", _emptyFunc); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n      _addListener(_doc, "contextmenu", function () {\n        for (let p in _lookup) {\n          if (_lookup[p].isPressed) {\n            _lookup[p].endDrag();\n          }\n        }\n      });\n      gsap = _coreInitted = _getGSAP();\n    }\n    if (gsap) {\n      InertiaPlugin = gsap.plugins.inertia;\n      _checkPrefix = gsap.utils.checkPrefix;\n      _transformProp = _checkPrefix(_transformProp);\n      _transformOriginProp = _checkPrefix(_transformOriginProp);\n      _toArray = gsap.utils.toArray;\n      _supports3D = !!_checkPrefix("perspective");\n    } else if (required) {\n      console.warn("Please gsap.registerPlugin(Draggable)");\n    }\n  };\nclass EventDispatcher {\n  constructor(target) {\n    this._listeners = {};\n    this.target = target || this;\n  }\n  addEventListener(type, callback) {\n    let list = this._listeners[type] || (this._listeners[type] = []);\n    if (!~list.indexOf(callback)) {\n      list.push(callback);\n    }\n  }\n  removeEventListener(type, callback) {\n    let list = this._listeners[type],\n      i = list && list.indexOf(callback) || -1;\n    i > -1 && list.splice(i, 1);\n  }\n  dispatchEvent(type) {\n    let result;\n    (this._listeners[type] || []).forEach(callback => callback.call(this, {\n      type: type,\n      target: this.target\n    }) === false && (result = false));\n    return result; //if any of the callbacks return false, pass that along.\n  }\n}\nclass Draggable extends EventDispatcher {\n  constructor(target, vars) {\n    super();\n    _coreInitted || _initCore(1);\n    target = _toArray(target)[0]; //in case the target is a selector object or selector text\n    if (!InertiaPlugin) {\n      InertiaPlugin = gsap.plugins.inertia;\n    }\n    this.vars = vars = _copy(vars || {});\n    this.target = target;\n    this.x = this.y = this.rotation = 0;\n    this.dragResistance = parseFloat(vars.dragResistance) || 0;\n    this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;\n    this.lockAxis = vars.lockAxis;\n    this.autoScroll = vars.autoScroll || 0;\n    this.lockedAxis = null;\n    this.allowEventDefault = !!vars.allowEventDefault;\n    gsap.getProperty(target, "x"); // to ensure that transforms are instantiated.\n\n    let type = (vars.type || "x,y").toLowerCase(),\n      xyMode = ~type.indexOf("x") || ~type.indexOf("y"),\n      rotationMode = type.indexOf("rotation") !== -1,\n      xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",\n      yProp = xyMode ? "y" : "top",\n      allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"),\n      allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"),\n      minimumMovement = vars.minimumMovement || 2,\n      self = this,\n      triggers = _toArray(vars.trigger || vars.handle || target),\n      killProps = {},\n      dragEndTime = 0,\n      checkAutoScrollBounds = false,\n      autoScrollMarginTop = vars.autoScrollMarginTop || 40,\n      autoScrollMarginRight = vars.autoScrollMarginRight || 40,\n      autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,\n      autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,\n      isClickable = vars.clickableTest || _isClickable,\n      clickTime = 0,\n      gsCache = target._gsap || gsap.core.getCache(target),\n      isFixed = _isFixed(target),\n      getPropAsNum = (property, unit) => parseFloat(gsCache.get(target, property, unit)),\n      ownerDoc = target.ownerDocument || _doc,\n      enabled,\n      scrollProxy,\n      startPointerX,\n      startPointerY,\n      startElementX,\n      startElementY,\n      hasBounds,\n      hasDragCallback,\n      hasMoveCallback,\n      maxX,\n      minX,\n      maxY,\n      minY,\n      touch,\n      touchID,\n      rotationOrigin,\n      dirty,\n      old,\n      snapX,\n      snapY,\n      snapXY,\n      isClicking,\n      touchEventTarget,\n      matrix,\n      interrupted,\n      allowNativeTouchScrolling,\n      touchDragAxis,\n      isDispatching,\n      clickDispatch,\n      trustedClickDispatch,\n      isPreventingDefault,\n      onContextMenu = e => {\n        //used to prevent long-touch from triggering a context menu.\n        // (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.\n        _preventDefault(e);\n        e.stopImmediatePropagation && e.stopImmediatePropagation();\n        return false;\n      },\n      //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it\'s better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.\n      render = suppressEvents => {\n        if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {\n          let e = target,\n            autoScrollFactor = self.autoScroll * 15,\n            //multiplying by 15 just gives us a better "feel" speed-wise.\n            parent,\n            isRoot,\n            rect,\n            pointerX,\n            pointerY,\n            changeX,\n            changeY,\n            gap;\n          checkAutoScrollBounds = false;\n          _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n          _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n          pointerX = self.pointerX - _windowProxy.scrollLeft;\n          pointerY = self.pointerY - _windowProxy.scrollTop;\n          while (e && !isRoot) {\n            //walk up the chain and sense wherever the pointer is within 40px of an edge that\'s scrollable.\n            isRoot = _isRoot(e.parentNode);\n            parent = isRoot ? _windowProxy : e.parentNode;\n            rect = isRoot ? {\n              bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),\n              right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),\n              left: 0,\n              top: 0\n            } : parent.getBoundingClientRect();\n            changeX = changeY = 0;\n            if (allowY) {\n              gap = parent._gsMaxScrollY - parent.scrollTop;\n              if (gap < 0) {\n                changeY = gap;\n              } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {\n                checkAutoScrollBounds = true;\n                changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);\n              } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {\n                checkAutoScrollBounds = true;\n                changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);\n              }\n              if (changeY) {\n                parent.scrollTop += changeY;\n              }\n            }\n            if (allowX) {\n              gap = parent._gsMaxScrollX - parent.scrollLeft;\n              if (gap < 0) {\n                changeX = gap;\n              } else if (pointerX > rect.right - autoScrollMarginRight && gap) {\n                checkAutoScrollBounds = true;\n                changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);\n              } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {\n                checkAutoScrollBounds = true;\n                changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);\n              }\n              if (changeX) {\n                parent.scrollLeft += changeX;\n              }\n            }\n            if (isRoot && (changeX || changeY)) {\n              _win.scrollTo(parent.scrollLeft, parent.scrollTop);\n              setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);\n            }\n            e = parent;\n          }\n        }\n        if (dirty) {\n          let {\n            x,\n            y\n          } = self;\n          if (rotationMode) {\n            self.deltaX = x - parseFloat(gsCache.rotation);\n            self.rotation = x;\n            gsCache.rotation = x + "deg";\n            gsCache.renderTransform(1, gsCache);\n          } else {\n            if (scrollProxy) {\n              if (allowY) {\n                self.deltaY = y - scrollProxy.top();\n                scrollProxy.top(y);\n              }\n              if (allowX) {\n                self.deltaX = x - scrollProxy.left();\n                scrollProxy.left(x);\n              }\n            } else if (xyMode) {\n              if (allowY) {\n                self.deltaY = y - parseFloat(gsCache.y);\n                gsCache.y = y + "px";\n              }\n              if (allowX) {\n                self.deltaX = x - parseFloat(gsCache.x);\n                gsCache.x = x + "px";\n              }\n              gsCache.renderTransform(1, gsCache);\n            } else {\n              if (allowY) {\n                self.deltaY = y - parseFloat(target.style.top || 0);\n                target.style.top = y + "px";\n              }\n              if (allowX) {\n                self.deltaX = x - parseFloat(target.style.left || 0);\n                target.style.left = x + "px";\n              }\n            }\n          }\n          if (hasDragCallback && !suppressEvents && !isDispatching) {\n            isDispatching = true; //in case onDrag has an update() call (avoid endless loop)\n            if (_dispatchEvent(self, "drag", "onDrag") === false) {\n              if (allowX) {\n                self.x -= self.deltaX;\n              }\n              if (allowY) {\n                self.y -= self.deltaY;\n              }\n              render(true);\n            }\n            isDispatching = false;\n          }\n        }\n        dirty = false;\n      },\n      //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy\'s top/left) to the Draggable\'s x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.\n      syncXY = (skipOnUpdate, skipSnap) => {\n        let {\n            x,\n            y\n          } = self,\n          snappedValue,\n          cs;\n        if (!target._gsap) {\n          //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).\n          gsCache = gsap.core.getCache(target);\n        }\n        gsCache.uncache && gsap.getProperty(target, "x"); // trigger a re-cache\n        if (xyMode) {\n          self.x = parseFloat(gsCache.x);\n          self.y = parseFloat(gsCache.y);\n        } else if (rotationMode) {\n          self.x = self.rotation = parseFloat(gsCache.rotation);\n        } else if (scrollProxy) {\n          self.y = scrollProxy.top();\n          self.x = scrollProxy.left();\n        } else {\n          self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;\n          self.x = parseFloat(target.style.left || (cs || {}).left) || 0;\n        }\n        if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {\n          if (snapXY) {\n            _temp1.x = self.x;\n            _temp1.y = self.y;\n            snappedValue = snapXY(_temp1);\n            if (snappedValue.x !== self.x) {\n              self.x = snappedValue.x;\n              dirty = true;\n            }\n            if (snappedValue.y !== self.y) {\n              self.y = snappedValue.y;\n              dirty = true;\n            }\n          }\n          if (snapX) {\n            snappedValue = snapX(self.x);\n            if (snappedValue !== self.x) {\n              self.x = snappedValue;\n              if (rotationMode) {\n                self.rotation = snappedValue;\n              }\n              dirty = true;\n            }\n          }\n          if (snapY) {\n            snappedValue = snapY(self.y);\n            if (snappedValue !== self.y) {\n              self.y = snappedValue;\n            }\n            dirty = true;\n          }\n        }\n        dirty && render(true);\n        if (!skipOnUpdate) {\n          self.deltaX = self.x - x;\n          self.deltaY = self.y - y;\n          _dispatchEvent(self, "throwupdate", "onThrowUpdate");\n        }\n      },\n      buildSnapFunc = (snap, min, max, factor) => {\n        if (min == null) {\n          min = -_bigNum;\n        }\n        if (max == null) {\n          max = _bigNum;\n        }\n        if (_isFunction(snap)) {\n          return n => {\n            let edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we\'re tweening, disable the edgeTolerance because it\'s already factored into the tweening values (we don\'t want to apply it multiple times)\n            return snap.call(self, n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor;\n          };\n        }\n        if (_isArray(snap)) {\n          return n => {\n            let i = snap.length,\n              closest = 0,\n              absDif = _bigNum,\n              val,\n              dif;\n            while (--i > -1) {\n              val = snap[i];\n              dif = val - n;\n              if (dif < 0) {\n                dif = -dif;\n              }\n              if (dif < absDif && val >= min && val <= max) {\n                closest = i;\n                absDif = dif;\n              }\n            }\n            return snap[closest];\n          };\n        }\n        return isNaN(snap) ? n => n : () => snap * factor;\n      },\n      buildPointSnapFunc = (snap, minX, maxX, minY, maxY, radius, factor) => {\n        radius = radius && radius < _bigNum ? radius * radius : _bigNum; //so we don\'t have to Math.sqrt() in the functions. Performance optimization.\n        if (_isFunction(snap)) {\n          return point => {\n            let edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,\n              x = point.x,\n              y = point.y,\n              result,\n              dx,\n              dy; //if we\'re tweening, disable the edgeTolerance because it\'s already factored into the tweening values (we don\'t want to apply it multiple times)\n            point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;\n            point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;\n            result = snap.call(self, point);\n            if (result !== point) {\n              point.x = result.x;\n              point.y = result.y;\n            }\n            if (factor !== 1) {\n              point.x *= factor;\n              point.y *= factor;\n            }\n            if (radius < _bigNum) {\n              dx = point.x - x;\n              dy = point.y - y;\n              if (dx * dx + dy * dy > radius) {\n                point.x = x;\n                point.y = y;\n              }\n            }\n            return point;\n          };\n        }\n        if (_isArray(snap)) {\n          return p => {\n            let i = snap.length,\n              closest = 0,\n              minDist = _bigNum,\n              x,\n              y,\n              point,\n              dist;\n            while (--i > -1) {\n              point = snap[i];\n              x = point.x - p.x;\n              y = point.y - p.y;\n              dist = x * x + y * y;\n              if (dist < minDist) {\n                closest = i;\n                minDist = dist;\n              }\n            }\n            return minDist <= radius ? snap[closest] : p;\n          };\n        }\n        return n => n;\n      },\n      calculateBounds = () => {\n        let bounds, targetBounds, snap, snapIsRaw;\n        hasBounds = false;\n        if (scrollProxy) {\n          scrollProxy.calibrate();\n          self.minX = minX = -scrollProxy.maxScrollLeft();\n          self.minY = minY = -scrollProxy.maxScrollTop();\n          self.maxX = maxX = self.maxY = maxY = 0;\n          hasBounds = true;\n        } else if (!!vars.bounds) {\n          bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}\n          if (rotationMode) {\n            self.minX = minX = bounds.left;\n            self.maxX = maxX = bounds.left + bounds.width;\n            self.minY = minY = self.maxY = maxY = 0;\n          } else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {\n            bounds = vars.bounds;\n            self.minX = minX = bounds.minX;\n            self.minY = minY = bounds.minY;\n            self.maxX = maxX = bounds.maxX;\n            self.maxY = maxY = bounds.maxY;\n          } else {\n            targetBounds = _getBounds(target, target.parentNode);\n            self.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left - 0.5);\n            self.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top - 0.5);\n            self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));\n            self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));\n          }\n          if (minX > maxX) {\n            self.minX = maxX;\n            self.maxX = maxX = minX;\n            minX = self.minX;\n          }\n          if (minY > maxY) {\n            self.minY = maxY;\n            self.maxY = maxY = minY;\n            minY = self.minY;\n          }\n          if (rotationMode) {\n            self.minRotation = minX;\n            self.maxRotation = maxX;\n          }\n          hasBounds = true;\n        }\n        if (vars.liveSnap) {\n          snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;\n          snapIsRaw = _isArray(snap) || _isFunction(snap);\n          if (rotationMode) {\n            snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);\n            snapY = null;\n          } else {\n            if (snap.points) {\n              snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);\n            } else {\n              if (allowX) {\n                snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);\n              }\n              if (allowY) {\n                snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);\n              }\n            }\n          }\n        }\n      },\n      onThrowComplete = () => {\n        self.isThrowing = false;\n        _dispatchEvent(self, "throwcomplete", "onThrowComplete");\n      },\n      onThrowInterrupt = () => {\n        self.isThrowing = false;\n      },\n      animate = (inertia, forceZeroVelocity) => {\n        let snap, snapIsRaw, tween, overshootTolerance;\n        if (inertia && InertiaPlugin) {\n          if (inertia === true) {\n            snap = vars.snap || vars.liveSnap || {};\n            snapIsRaw = _isArray(snap) || _isFunction(snap);\n            inertia = {\n              resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)\n            };\n            if (rotationMode) {\n              inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);\n            } else {\n              if (allowX) {\n                inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "x");\n              }\n              if (allowY) {\n                inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "y");\n              }\n              if (snap.points || _isArray(snap) && _isObject(snap[0])) {\n                inertia.linkedProps = xProp + "," + yProp;\n                inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there\'s a "radius" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that "skipSnap" parameter is true for syncXY.\n              }\n            }\n          }\n          self.isThrowing = true;\n          overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;\n          if (!inertia.duration) {\n            inertia.duration = {\n              max: Math.max(vars.minDuration || 0, "maxDuration" in vars ? vars.maxDuration : 2),\n              min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,\n              overshoot: overshootTolerance\n            };\n          }\n          self.tween = tween = gsap.to(scrollProxy || target, {\n            inertia: inertia,\n            data: "_draggable",\n            onComplete: onThrowComplete,\n            onInterrupt: onThrowInterrupt,\n            onUpdate: vars.fastMode ? _dispatchEvent : syncXY,\n            onUpdateParams: vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : snap && snap.radius ? [false, true] : []\n          });\n          if (!vars.fastMode) {\n            if (scrollProxy) {\n              scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we\'re affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n            }\n            tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that\'s when InertiaPlugin calculates it.\n            syncXY(true, true);\n            self.endX = self.x;\n            self.endY = self.y;\n            if (rotationMode) {\n              self.endRotation = self.x;\n            }\n            tween.play(0);\n            syncXY(true, true);\n            if (scrollProxy) {\n              scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we\'re affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.\n            }\n          }\n        } else if (hasBounds) {\n          self.applyBounds();\n        }\n      },\n      updateMatrix = shiftStart => {\n        let start = matrix,\n          p;\n        matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);\n        if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D())) {\n          //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.\n          p = start.inverse().apply({\n            x: startPointerX,\n            y: startPointerY\n          });\n          matrix.apply(p, p);\n          startPointerX = p.x;\n          startPointerY = p.y;\n        }\n        if (matrix.equals(_identityMatrix)) {\n          //if there are no transforms, we can optimize performance by not factoring in the matrix\n          matrix = null;\n        }\n      },\n      recordStartPositions = () => {\n        let edgeTolerance = 1 - self.edgeResistance,\n          offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0,\n          offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0,\n          parsedOrigin,\n          x,\n          y;\n        updateMatrix(false);\n        _point1.x = self.pointerX - offsetX;\n        _point1.y = self.pointerY - offsetY;\n        matrix && matrix.apply(_point1, _point1);\n        startPointerX = _point1.x; //translate to local coordinate system\n        startPointerY = _point1.y;\n        if (dirty) {\n          setPointerPosition(self.pointerX, self.pointerY);\n          render(true);\n        }\n        if (scrollProxy) {\n          calculateBounds();\n          startElementY = scrollProxy.top();\n          startElementX = scrollProxy.left();\n        } else {\n          //if the element is in the process of tweening, don\'t force snapping to occur because it could make it jump. Imagine the user throwing, then before it\'s done, clicking on the element in its inbetween state.\n          if (isTweening()) {\n            syncXY(true, true);\n            calculateBounds();\n          } else {\n            self.applyBounds();\n          }\n          if (rotationMode) {\n            parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp] || "0 0").split(" ");\n            rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target).apply({\n              x: parseFloat(parsedOrigin[0]) || 0,\n              y: parseFloat(parsedOrigin[1]) || 0\n            });\n            syncXY(true, true);\n            x = self.pointerX - rotationOrigin.x - offsetX;\n            y = rotationOrigin.y - self.pointerY + offsetY;\n            startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)\n            startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;\n          } else {\n            //parent = !isFixed && target.parentNode;\n            //startScrollTop = parent ? parent.scrollTop || 0 : 0;\n            //startScrollLeft = parent ? parent.scrollLeft || 0 : 0;\n            startElementY = getPropAsNum(yProp, "px"); //record the starting top and left values so that we can just add the mouse\'s movement to them later.\n            startElementX = getPropAsNum(xProp, "px");\n          }\n        }\n        if (hasBounds && edgeTolerance) {\n          if (startElementX > maxX) {\n            startElementX = maxX + (startElementX - maxX) / edgeTolerance;\n          } else if (startElementX < minX) {\n            startElementX = minX - (minX - startElementX) / edgeTolerance;\n          }\n          if (!rotationMode) {\n            if (startElementY > maxY) {\n              startElementY = maxY + (startElementY - maxY) / edgeTolerance;\n            } else if (startElementY < minY) {\n              startElementY = minY - (minY - startElementY) / edgeTolerance;\n            }\n          }\n        }\n        self.startX = startElementX = _round(startElementX);\n        self.startY = startElementY = _round(startElementY);\n      },\n      isTweening = () => self.tween && self.tween.isActive(),\n      removePlaceholder = () => {\n        if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {\n          //_placeholderDiv just props open auto-scrolling containers so they don\'t collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.\n          _placeholderDiv.parentNode.removeChild(_placeholderDiv);\n        }\n      },\n      //called when the mouse is pressed (or touch starts)\n      onPress = (e, force) => {\n        let i;\n        if (!enabled || self.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {\n          //when we DON\'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it\'d result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.\n          isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n          return;\n        }\n        interrupted = isTweening();\n        self.pointerEvent = e;\n        if (_touchEventLookup[e.type]) {\n          //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.\n          touchEventTarget = ~e.type.indexOf("touch") ? e.currentTarget || e.target : ownerDoc; //pointer-based touches (for Microsoft browsers) don\'t remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".\n          _addListener(touchEventTarget, "touchend", onRelease);\n          _addListener(touchEventTarget, "touchmove", onMove);\n          _addListener(touchEventTarget, "touchcancel", onRelease);\n          _addListener(ownerDoc, "touchstart", _onMultiTouchDocument);\n        } else {\n          touchEventTarget = null;\n          _addListener(ownerDoc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user\'s mouse moves too quickly (and off of the box), things still work.\n        }\n        touchDragAxis = null;\n        if (!_supportsPointer || !touchEventTarget) {\n          _addListener(ownerDoc, "mouseup", onRelease);\n          e && e.target && _addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don\'t bubble up the event to the _doc on elements with contentEditable="true"\n        }\n        isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;\n        if (isClicking) {\n          _addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.\n          _dispatchEvent(self, "pressInit", "onPressInit");\n          _dispatchEvent(self, "press", "onPress");\n          _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn\'t drag to select text)\n          isPreventingDefault = false;\n          return;\n        }\n        allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn\'t have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.\n        isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;\n        if (isPreventingDefault) {\n          _preventDefault(e);\n          _addListener(_win, "touchforcechange", _preventDefault); //works around safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n        }\n        if (e.changedTouches) {\n          //touch events store the data slightly differently\n          e = touch = e.changedTouches[0];\n          touchID = e.identifier;\n        } else if (e.pointerId) {\n          touchID = e.pointerId; //for some Microsoft browsers\n        } else {\n          touch = touchID = null;\n        }\n        _dragCount++;\n        _addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)\n        startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove\n        startPointerX = self.pointerX = e.pageX;\n        _dispatchEvent(self, "pressInit", "onPressInit");\n        if (allowNativeTouchScrolling || self.autoScroll) {\n          _recordMaxScrolls(target.parentNode);\n        }\n        if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {\n          //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.\n          _placeholderDiv.style.width = target.parentNode.scrollWidth + "px";\n          target.parentNode.appendChild(_placeholderDiv);\n        }\n        recordStartPositions();\n        self.tween && self.tween.kill();\n        self.isThrowing = false;\n        gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.\n        scrollProxy && gsap.killTweensOf(target, {\n          scrollTo: 1\n        }, true); //just in case the original target\'s scroll position is being tweened somewhere else.\n        self.tween = self.lockedAxis = null;\n        if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {\n          target.style.zIndex = Draggable.zIndex++;\n        }\n        self.isPressed = true;\n        hasDragCallback = !!(vars.onDrag || self._listeners.drag);\n        hasMoveCallback = !!(vars.onMove || self._listeners.move);\n        if (!rotationMode && (vars.cursor !== false || vars.activeCursor)) {\n          i = triggers.length;\n          while (--i > -1) {\n            gsap.set(triggers[i], {\n              cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)\n            });\n          }\n        }\n        _dispatchEvent(self, "press", "onPress");\n      },\n      //called every time the mouse/touch moves\n      onMove = e => {\n        let originalEvent = e,\n          touches,\n          pointerX,\n          pointerY,\n          i,\n          dx,\n          dy;\n        if (!enabled || _isMultiTouching || !self.isPressed || !e) {\n          isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n          return;\n        }\n        self.pointerEvent = e;\n        touches = e.changedTouches;\n        if (touches) {\n          //touch events store the data slightly differently\n          e = touches[0];\n          if (e !== touch && e.identifier !== touchID) {\n            //Usually changedTouches[0] will be what we\'re looking for, but in case it\'s not, look through the rest of the array...(and Android browsers don\'t reuse the event like iOS)\n            i = touches.length;\n            while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable\'s target, let it through.\n            if (i < 0) {\n              return;\n            }\n          }\n        } else if (e.pointerId && touchID && e.pointerId !== touchID) {\n          //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we\'re receiving has a pointerId that doesn\'t match the touchID, ignore it (for multi-touch)\n          return;\n        }\n        if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {\n          //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).\n          _point1.x = e.pageX;\n          _point1.y = e.pageY;\n          matrix && matrix.apply(_point1, _point1);\n          pointerX = _point1.x;\n          pointerY = _point1.y;\n          dx = Math.abs(pointerX - startPointerX);\n          dy = Math.abs(pointerY - startPointerY);\n          if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n            touchDragAxis = dx > dy && allowX ? "x" : "y";\n            if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {\n              _addListener(_win, "touchforcechange", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari\n            }\n            if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {\n              self.lockedAxis = touchDragAxis === "x" ? "y" : "x";\n              _isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);\n            }\n            if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {\n              onRelease(originalEvent);\n              return;\n            }\n          }\n        }\n        if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {\n          _preventDefault(originalEvent);\n          isPreventingDefault = true;\n        } else if (isPreventingDefault) {\n          isPreventingDefault = false;\n        }\n        if (self.autoScroll) {\n          checkAutoScrollBounds = true;\n        }\n        setPointerPosition(e.pageX, e.pageY, hasMoveCallback);\n      },\n      setPointerPosition = (pointerX, pointerY, invokeOnMove) => {\n        let dragTolerance = 1 - self.dragResistance,\n          edgeTolerance = 1 - self.edgeResistance,\n          prevPointerX = self.pointerX,\n          prevPointerY = self.pointerY,\n          prevStartElementY = startElementY,\n          prevX = self.x,\n          prevY = self.y,\n          prevEndX = self.endX,\n          prevEndY = self.endY,\n          prevEndRotation = self.endRotation,\n          prevDirty = dirty,\n          xChange,\n          yChange,\n          x,\n          y,\n          dif,\n          temp;\n        self.pointerX = pointerX;\n        self.pointerY = pointerY;\n        if (isFixed) {\n          pointerX -= _getDocScrollLeft(ownerDoc);\n          pointerY -= _getDocScrollTop(ownerDoc);\n        }\n        if (rotationMode) {\n          y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;\n          dif = self.y - y;\n          if (dif > 180) {\n            startElementY -= 360;\n            self.y = y;\n          } else if (dif < -180) {\n            startElementY += 360;\n            self.y = y;\n          }\n          if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {\n            self.y = y;\n            x = startElementX + (startElementY - y) * dragTolerance;\n          } else {\n            x = startElementX;\n          }\n        } else {\n          if (matrix) {\n            temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;\n            pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;\n            pointerX = temp;\n          }\n          yChange = pointerY - startPointerY;\n          xChange = pointerX - startPointerX;\n          if (yChange < minimumMovement && yChange > -minimumMovement) {\n            yChange = 0;\n          }\n          if (xChange < minimumMovement && xChange > -minimumMovement) {\n            xChange = 0;\n          }\n          if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {\n            temp = self.lockedAxis;\n            if (!temp) {\n              self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;\n              if (temp && _isFunction(self.vars.onLockAxis)) {\n                self.vars.onLockAxis.call(self, self.pointerEvent);\n              }\n            }\n            if (temp === "y") {\n              yChange = 0;\n            } else if (temp === "x") {\n              xChange = 0;\n            }\n          }\n          x = _round(startElementX + xChange * dragTolerance);\n          y = _round(startElementY + yChange * dragTolerance);\n        }\n        if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {\n          if (snapXY) {\n            _temp1.x = x;\n            _temp1.y = y;\n            temp = snapXY(_temp1);\n            x = _round(temp.x);\n            y = _round(temp.y);\n          }\n          if (snapX) {\n            x = _round(snapX(x));\n          }\n          if (snapY) {\n            y = _round(snapY(y));\n          }\n        } else if (hasBounds) {\n          if (x > maxX) {\n            x = maxX + Math.round((x - maxX) * edgeTolerance);\n          } else if (x < minX) {\n            x = minX + Math.round((x - minX) * edgeTolerance);\n          }\n          if (!rotationMode) {\n            if (y > maxY) {\n              y = Math.round(maxY + (y - maxY) * edgeTolerance);\n            } else if (y < minY) {\n              y = Math.round(minY + (y - minY) * edgeTolerance);\n            }\n          }\n        }\n        if (self.x !== x || self.y !== y && !rotationMode) {\n          if (rotationMode) {\n            self.endRotation = self.x = self.endX = x;\n            dirty = true;\n          } else {\n            if (allowY) {\n              self.y = self.endY = y;\n              dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn\'t render on every move because sometimes many move events can get dispatched between screen refreshes, and that\'d be wasteful to render every time)\n            }\n            if (allowX) {\n              self.x = self.endX = x;\n              dirty = true;\n            }\n          }\n          if (!invokeOnMove || _dispatchEvent(self, "move", "onMove") !== false) {\n            if (!self.isDragging && self.isPressed) {\n              self.isDragging = true;\n              _dispatchEvent(self, "dragstart", "onDragStart");\n            }\n          } else {\n            //revert because the onMove returned false!\n            self.pointerX = prevPointerX;\n            self.pointerY = prevPointerY;\n            startElementY = prevStartElementY;\n            self.x = prevX;\n            self.y = prevY;\n            self.endX = prevEndX;\n            self.endY = prevEndY;\n            self.endRotation = prevEndRotation;\n            dirty = prevDirty;\n          }\n        }\n      },\n      //called when the mouse/touch is released\n      onRelease = (e, force) => {\n        if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {\n          //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we\'re receiving has a pointerId that doesn\'t match the touchID, ignore it (for multi-touch)\n          isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.\n          return;\n        }\n        self.isPressed = false;\n        let originalEvent = e,\n          wasDragging = self.isDragging,\n          isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),\n          placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder),\n          touches,\n          i,\n          syntheticEvent,\n          eventTarget,\n          syntheticClick;\n        if (touchEventTarget) {\n          _removeListener(touchEventTarget, "touchend", onRelease);\n          _removeListener(touchEventTarget, "touchmove", onMove);\n          _removeListener(touchEventTarget, "touchcancel", onRelease);\n          _removeListener(ownerDoc, "touchstart", _onMultiTouchDocument);\n        } else {\n          _removeListener(ownerDoc, "mousemove", onMove);\n        }\n        _removeListener(_win, "touchforcechange", _preventDefault);\n        if (!_supportsPointer || !touchEventTarget) {\n          _removeListener(ownerDoc, "mouseup", onRelease);\n          e && e.target && _removeListener(e.target, "mouseup", onRelease);\n        }\n        dirty = false;\n        if (wasDragging) {\n          dragEndTime = _lastDragTime = _getTime();\n          self.isDragging = false;\n        }\n        if (isClicking && !isContextMenuRelease) {\n          if (e) {\n            _removeListener(e.target, "change", onRelease);\n            self.pointerEvent = originalEvent;\n          }\n          _setSelectable(triggers, false);\n          _dispatchEvent(self, "release", "onRelease");\n          _dispatchEvent(self, "click", "onClick");\n          isClicking = false;\n          return;\n        }\n        _removeFromRenderQueue(render);\n        if (!rotationMode) {\n          i = triggers.length;\n          while (--i > -1) {\n            _setStyle(triggers[i], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));\n          }\n        }\n        _dragCount--;\n        if (e) {\n          touches = e.changedTouches;\n          if (touches) {\n            //touch events store the data slightly differently\n            e = touches[0];\n            if (e !== touch && e.identifier !== touchID) {\n              //Usually changedTouches[0] will be what we\'re looking for, but in case it\'s not, look through the rest of the array...(and Android browsers don\'t reuse the event like iOS)\n              i = touches.length;\n              while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}\n              if (i < 0) {\n                return;\n              }\n            }\n          }\n          self.pointerEvent = originalEvent;\n          self.pointerX = e.pageX;\n          self.pointerY = e.pageY;\n        }\n        if (isContextMenuRelease && originalEvent) {\n          _preventDefault(originalEvent);\n          isPreventingDefault = true;\n          _dispatchEvent(self, "release", "onRelease");\n        } else if (originalEvent && !wasDragging) {\n          isPreventingDefault = false;\n          if (interrupted && (vars.snap || vars.bounds)) {\n            //otherwise, if the user clicks on the object while it\'s animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)\n            animate(vars.inertia || vars.throwProps);\n          }\n          _dispatchEvent(self, "release", "onRelease");\n          if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {\n            //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn\'t trigger a "click".\n            _dispatchEvent(self, "click", "onClick");\n            if (_getTime() - clickTime < 300) {\n              _dispatchEvent(self, "doubleclick", "onDoubleClick");\n            }\n            eventTarget = originalEvent.target || target; //old IE uses srcElement\n            clickTime = _getTime();\n            syntheticClick = () => {\n              // some browsers (like Firefox) won\'t trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won\'t work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don\'t even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n              if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {\n                if (eventTarget.click) {\n                  //some browsers (like mobile Safari) don\'t properly trigger the click event\n                  eventTarget.click();\n                } else if (ownerDoc.createEvent) {\n                  syntheticEvent = ownerDoc.createEvent("MouseEvents");\n                  syntheticEvent.initMouseEvent("click", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);\n                  eventTarget.dispatchEvent(syntheticEvent);\n                }\n              }\n            };\n            if (!_isAndroid && !originalEvent.defaultPrevented) {\n              //iOS Safari requires the synthetic click to happen immediately or else it simply won\'t work, but Android doesn\'t play nice.\n              gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there\'s a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don\'t fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it\'s "trusted".\n            }\n          }\n        } else {\n          animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn\'t defined or IntertiaPlugin isn\'t loaded.\n          if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {\n            isPreventingDefault = true;\n            _preventDefault(originalEvent);\n          } else {\n            isPreventingDefault = false;\n          }\n          _dispatchEvent(self, "release", "onRelease");\n        }\n        isTweening() && placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets\n        wasDragging && _dispatchEvent(self, "dragend", "onDragEnd");\n        return true;\n      },\n      updateScroll = e => {\n        if (e && self.isDragging && !scrollProxy) {\n          let parent = e.target || target.parentNode,\n            deltaX = parent.scrollLeft - parent._gsScrollX,\n            deltaY = parent.scrollTop - parent._gsScrollY;\n          if (deltaX || deltaY) {\n            if (matrix) {\n              startPointerX -= deltaX * matrix.a + deltaY * matrix.c;\n              startPointerY -= deltaY * matrix.d + deltaX * matrix.b;\n            } else {\n              startPointerX -= deltaX;\n              startPointerY -= deltaY;\n            }\n            parent._gsScrollX += deltaX;\n            parent._gsScrollY += deltaY;\n            setPointerPosition(self.pointerX, self.pointerY);\n          }\n        }\n      },\n      onClick = e => {\n        //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don\'t even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.\n        let time = _getTime(),\n          recentlyClicked = time - clickTime < 40,\n          recentlyDragged = time - dragEndTime < 40,\n          alreadyDispatched = recentlyClicked && clickDispatch === clickTime,\n          defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,\n          alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,\n          trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn\'t support isTrusted, and it won\'t properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don\'t you love cross-browser compatibility challenges?\n        if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {\n          e.stopImmediatePropagation();\n        }\n        if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {\n          //let the first click pass through unhindered. Let the next one only if it\'s trusted, then no more (stop quick-succession ones)\n          if (trusted && alreadyDispatched) {\n            trustedClickDispatch = clickTime;\n          }\n          clickDispatch = clickTime;\n          return;\n        }\n        if (self.isPressed || recentlyDragged || recentlyClicked) {\n          if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {\n            _preventDefault(e);\n          }\n        }\n        if (!recentlyClicked && !recentlyDragged) {\n          // for script-triggered event dispatches, like element.click()\n          e && e.target && (self.pointerEvent = e);\n          _dispatchEvent(self, "click", "onClick");\n        }\n      },\n      localizePoint = p => matrix ? {\n        x: p.x * matrix.a + p.y * matrix.c + matrix.e,\n        y: p.x * matrix.b + p.y * matrix.d + matrix.f\n      } : {\n        x: p.x,\n        y: p.y\n      };\n    old = Draggable.get(target);\n    old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)\n\n    //give the user access to start/stop dragging...\n    this.startDrag = (event, align) => {\n      let r1, r2, p1, p2;\n      onPress(event || self.pointerEvent, true);\n      //if the pointer isn\'t on top of the element, adjust things accordingly\n      if (align && !self.hitTest(event || self.pointerEvent)) {\n        r1 = _parseRect(event || self.pointerEvent);\n        r2 = _parseRect(target);\n        p1 = localizePoint({\n          x: r1.left + r1.width / 2,\n          y: r1.top + r1.height / 2\n        });\n        p2 = localizePoint({\n          x: r2.left + r2.width / 2,\n          y: r2.top + r2.height / 2\n        });\n        startPointerX -= p1.x - p2.x;\n        startPointerY -= p1.y - p2.y;\n      }\n      if (!self.isDragging) {\n        self.isDragging = true;\n        _dispatchEvent(self, "dragstart", "onDragStart");\n      }\n    };\n    this.drag = onMove;\n    this.endDrag = e => onRelease(e || self.pointerEvent, true);\n    this.timeSinceDrag = () => self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;\n    this.timeSinceClick = () => (_getTime() - clickTime) / 1000;\n    this.hitTest = (target, threshold) => Draggable.hitTest(self.target, target, threshold);\n    this.getDirection = (from, diagonalThreshold) => {\n      //from can be "start" (default), "velocity", or an element\n      let mode = from === "velocity" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? "element" : "start",\n        xChange,\n        yChange,\n        ratio,\n        direction,\n        r1,\n        r2;\n      if (mode === "element") {\n        r1 = _parseRect(self.target);\n        r2 = _parseRect(from);\n      }\n      xChange = mode === "start" ? self.x - startElementX : mode === "velocity" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);\n      if (rotationMode) {\n        return xChange < 0 ? "counter-clockwise" : "clockwise";\n      } else {\n        diagonalThreshold = diagonalThreshold || 2;\n        yChange = mode === "start" ? self.y - startElementY : mode === "velocity" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);\n        ratio = Math.abs(xChange / yChange);\n        direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";\n        if (ratio < diagonalThreshold) {\n          if (direction !== "") {\n            direction += "-";\n          }\n          direction += yChange < 0 ? "up" : "down";\n        }\n      }\n      return direction;\n    };\n    this.applyBounds = (newBounds, sticky) => {\n      let x, y, forceZeroVelocity, e, parent, isRoot;\n      if (newBounds && vars.bounds !== newBounds) {\n        vars.bounds = newBounds;\n        return self.update(true, sticky);\n      }\n      syncXY(true);\n      calculateBounds();\n      if (hasBounds && !isTweening()) {\n        x = self.x;\n        y = self.y;\n        if (x > maxX) {\n          x = maxX;\n        } else if (x < minX) {\n          x = minX;\n        }\n        if (y > maxY) {\n          y = maxY;\n        } else if (y < minY) {\n          y = minY;\n        }\n        if (self.x !== x || self.y !== y) {\n          forceZeroVelocity = true;\n          self.x = self.endX = x;\n          if (rotationMode) {\n            self.endRotation = x;\n          } else {\n            self.y = self.endY = y;\n          }\n          dirty = true;\n          render(true);\n          if (self.autoScroll && !self.isDragging) {\n            _recordMaxScrolls(target.parentNode);\n            e = target;\n            _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;\n            _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;\n            while (e && !isRoot) {\n              //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.\n              isRoot = _isRoot(e.parentNode);\n              parent = isRoot ? _windowProxy : e.parentNode;\n              if (allowY && parent.scrollTop > parent._gsMaxScrollY) {\n                parent.scrollTop = parent._gsMaxScrollY;\n              }\n              if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {\n                parent.scrollLeft = parent._gsMaxScrollX;\n              }\n              e = parent;\n            }\n          }\n        }\n        if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {\n          animate(vars.inertia || vars.throwProps, forceZeroVelocity);\n        }\n      }\n      return self;\n    };\n    this.update = (applyBounds, sticky, ignoreExternalChanges) => {\n      let {\n        x,\n        y\n      } = self;\n      updateMatrix(!sticky);\n      if (applyBounds) {\n        self.applyBounds();\n      } else {\n        dirty && ignoreExternalChanges && render(true);\n        syncXY(true);\n      }\n      if (sticky) {\n        setPointerPosition(self.pointerX, self.pointerY);\n        dirty && render(true);\n      }\n      if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {\n        recordStartPositions();\n      }\n      if (self.autoScroll) {\n        _recordMaxScrolls(target.parentNode, self.isDragging);\n        checkAutoScrollBounds = self.isDragging;\n        render(true);\n        //in case reparenting occurred.\n        _removeScrollListener(target, updateScroll);\n        _addScrollListener(target, updateScroll);\n      }\n      return self;\n    };\n    this.enable = type => {\n      let setVars = {\n          lazy: true\n        },\n        id,\n        i,\n        trigger;\n      if (!rotationMode && vars.cursor !== false) {\n        setVars.cursor = vars.cursor || _defaultCursor;\n      }\n      if (gsap.utils.checkPrefix("touchCallout")) {\n        setVars.touchCallout = "none";\n      }\n      if (type !== "soft") {\n        _setTouchActionForAllDescendants(triggers, allowX === allowY ? "none" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is "manipulate" because it\'s perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn\'t prevent dragging.\n        i = triggers.length;\n        while (--i > -1) {\n          trigger = triggers[i];\n          _supportsPointer || _addListener(trigger, "mousedown", onPress);\n          _addListener(trigger, "touchstart", onPress);\n          _addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.\n          gsap.set(trigger, setVars);\n          if (trigger.getBBox && trigger.ownerSVGElement) {\n            // a bug in chrome doesn\'t respect touch-action on SVG elements - it only works if we set it on the parent SVG.\n            gsap.set(trigger.ownerSVGElement, {\n              touchAction: allowX === allowY ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"\n            });\n          }\n          vars.allowContextMenu || _addListener(trigger, "contextmenu", onContextMenu);\n        }\n        _setSelectable(triggers, false);\n      }\n      _addScrollListener(target, updateScroll);\n      enabled = true;\n      if (InertiaPlugin && type !== "soft") {\n        InertiaPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");\n      }\n      target._gsDragID = id = "d" + _lookupCount++;\n      _lookup[id] = self;\n      if (scrollProxy) {\n        scrollProxy.enable();\n        scrollProxy.element._gsDragID = id;\n      }\n      (vars.bounds || rotationMode) && recordStartPositions();\n      vars.bounds && self.applyBounds();\n      return self;\n    };\n    this.disable = type => {\n      let dragging = self.isDragging,\n        i,\n        trigger;\n      if (!rotationMode) {\n        i = triggers.length;\n        while (--i > -1) {\n          _setStyle(triggers[i], "cursor", null);\n        }\n      }\n      if (type !== "soft") {\n        _setTouchActionForAllDescendants(triggers, null);\n        i = triggers.length;\n        while (--i > -1) {\n          trigger = triggers[i];\n          _setStyle(trigger, "touchCallout", null);\n          _removeListener(trigger, "mousedown", onPress);\n          _removeListener(trigger, "touchstart", onPress);\n          _removeListener(trigger, "click", onClick);\n          _removeListener(trigger, "contextmenu", onContextMenu);\n        }\n        _setSelectable(triggers, true);\n        if (touchEventTarget) {\n          _removeListener(touchEventTarget, "touchcancel", onRelease);\n          _removeListener(touchEventTarget, "touchend", onRelease);\n          _removeListener(touchEventTarget, "touchmove", onMove);\n        }\n        _removeListener(ownerDoc, "mouseup", onRelease);\n        _removeListener(ownerDoc, "mousemove", onMove);\n      }\n      _removeScrollListener(target, updateScroll);\n      enabled = false;\n      InertiaPlugin && type !== "soft" && InertiaPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");\n      scrollProxy && scrollProxy.disable();\n      _removeFromRenderQueue(render);\n      self.isDragging = self.isPressed = isClicking = false;\n      dragging && _dispatchEvent(self, "dragend", "onDragEnd");\n      return self;\n    };\n    this.enabled = function (value, type) {\n      return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;\n    };\n    this.kill = function () {\n      self.isThrowing = false;\n      self.tween && self.tween.kill();\n      self.disable();\n      gsap.set(triggers, {\n        clearProps: "userSelect"\n      });\n      delete _lookup[target._gsDragID];\n      return self;\n    };\n    if (~type.indexOf("scroll")) {\n      scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({\n        onKill: function () {\n          //ScrollProxy\'s onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn\'t fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.\n          self.isPressed && onRelease(null);\n        }\n      }, vars));\n      //a bug in many Android devices\' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)\n      target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";\n      target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";\n      target = scrollProxy.content;\n    }\n    if (rotationMode) {\n      killProps.rotation = 1;\n    } else {\n      if (allowX) {\n        killProps[xProp] = 1;\n      }\n      if (allowY) {\n        killProps[yProp] = 1;\n      }\n    }\n    gsCache.force3D = "force3D" in vars ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it\'s released and there\'s an inertia tween, it\'d jump to 3D which can create an initial jump due to the work the browser must to do layerize it.\n\n    this.enable();\n  }\n  static register(core) {\n    gsap = core;\n    _initCore();\n  }\n  static create(targets, vars) {\n    _coreInitted || _initCore(true);\n    return _toArray(targets).map(target => new Draggable(target, vars));\n  }\n  static get(target) {\n    return _lookup[(_toArray(target)[0] || {})._gsDragID];\n  }\n  static timeSinceDrag() {\n    return (_getTime() - _lastDragTime) / 1000;\n  }\n  static hitTest(obj1, obj2, threshold) {\n    if (obj1 === obj2) {\n      return false;\n    }\n    let r1 = _parseRect(obj1),\n      r2 = _parseRect(obj2),\n      {\n        top,\n        left,\n        right,\n        bottom,\n        width,\n        height\n      } = r1,\n      isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top,\n      overlap,\n      area,\n      isRatio;\n    if (isOutside || !threshold) {\n      return !isOutside;\n    }\n    isRatio = (threshold + "").indexOf("%") !== -1;\n    threshold = parseFloat(threshold) || 0;\n    overlap = {\n      left: Math.max(left, r2.left),\n      top: Math.max(top, r2.top)\n    };\n    overlap.width = Math.min(right, r2.right) - overlap.left;\n    overlap.height = Math.min(bottom, r2.bottom) - overlap.top;\n    if (overlap.width < 0 || overlap.height < 0) {\n      return false;\n    }\n    if (isRatio) {\n      threshold *= 0.01;\n      area = overlap.width * overlap.height;\n      return area >= width * height * threshold || area >= r2.width * r2.height * threshold;\n    }\n    return overlap.width > threshold && overlap.height > threshold;\n  }\n}\n_setDefaults(Draggable.prototype, {\n  pointerX: 0,\n  pointerY: 0,\n  startX: 0,\n  startY: 0,\n  deltaX: 0,\n  deltaY: 0,\n  isDragging: false,\n  isPressed: false\n});\nDraggable.zIndex = 1000;\nDraggable.version = "3.6.1";\n_getGSAP() && gsap.registerPlugin(Draggable);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/Draggable.js?')},"./build/scripts/vendor/gsap/src/DrawSVGPlugin.js":
/*!********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/DrawSVGPlugin.js ***!
  \********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DrawSVGPlugin: () => (/* binding */ DrawSVGPlugin),\n/* harmony export */   "default": () => (/* binding */ DrawSVGPlugin)\n/* harmony export */ });\n/*!\n * DrawSVGPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _toArray,\n  _doc,\n  _win,\n  _isEdge,\n  _coreInitted,\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n  _types = {\n    rect: ["width", "height"],\n    circle: ["r", "r"],\n    ellipse: ["rx", "ry"],\n    line: ["x2", "y2"]\n  },\n  _round = value => Math.round(value * 10000) / 10000,\n  _parseNum = value => parseFloat(value) || 0,\n  _parseSingleVal = (value, length) => {\n    let num = _parseNum(value);\n    return ~value.indexOf("%") ? num / 100 * length : num;\n  },\n  _getAttributeAsNumber = (target, attr) => _parseNum(target.getAttribute(attr)),\n  _sqrt = Math.sqrt,\n  _getDistance = (x1, y1, x2, y2, scaleX, scaleY) => _sqrt(((_parseNum(x2) - _parseNum(x1)) * scaleX) ** 2 + ((_parseNum(y2) - _parseNum(y1)) * scaleY) ** 2),\n  _warn = message => console.warn(message),\n  _hasNonScalingStroke = target => target.getAttribute("vector-effect") === "non-scaling-stroke",\n  _bonusValidated = 1,\n  //<name>DrawSVGPlugin</name>\n  //accepts values like "100%" or "20% 80%" or "20 50" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]\n  _parse = (value, length, defaultStart) => {\n    let i = value.indexOf(" "),\n      s,\n      e;\n    if (i < 0) {\n      s = defaultStart !== undefined ? defaultStart + "" : value;\n      e = value;\n    } else {\n      s = value.substr(0, i);\n      e = value.substr(i + 1);\n    }\n    s = _parseSingleVal(s, length);\n    e = _parseSingleVal(e, length);\n    return s > e ? [e, s] : [s, e];\n  },\n  _getLength = target => {\n    target = _toArray(target)[0];\n    if (!target) {\n      return 0;\n    }\n    let type = target.tagName.toLowerCase(),\n      style = target.style,\n      scaleX = 1,\n      scaleY = 1,\n      length,\n      bbox,\n      points,\n      prevPoint,\n      i,\n      rx,\n      ry;\n    if (_hasNonScalingStroke(target)) {\n      //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.\n      scaleY = target.getScreenCTM();\n      scaleX = _sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\n      scaleY = _sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\n    }\n    try {\n      //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.\n      bbox = target.getBBox(); //solely for fixing bug in IE - we don\'t actually use the bbox.\n    } catch (e) {\n      //firefox has a bug that throws an error if the element isn\'t visible.\n      _warn("Some browsers won\'t measure invisible elements (like display:none or masks inside defs).");\n    }\n    let {\n      x,\n      y,\n      width,\n      height\n    } = bbox || {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    if ((!bbox || !width && !height) && _types[type]) {\n      //if the element isn\'t visible, try to discern width/height using its attributes.\n      width = _getAttributeAsNumber(target, _types[type][0]);\n      height = _getAttributeAsNumber(target, _types[type][1]);\n      if (type !== "rect" && type !== "line") {\n        //double the radius for circles and ellipses\n        width *= 2;\n        height *= 2;\n      }\n      if (type === "line") {\n        x = _getAttributeAsNumber(target, "x1");\n        y = _getAttributeAsNumber(target, "y1");\n        width = Math.abs(width - x);\n        height = Math.abs(height - y);\n      }\n    }\n    if (type === "path") {\n      prevPoint = style.strokeDasharray;\n      style.strokeDasharray = "none";\n      length = target.getTotalLength() || 0;\n      scaleX !== scaleY && _warn("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn\'t proportionally scaled.");\n      length *= (scaleX + scaleY) / 2;\n      style.strokeDasharray = prevPoint;\n    } else if (type === "rect") {\n      length = width * 2 * scaleX + height * 2 * scaleY;\n    } else if (type === "line") {\n      length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);\n    } else if (type === "polyline" || type === "polygon") {\n      points = target.getAttribute("points").match(_numExp) || [];\n      type === "polygon" && points.push(points[0], points[1]);\n      length = 0;\n      for (i = 2; i < points.length; i += 2) {\n        length += _getDistance(points[i - 2], points[i - 1], points[i], points[i + 1], scaleX, scaleY) || 0;\n      }\n    } else if (type === "circle" || type === "ellipse") {\n      rx = width / 2 * scaleX;\n      ry = height / 2 * scaleY;\n      length = Math.PI * (3 * (rx + ry) - _sqrt((3 * rx + ry) * (rx + 3 * ry)));\n    }\n    return length || 0;\n  },\n  _getPosition = (target, length) => {\n    target = _toArray(target)[0];\n    if (!target) {\n      return [0, 0];\n    }\n    length || (length = _getLength(target) + 1);\n    let cs = _win.getComputedStyle(target),\n      dash = cs.strokeDasharray || "",\n      offset = _parseNum(cs.strokeDashoffset),\n      i = dash.indexOf(",");\n    i < 0 && (i = dash.indexOf(" "));\n    dash = i < 0 ? length : _parseNum(dash.substr(0, i));\n    dash > length && (dash = length);\n    return [-offset || 0, dash - offset || 0];\n  },\n  _initCore = () => {\n    if (_windowExists()) {\n      _doc = document;\n      _win = window;\n      _coreInitted = gsap = _getGSAP();\n      _toArray = gsap.utils.toArray;\n      _isEdge = ((_win.navigator || {}).userAgent || "").indexOf("Edge") !== -1; //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than "butt" (like "round") and it doesn\'t match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we\'ll only do that if/when we have to (to maximize performance)\n    }\n  };\nconst DrawSVGPlugin = {\n  version: "3.6.1",\n  name: "drawSVG",\n  register(core) {\n    gsap = core;\n    _initCore();\n  },\n  init(target, value, tween, index, targets) {\n    if (!target.getBBox) {\n      return false;\n    }\n    _coreInitted || _initCore();\n    let length = _getLength(target),\n      start,\n      end,\n      cs;\n    this._style = target.style;\n    this._target = target;\n    if (value + "" === "true") {\n      value = "0 100%";\n    } else if (!value) {\n      value = "0 0";\n    } else if ((value + "").indexOf(" ") === -1) {\n      value = "0 " + value;\n    }\n    start = _getPosition(target, length);\n    end = _parse(value, length, start[0]);\n    this._length = _round(length);\n    this._dash = _round(start[1] - start[0]); //some browsers render artifacts if dash is 0, so we use a very small number in that case.\n    this._offset = _round(-start[0]);\n    this._dashPT = this.add(this, "_dash", this._dash, _round(end[1] - end[0]));\n    this._offsetPT = this.add(this, "_offset", this._offset, _round(-end[0]));\n    if (_isEdge) {\n      //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it\'s "round" and stroke-linejoin is also "round"). Imperceptible, relatively high-performance, and effective. Another option was to set the "d" <path> attribute to its current value on every tick, but that seems like it\'d be much less performant.\n      cs = _win.getComputedStyle(target);\n      if (cs.strokeLinecap !== cs.strokeLinejoin) {\n        end = _parseNum(cs.strokeMiterlimit);\n        this.add(target.style, "strokeMiterlimit", end, end + 0.01);\n      }\n    }\n    this._live = _hasNonScalingStroke(target) || ~(value + "").indexOf("live");\n    this._nowrap = ~(value + "").indexOf("nowrap");\n    this._props.push("drawSVG");\n    return _bonusValidated;\n  },\n  render(ratio, data) {\n    let pt = data._pt,\n      style = data._style,\n      length,\n      lengthRatio,\n      dash,\n      offset;\n    if (pt) {\n      //when the element has vector-effect="non-scaling-stroke" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.\n      if (data._live) {\n        length = _getLength(data._target);\n        if (length !== data._length) {\n          lengthRatio = length / data._length;\n          data._length = length;\n          if (data._offsetPT) {\n            data._offsetPT.s *= lengthRatio;\n            data._offsetPT.c *= lengthRatio;\n          }\n          if (data._dashPT) {\n            data._dashPT.s *= lengthRatio;\n            data._dashPT.c *= lengthRatio;\n          } else {\n            data._dash *= lengthRatio;\n          }\n        }\n      }\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n      dash = data._dash || ratio && ratio !== 1 && 0.0001 || 0; // only let it be zero if it\'s at the start or end of the tween.\n      length = data._length - dash + 0.1;\n      offset = data._offset;\n      dash && offset && dash + Math.abs(offset % data._length) > data._length - 0.2 && (offset += offset < 0 ? 0.1 : -0.1) && (length += 0.1);\n      style.strokeDashoffset = dash ? offset : offset + 0.001;\n      style.strokeDasharray = length < 0.2 ? "none" : dash ? dash + "px," + (data._nowrap ? 999999 : length) + "px" : "0px, 999999px";\n    }\n  },\n  getLength: _getLength,\n  getPosition: _getPosition\n};\n_getGSAP() && gsap.registerPlugin(DrawSVGPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/DrawSVGPlugin.js?')},"./build/scripts/vendor/gsap/src/EasePack.js":
/*!***************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/EasePack.js ***!
  \***************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EasePack: () => (/* binding */ EasePack),\n/* harmony export */   ExpoScaleEase: () => (/* binding */ ExpoScaleEase),\n/* harmony export */   RoughEase: () => (/* binding */ RoughEase),\n/* harmony export */   SlowMo: () => (/* binding */ SlowMo),\n/* harmony export */   "default": () => (/* binding */ EasePack)\n/* harmony export */ });\n/*!\n * EasePack 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _registerEase,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _boolean = (value, defaultValue) => !!(typeof value === "undefined" ? defaultValue : value && !~(value + "").indexOf("false")),\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (gsap) {\n      _registerEase = gsap.registerEase;\n      //add weighted ease capabilities to standard eases so users can do "power2.inOut(0.8)" for example to push everything toward the "out", or (-0.8) to push it toward the "in" (0 is neutral)\n      let eases = gsap.parseEase(),\n        createConfig = ease => ratio => {\n          let y = 0.5 + ratio / 2;\n          ease.config = p => ease(2 * (1 - p) * p * y + p * p);\n        },\n        p;\n      for (p in eases) {\n        if (!eases[p].config) {\n          createConfig(eases[p]);\n        }\n      }\n      _registerEase("slow", SlowMo);\n      _registerEase("expoScale", ExpoScaleEase);\n      _registerEase("rough", RoughEase);\n      for (p in EasePack) {\n        p !== "version" && gsap.core.globals(p, EasePack[p]);\n      }\n      _coreInitted = 1;\n    }\n  },\n  _createSlowMo = (linearRatio, power, yoyoMode) => {\n    linearRatio = Math.min(1, linearRatio || 0.7);\n    let pow = linearRatio < 1 ? power || power === 0 ? power : 0.7 : 0,\n      p1 = (1 - linearRatio) / 2,\n      p3 = p1 + linearRatio,\n      calcEnd = _boolean(yoyoMode);\n    return p => {\n      let r = p + (0.5 - p) * pow;\n      return p < p1 ? calcEnd ? 1 - (p = 1 - p / p1) * p : r - (p = 1 - p / p1) * p * p * p * r : p > p3 ? calcEnd ? p === 1 ? 0 : 1 - (p = (p - p3) / p1) * p : r + (p - r) * (p = (p - p3) / p1) * p * p * p : calcEnd ? 1 : r;\n    };\n  },\n  _createExpoScale = (start, end, ease) => {\n    let p1 = Math.log(end / start),\n      p2 = end - start;\n    ease && (ease = gsap.parseEase(ease));\n    return p => (start * Math.exp(p1 * (ease ? ease(p) : p)) - start) / p2;\n  },\n  EasePoint = function (time, value, next) {\n    this.t = time;\n    this.v = value;\n    if (next) {\n      this.next = next;\n      next.prev = this;\n      this.c = next.v - value;\n      this.gap = next.t - time;\n    }\n  },\n  _createRoughEase = vars => {\n    if (typeof vars !== "object") {\n      //users may pass in via a string, like "rough(30)"\n      vars = {\n        points: +vars || 20\n      };\n    }\n    let taper = vars.taper || "none",\n      a = [],\n      cnt = 0,\n      points = (+vars.points || 20) | 0,\n      i = points,\n      randomize = _boolean(vars.randomize, true),\n      clamp = _boolean(vars.clamp),\n      template = gsap ? gsap.parseEase(vars.template) : 0,\n      strength = (+vars.strength || 1) * 0.4,\n      x,\n      y,\n      bump,\n      invX,\n      obj,\n      pnt,\n      recent;\n    while (--i > -1) {\n      x = randomize ? Math.random() : 1 / points * i;\n      y = template ? template(x) : x;\n      if (taper === "none") {\n        bump = strength;\n      } else if (taper === "out") {\n        invX = 1 - x;\n        bump = invX * invX * strength;\n      } else if (taper === "in") {\n        bump = x * x * strength;\n      } else if (x < 0.5) {\n        //"both" (start)\n        invX = x * 2;\n        bump = invX * invX * 0.5 * strength;\n      } else {\n        //"both" (end)\n        invX = (1 - x) * 2;\n        bump = invX * invX * 0.5 * strength;\n      }\n      if (randomize) {\n        y += Math.random() * bump - bump * 0.5;\n      } else if (i % 2) {\n        y += bump * 0.5;\n      } else {\n        y -= bump * 0.5;\n      }\n      if (clamp) {\n        if (y > 1) {\n          y = 1;\n        } else if (y < 0) {\n          y = 0;\n        }\n      }\n      a[cnt++] = {\n        x: x,\n        y: y\n      };\n    }\n    a.sort((a, b) => a.x - b.x);\n    pnt = new EasePoint(1, 1, null);\n    i = points;\n    while (i--) {\n      obj = a[i];\n      pnt = new EasePoint(obj.x, obj.y, pnt);\n    }\n    recent = new EasePoint(0, 0, pnt.t ? pnt : pnt.next);\n    return p => {\n      let pnt = recent;\n      if (p > pnt.t) {\n        while (pnt.next && p >= pnt.t) {\n          pnt = pnt.next;\n        }\n        pnt = pnt.prev;\n      } else {\n        while (pnt.prev && p <= pnt.t) {\n          pnt = pnt.prev;\n        }\n      }\n      recent = pnt;\n      return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;\n    };\n  };\nconst SlowMo = _createSlowMo(0.7);\nSlowMo.ease = SlowMo; //for backward compatibility\nSlowMo.config = _createSlowMo;\nconst ExpoScaleEase = _createExpoScale(1, 2);\nExpoScaleEase.config = _createExpoScale;\nconst RoughEase = _createRoughEase();\nRoughEase.ease = RoughEase; //for backward compatibility\nRoughEase.config = _createRoughEase;\nconst EasePack = {\n  SlowMo: SlowMo,\n  RoughEase: RoughEase,\n  ExpoScaleEase: ExpoScaleEase\n};\nfor (let p in EasePack) {\n  EasePack[p].register = _initCore;\n  EasePack[p].version = "3.6.1";\n}\n_getGSAP() && gsap.registerPlugin(SlowMo);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/EasePack.js?')},"./build/scripts/vendor/gsap/src/EaselPlugin.js":
/*!******************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/EaselPlugin.js ***!
  \******************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EaselPlugin: () => (/* binding */ EaselPlugin),\n/* harmony export */   "default": () => (/* binding */ EaselPlugin)\n/* harmony export */ });\n/*!\n * EaselPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _win,\n  _createJS,\n  _ColorFilter,\n  _ColorMatrixFilter,\n  _colorProps = "redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset".split(","),\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _getCreateJS = () => _createJS || _win && _win.createjs || _win || {},\n  _warn = message => console.warn(message),\n  _cache = target => {\n    let b = target.getBounds && target.getBounds();\n    if (!b) {\n      b = target.nominalBounds || {\n        x: 0,\n        y: 0,\n        width: 100,\n        height: 100\n      };\n      target.setBounds && target.setBounds(b.x, b.y, b.width, b.height);\n    }\n    target.cache && target.cache(b.x, b.y, b.width, b.height);\n    _warn("EaselPlugin: for filters to display in EaselJS, you must call the object\'s cache() method first. GSAP attempted to use the target\'s getBounds() for the cache but that may not be completely accurate. " + target);\n  },\n  _parseColorFilter = (target, v, plugin) => {\n    if (!_ColorFilter) {\n      _ColorFilter = _getCreateJS().ColorFilter;\n      if (!_ColorFilter) {\n        _warn("EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn\'t loaded.");\n      }\n    }\n    let filters = target.filters || [],\n      i = filters.length,\n      c,\n      s,\n      e,\n      a,\n      p,\n      pt;\n    while (i--) {\n      if (filters[i] instanceof _ColorFilter) {\n        s = filters[i];\n        break;\n      }\n    }\n    if (!s) {\n      s = new _ColorFilter();\n      filters.push(s);\n      target.filters = filters;\n    }\n    e = s.clone();\n    if (v.tint != null) {\n      c = gsap.utils.splitColor(v.tint);\n      a = v.tintAmount != null ? +v.tintAmount : 1;\n      e.redOffset = +c[0] * a;\n      e.greenOffset = +c[1] * a;\n      e.blueOffset = +c[2] * a;\n      e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;\n    } else {\n      for (p in v) {\n        if (p !== "exposure") if (p !== "brightness") {\n          e[p] = +v[p];\n        }\n      }\n    }\n    if (v.exposure != null) {\n      e.redOffset = e.greenOffset = e.blueOffset = 255 * (+v.exposure - 1);\n      e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;\n    } else if (v.brightness != null) {\n      a = +v.brightness - 1;\n      e.redOffset = e.greenOffset = e.blueOffset = a > 0 ? a * 255 : 0;\n      e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);\n    }\n    i = 8;\n    while (i--) {\n      p = _colorProps[i];\n      if (s[p] !== e[p]) {\n        pt = plugin.add(s, p, s[p], e[p]);\n        if (pt) {\n          pt.op = "easel_colorFilter";\n        }\n      }\n    }\n    plugin._props.push("easel_colorFilter");\n    if (!target.cacheID) {\n      _cache(target);\n    }\n  },\n  _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n  _lumR = 0.212671,\n  _lumG = 0.715160,\n  _lumB = 0.072169,\n  _applyMatrix = (m, m2) => {\n    if (!(m instanceof Array) || !(m2 instanceof Array)) {\n      return m2;\n    }\n    let temp = [],\n      i = 0,\n      z = 0,\n      y,\n      x;\n    for (y = 0; y < 4; y++) {\n      for (x = 0; x < 5; x++) {\n        z = x === 4 ? m[i + 4] : 0;\n        temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n      }\n      i += 5;\n    }\n    return temp;\n  },\n  _setSaturation = (m, n) => {\n    if (isNaN(n)) {\n      return m;\n    }\n    let inv = 1 - n,\n      r = inv * _lumR,\n      g = inv * _lumG,\n      b = inv * _lumB;\n    return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);\n  },\n  _colorize = (m, color, amount) => {\n    if (isNaN(amount)) {\n      amount = 1;\n    }\n    let c = gsap.utils.splitColor(color),\n      r = c[0] / 255,\n      g = c[1] / 255,\n      b = c[2] / 255,\n      inv = 1 - amount;\n    return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);\n  },\n  _setHue = (m, n) => {\n    if (isNaN(n)) {\n      return m;\n    }\n    n *= Math.PI / 180;\n    let c = Math.cos(n),\n      s = Math.sin(n);\n    return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);\n  },\n  _setContrast = (m, n) => {\n    if (isNaN(n)) {\n      return m;\n    }\n    n += 0.01;\n    return _applyMatrix([n, 0, 0, 0, 128 * (1 - n), 0, n, 0, 0, 128 * (1 - n), 0, 0, n, 0, 128 * (1 - n), 0, 0, 0, 1, 0], m);\n  },\n  _parseColorMatrixFilter = (target, v, plugin) => {\n    if (!_ColorMatrixFilter) {\n      _ColorMatrixFilter = _getCreateJS().ColorMatrixFilter;\n      if (!_ColorMatrixFilter) {\n        _warn("EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn\'t loaded.");\n      }\n    }\n    let filters = target.filters || [],\n      i = filters.length,\n      matrix,\n      startMatrix,\n      s,\n      pg;\n    while (--i > -1) {\n      if (filters[i] instanceof _ColorMatrixFilter) {\n        s = filters[i];\n        break;\n      }\n    }\n    if (!s) {\n      s = new _ColorMatrixFilter(_idMatrix.slice());\n      filters.push(s);\n      target.filters = filters;\n    }\n    startMatrix = s.matrix;\n    matrix = _idMatrix.slice();\n    if (v.colorize != null) {\n      matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));\n    }\n    if (v.contrast != null) {\n      matrix = _setContrast(matrix, Number(v.contrast));\n    }\n    if (v.hue != null) {\n      matrix = _setHue(matrix, Number(v.hue));\n    }\n    if (v.saturation != null) {\n      matrix = _setSaturation(matrix, Number(v.saturation));\n    }\n    i = matrix.length;\n    while (--i > -1) {\n      if (matrix[i] !== startMatrix[i]) {\n        pg = plugin.add(startMatrix, i, startMatrix[i], matrix[i]);\n        if (pg) {\n          pg.op = "easel_colorMatrixFilter";\n        }\n      }\n    }\n    plugin._props.push("easel_colorMatrixFilter");\n    if (!target.cacheID) {\n      _cache();\n    }\n    plugin._matrix = startMatrix;\n  },\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (_windowExists()) {\n      _win = window;\n    }\n    if (gsap) {\n      _coreInitted = 1;\n    }\n  };\nconst EaselPlugin = {\n  version: "3.6.1",\n  name: "easel",\n  init(target, value, tween, index, targets) {\n    if (!_coreInitted) {\n      _initCore();\n      if (!gsap) {\n        _warn("Please gsap.registerPlugin(EaselPlugin)");\n      }\n    }\n    this.target = target;\n    let p, pt, tint, colorMatrix, end, labels, i;\n    for (p in value) {\n      end = value[p];\n      if (p === "colorFilter" || p === "tint" || p === "tintAmount" || p === "exposure" || p === "brightness") {\n        if (!tint) {\n          _parseColorFilter(target, value.colorFilter || value, this);\n          tint = true;\n        }\n      } else if (p === "saturation" || p === "contrast" || p === "hue" || p === "colorize" || p === "colorizeAmount") {\n        if (!colorMatrix) {\n          _parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);\n          colorMatrix = true;\n        }\n      } else if (p === "frame") {\n        if (typeof end === "string" && end.charAt(1) !== "=" && (labels = target.labels)) {\n          for (i = 0; i < labels.length; i++) {\n            if (labels[i].label === end) {\n              end = labels[i].position;\n            }\n          }\n        }\n        pt = this.add(target, "gotoAndStop", target.currentFrame, end, index, targets, Math.round);\n        if (pt) {\n          pt.op = p;\n        }\n      } else if (target[p] != null) {\n        this.add(target, p, "get", end);\n      }\n    }\n  },\n  render(ratio, data) {\n    let pt = data._pt;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n    if (data.target.cacheID) {\n      data.target.updateCache();\n    }\n  },\n  register: _initCore\n};\nEaselPlugin.registerCreateJS = createjs => {\n  _createJS = createjs;\n};\n_getGSAP() && gsap.registerPlugin(EaselPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/EaselPlugin.js?')},"./build/scripts/vendor/gsap/src/Flip.js":
/*!***********************************************!*\
  !*** ./build/scripts/vendor/gsap/src/Flip.js ***!
  \***********************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Flip: () => (/* binding */ Flip),\n/* harmony export */   "default": () => (/* binding */ Flip)\n/* harmony export */ });\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ "./build/scripts/vendor/gsap/src/utils/matrix.js");\n/*!\n * Flip 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet _id = 1,\n  _toArray,\n  gsap,\n  _RAD2DEG = 180 / Math.PI,\n  _DEG2RAD = Math.PI / 180,\n  _emptyObj = {},\n  _dashedNameLookup = {},\n  _memoizedRemoveProps = {},\n  _callbacks = "onStart,onUpdate,onComplete,onReverseComplete,onInterrupt".split(","),\n  _removeProps = "transform,transformOrigin,width,height,position,top,left,opacity,zIndex".split(","),\n  _getEl = target => _toArray(target)[0] || console.warn("Element not found:", target),\n  _round = value => Math.round(value * 10000) / 10000 || 0,\n  _toggleClass = (targets, className, action) => targets.forEach(el => el.classList[action](className)),\n  _reserved = {\n    zIndex: 1,\n    clear: 1,\n    simple: 1,\n    spin: 1,\n    clearProps: 1,\n    targets: 1,\n    toggleClass: 1,\n    onComplete: 1,\n    onUpdate: 1,\n    onInterrupt: 1,\n    onStart: 1,\n    delay: 1,\n    repeat: 1,\n    repeatDelay: 1,\n    yoyo: 1,\n    scale: 1,\n    fade: 1,\n    absolute: 1,\n    props: 1,\n    onEnter: 1,\n    onLeave: 1,\n    custom: 1,\n    paused: 1,\n    nested: 1\n  },\n  _fitReserved = {\n    zIndex: 1,\n    simple: 1,\n    clearProps: 1,\n    scale: 1,\n    absolute: 1,\n    fitChild: 1,\n    getVars: 1,\n    props: 1\n  },\n  _camelToDashed = p => p.replace(/([A-Z])/g, "-$1").toLowerCase(),\n  _listToArray = list => typeof list === "string" ? list.split(" ").join("").split(",") : list,\n  // removes extra spaces contaminating the names, returns an Array.\n  _closestTenth,\n  _bonusValidated = 1,\n  //<name>Flip</name>\n  _copy = (obj, exclude) => {\n    let result = {},\n      p;\n    for (p in obj) {\n      exclude[p] || (result[p] = obj[p]);\n    }\n    return result;\n  },\n  _memoizedProps = {},\n  _memoizeProps = props => {\n    let p = _memoizedProps[props] = _listToArray(props);\n    _memoizedRemoveProps[props] = p.concat(_removeProps);\n    return p;\n  },\n  _getInverseGlobalMatrix = el => {\n    // integrates caching for improved performance\n    let cache = el._gsap || gsap.core.getCache(el);\n    if (cache.gmCache === gsap.ticker.frame) {\n      return cache.gMatrix;\n    }\n    cache.gmCache = gsap.ticker.frame;\n    return cache.gMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, true, false, true);\n  },\n  _getDOMDepth = function (el, invert) {\n    let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    // In invert is true, the sibling depth is increments of 1, and parent/nesting depth is increments of 1000. This lets us order elements in an Array to reflect document flow.\n    let parent = el.parentNode,\n      inc = 1000 * 10 ** level * (invert ? -1 : 1),\n      l = invert ? -inc * 900 : 0;\n    while (el) {\n      l += inc;\n      el = el.previousSibling;\n    }\n    return parent ? l + _getDOMDepth(parent, invert, level + 1) : l;\n  },\n  _orderByDOMDepth = (comps, invert, isElStates) => {\n    comps.forEach(comp => comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert));\n    comps.sort((c1, c2) => c1.d - c2.d);\n    return comps;\n  },\n  _recordInlineStyles = (elState, props) => {\n    // records the current inline CSS properties into an Array in alternating name/value pairs that\'s stored in a "css" property on the state object so that we can revert later.\n    let style = elState.element.style,\n      a = elState.css = elState.css || [],\n      i = props.length,\n      p,\n      v;\n    while (i--) {\n      p = props[i];\n      v = style[p] || style.getPropertyValue(p);\n      a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);\n    }\n    return style;\n  },\n  _applyInlineStyles = state => {\n    let css = state.css,\n      style = state.element.style,\n      i = 0;\n    state.cache.uncache = 1;\n    for (; i < css.length; i += 2) {\n      css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);\n    }\n  },\n  _setFinalStates = (comps, onlyTransforms) => {\n    let i = comps.length,\n      comp;\n    while (i--) {\n      comp = comps[i];\n      comp.a.cache.uncache = 1;\n    }\n    onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);\n  },\n  _makeAbsolute = (elState, fallbackNode) => {\n    let {\n        element,\n        width,\n        height,\n        uncache,\n        getProp\n      } = elState,\n      style = element.style,\n      result,\n      displayIsNone;\n    typeof fallbackNode !== "object" && (fallbackNode = elState);\n    if (getProp("position") !== "absolute") {\n      displayIsNone = getProp("display") === "none";\n      if (!elState.isVisible || displayIsNone) {\n        displayIsNone && (_recordInlineStyles(elState, ["display"]).display = fallbackNode.display);\n        elState.matrix = fallbackNode.matrix;\n        elState.width = width = elState.width || fallbackNode.width;\n        elState.height = height = elState.height || fallbackNode.height;\n      }\n      style.position = "absolute";\n      style.width = width + "px";\n      style.height = height + "px";\n      style.top || (style.top = "0px");\n      style.left || (style.left = "0px");\n      if (uncache) {\n        result = new ElementState(element);\n      } else {\n        // better performance\n        result = _copy(elState, _emptyObj);\n        if (elState.simple) {\n          let bounds = element.getBoundingClientRect();\n          result.matrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)());\n        } else {\n          result.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n        }\n      }\n      result = _fit(result, elState, true);\n      elState.x = parseFloat(result.x);\n      elState.y = parseFloat(result.y);\n    }\n    return element;\n  },\n  _findElStateInState = (state, other) => other && state.idLookup[_parseElementState(other).id] || state.elementStates[0],\n  _parseElementState = (elOrNode, props, simple, other) => elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === "string" ? _getEl(elOrNode) || console.warn(elOrNode + " not found") : elOrNode, props, simple),\n  _recordProps = (elState, props) => {\n    let getProp = gsap.getProperty(elState.element, null, "native"),\n      obj = elState.props = {},\n      i = props.length;\n    while (i--) {\n      obj[props[i]] = (getProp(props[i]) + "").trim();\n    }\n    obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);\n    return elState;\n  },\n  _applyProps = (element, props) => {\n    let style = element.style || element,\n      // could pass in a vars object.\n      p;\n    for (p in props) {\n      style[p] = props[p];\n    }\n  },\n  _getID = el => {\n    let id = el.getAttribute("data-flip-id");\n    id || el.setAttribute("data-flip-id", id = "auto-" + _id++);\n    return id;\n  },\n  _getCTMInverse = el => el.getCTM && el.nodeName.toLowerCase() === "svg" && el.getCTM().inverse(),\n  _elementsFromElementStates = elStates => elStates.map(elState => elState.element),\n  _handleCallback = (callback, elStates, tl) => callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0),\n  _fit = (fromState, toState, scale, applyProps, fitChild, vars) => {\n    let {\n        element,\n        cache,\n        parent,\n        x,\n        y\n      } = fromState,\n      {\n        width,\n        height,\n        scaleX,\n        scaleY,\n        rotation\n      } = toState,\n      cssText = vars && element.style.cssText,\n      dimensionState = fromState,\n      {\n        e,\n        f\n      } = toState.matrix,\n      deep = fromState.width !== width || fromState.height !== height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation,\n      simple = !deep && fromState.simple && toState.simple && !fitChild,\n      skewX,\n      fromPoint,\n      toPoint,\n      getProp,\n      parentMatrix,\n      matrix;\n    if (simple) {\n      scaleX = scaleY = 1;\n      rotation = skewX = 0;\n    } else {\n      parentMatrix = _getInverseGlobalMatrix(parent);\n      matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix); // root SVG elements have a ctm that we must factor out (for example, viewBox:"0 0 94 94" with a width of 200px would scale the internals by 2.127 but when we\'re matching the size of the root <svg> element itself, that scaling shouldn\'t factor in!)\n      rotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);\n      skewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360; // in very rare cases, minor rounding might end up with 360 which should be 0.\n      scaleX = Math.sqrt(matrix.a ** 2 + matrix.b ** 2);\n      scaleY = Math.sqrt(matrix.c ** 2 + matrix.d ** 2) * Math.cos(skewX * _DEG2RAD);\n      if (fitChild) {\n        getProp = gsap.getProperty(fitChild);\n        dimensionState = {\n          scaleX: getProp("scaleX"),\n          scaleY: getProp("scaleY"),\n          width: Math.ceil(parseFloat(getProp("width", "px"))),\n          height: parseFloat(getProp("height", "px"))\n        };\n      }\n      cache.rotation = rotation + "deg";\n      cache.skewX = skewX + "deg";\n    }\n    if (scale) {\n      scaleX *= width / dimensionState.width;\n      scaleY *= height / dimensionState.height;\n      cache.scaleX = scaleX;\n      cache.scaleY = scaleY;\n    } else {\n      width *= scaleX / dimensionState.scaleX;\n      height *= scaleY / dimensionState.scaleY;\n      element.style.width = width + "px";\n      element.style.height = height + "px";\n    }\n    if (fromState.position === "fixed") {\n      e -= (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)();\n      f -= (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)();\n    }\n    if (toState.position === "fixed") {\n      e += (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)();\n      f += (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)();\n    }\n    applyProps && _applyProps(element, toState.props);\n    if (simple) {\n      x += e - fromState.matrix.e;\n      y += f - fromState.matrix.f;\n    } else if (deep || parent !== toState.parent) {\n      cache.renderTransform(1, cache);\n      matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fitChild || element, false, false, true);\n      fromPoint = parentMatrix.apply({\n        x: matrix.e,\n        y: matrix.f\n      });\n      toPoint = parentMatrix.apply({\n        x: e,\n        y: f\n      });\n      x += _round(toPoint.x - fromPoint.x);\n      y += _round(toPoint.y - fromPoint.y);\n    } else {\n      // use a faster/cheaper algorithm if we\'re just moving x/y\n      parentMatrix.e = parentMatrix.f = 0;\n      toPoint = parentMatrix.apply({\n        x: e - fromState.matrix.e,\n        y: f - fromState.matrix.f\n      });\n      x += _round(toPoint.x);\n      y += _round(toPoint.y);\n    }\n    if (vars && !(vars instanceof ElementState)) {\n      // revert\n      element.style.cssText = cssText;\n      cache.uncache = 1;\n    } else {\n      // or apply the transform immediately\n      cache.x = x + "px";\n      cache.y = y + "px";\n      cache.renderTransform(1, cache);\n    }\n    if (vars) {\n      vars.x = x;\n      vars.y = y;\n      vars.rotation = rotation;\n      vars.skewX = skewX;\n      if (scale) {\n        vars.scaleX = scaleX;\n        vars.scaleY = scaleY;\n      } else {\n        vars.width = width;\n        vars.height = height;\n      }\n    }\n    return vars || cache;\n  },\n  _parseState = (targetsOrState, vars) => targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars),\n  _getChangingElState = (toState, fromState, id) => {\n    let to1 = toState.idLookup[id],\n      to2 = toState.alt[id];\n    return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;\n  },\n  _fromTo = (fromState, toState, vars, relative) => {\n    // relative is -1 if "from()", and 1 if "to()"\n    if (!_bonusValidated) {\n      return;\n    }\n    fromState instanceof FlipState && toState instanceof FlipState || console.warn("Not a valid state object.");\n    vars = vars || {};\n    let {\n        clearProps,\n        onEnter,\n        onLeave,\n        absolute,\n        custom,\n        delay,\n        paused,\n        repeat,\n        repeatDelay,\n        yoyo,\n        toggleClass,\n        nested,\n        zIndex,\n        scale,\n        fade,\n        stagger,\n        spin\n      } = vars,\n      props = ("props" in vars ? vars : fromState).props,\n      tweenVars = _copy(vars, _reserved),\n      animation = gsap.timeline({\n        delay,\n        paused,\n        repeat,\n        repeatDelay,\n        yoyo\n      }),\n      remainingProps = tweenVars,\n      entering = [],\n      leaving = [],\n      comps = [],\n      swapOutTargets = [],\n      spinNum = spin === true ? 1 : spin || 0,\n      spinFunc = typeof spin === "function" ? spin : () => spinNum,\n      interrupted = fromState.interrupted || toState.interrupted,\n      addFunc = animation[relative !== 1 ? "to" : "from"],\n      v,\n      p,\n      endTime,\n      i,\n      el,\n      comp,\n      state,\n      targets,\n      finalStates,\n      fromNode,\n      toNode;\n    relative || (toState = new FlipState(toState.targets, props).fit(toState, scale));\n    for (p in toState.idLookup) {\n      toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);\n      el = toNode.element;\n      fromNode = fromState.idLookup[p];\n      fromState.alt[p] && el === fromNode.element && (fromNode = fromState.alt[p]);\n      if (fromNode) {\n        comp = {\n          t: el,\n          b: fromNode,\n          a: toNode,\n          sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1\n        };\n        comps.push(comp);\n        if (comp.sd) {\n          if (comp.sd < 0) {\n            comp.b = toNode;\n            comp.a = fromNode;\n          }\n          //comp.fb = fromState.getElementState(el) || comp.b; // fallback? Might need to be something other than the before state, like making sure we use the values from the same element.\n          fade && comps.push(comp.swap = {\n            t: fromNode.element,\n            b: comp.b,\n            a: comp.a,\n            sd: comp.sd * -1,\n            swap: comp\n          });\n        }\n        el._flip = fromNode.element._flip = animation;\n      } else if (toNode.isVisible) {\n        comps.push({\n          t: el,\n          b: _copy(toNode, {\n            isVisible: 1\n          }),\n          a: toNode,\n          sd: 0\n        }); // to include it in the "entering" Array and do absolute positioning if necessary\n        el._flip = animation;\n      }\n    }\n    props && (_memoizedProps[props] || _memoizeProps(props)).forEach(p => tweenVars[p] = i => comps[i].a.props[p]);\n    comps.finalStates = finalStates = [];\n    absolute && _orderByDOMDepth(comps, true).forEach(c => (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b)); // when making absolute, we must go in a very particular order so that document flow changes don\'t affect things. Don\'t make it visible if both the before and after states are invisible! There\'s no point, and it could make things appear visible during the flip that shouldn\'t be.\n    _orderByDOMDepth(comps);\n\n    // TODO: cache the matrix, especially for parent because it\'ll probably get reused quite a bit, but lock it to a particular cycle(?).\n    for (i = 0; i < comps.length; i++) {\n      comp = comps[i];\n      el = comp.t;\n      nested && !(comp.sd < 0) && (comp.a.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true)); // moving a parent affects the position of children\n      if (comp.sd || comp.b.isVisible && comp.a.isVisible) {\n        if (comp.sd < 0) {\n          // swapping OUT (swap direction of -1 is out)\n          state = new ElementState(el, props, fromState.simple);\n          _fit(state, comp.a, scale, 0, 0, state);\n          state.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true);\n          state.css = comp.b.css;\n          comp.a = state;\n          fade && (el.style.opacity = interrupted ? comp.b.opacity : comp.a.opacity);\n          stagger && swapOutTargets.push(el);\n        } else if (comp.sd > 0 && fade) {\n          // swapping IN (swap direction of 1 is in)\n          el.style.opacity = interrupted ? comp.a.opacity - comp.b.opacity : "0";\n        }\n        _fit(comp.a, comp.b, scale, props);\n      } else {\n        // either entering or leaving (one side is invisible)\n        if (!comp.b.isVisible) {\n          // entering\n          comp.a.isVisible && entering.push(comp.a);\n          comps.splice(i--, 1);\n        } else if (!comp.a.isVisible) {\n          // leaving\n          comp.b.css = comp.a.css;\n          leaving.push(comp.b);\n          comps.splice(i--, 1);\n          absolute && nested && _fit(comp.a, comp.b, scale, props);\n        }\n      }\n      finalStates.push(comp.a);\n    }\n    if (scale) {\n      tweenVars.scaleX = i => comps[i].a.scaleX;\n      tweenVars.scaleY = i => comps[i].a.scaleY;\n    } else {\n      tweenVars.width = i => comps[i].a.width + "px";\n      tweenVars.height = i => comps[i].a.height + "px";\n      tweenVars.autoRound = vars.autoRound || false;\n    }\n    tweenVars.x = i => comps[i].a.x + "px";\n    tweenVars.y = i => comps[i].a.y + "px";\n    tweenVars.rotation = i => comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);\n    tweenVars.skewX = i => comps[i].a.skewX;\n    targets = comps.map(c => c.t);\n    if (zIndex || zIndex === 0) {\n      tweenVars.modifiers = {\n        zIndex: () => zIndex\n      };\n      tweenVars.zIndex = zIndex;\n      tweenVars.immediateRender = vars.immediateRender !== false;\n    }\n    fade && (tweenVars.opacity = i => comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : "+=0");\n    if (swapOutTargets.length) {\n      stagger = gsap.utils.distribute(stagger);\n      let dummyArray = targets.slice(swapOutTargets.length);\n      tweenVars.stagger = (i, el) => stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);\n    }\n\n    // // for testing...\n    // gsap.delayedCall(vars.data ? 50 : 1, function() {\n    // \tanimation.eventCallback("onComplete", () => _setFinalStates(comps, !clearProps));\n    // \taddFunc.call(animation, targets, tweenVars, 0).play();\n    // });\n    // return;\n\n    _callbacks.forEach(name => vars[name] && animation.eventCallback(name, vars[name], vars[name + "Params"])); // apply callbacks to the timeline, not tweens (because "custom" timing can make multiple tweens)\n\n    if (custom && targets.length) {\n      // bust out the custom properties as their own tweens so they can use different eases, durations, etc.\n      remainingProps = _copy(tweenVars, _reserved);\n      if ("scale" in custom) {\n        custom.scaleX = custom.scaleY = custom.scale;\n        delete custom.scale;\n      }\n      for (p in custom) {\n        v = _copy(custom[p], _fitReserved);\n        v[p] = tweenVars[p];\n        !("duration" in v) && "duration" in tweenVars && (v.duration = tweenVars.duration);\n        v.stagger = tweenVars.stagger;\n        addFunc.call(animation, targets, v, 0);\n        delete remainingProps[p];\n      }\n    }\n    if (targets.length || leaving.length || entering.length) {\n      toggleClass && animation.add(() => _toggleClass(targets, toggleClass, animation._zTime < 0 ? "remove" : "add"), 0) && !paused && _toggleClass(targets, toggleClass, "add");\n      targets.length && addFunc.call(animation, targets, remainingProps, 0);\n    }\n    _handleCallback(onEnter, entering, animation);\n    _handleCallback(onLeave, leaving, animation);\n    endTime = animation.duration();\n    animation.call(() => {\n      let forward = animation.time() >= endTime;\n      forward && _setFinalStates(comps, !clearProps);\n      toggleClass && _toggleClass(targets, toggleClass, forward ? "remove" : "add");\n    });\n    return animation;\n  },\n  _createLookup = state => {\n    let lookup = state.idLookup = {},\n      alt = state.alt = {},\n      elStates = state.elementStates,\n      i = elStates.length,\n      elState;\n    while (i--) {\n      elState = elStates[i];\n      lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;\n    }\n  };\nclass FlipState {\n  constructor(targets, vars, targetsAreElementStates) {\n    this.props = vars && vars.props;\n    this.simple = !!(vars && vars.simple);\n    if (targetsAreElementStates) {\n      this.targets = _elementsFromElementStates(targets);\n      this.elementStates = targets;\n      _createLookup(this);\n    } else {\n      this.targets = _toArray(targets);\n      this.update(!vars || vars.clear !== false);\n    }\n  }\n  update(clear) {\n    this.elementStates = this.targets.map(el => new ElementState(el, this.props, this.simple));\n    _createLookup(this);\n    this.killFlips(clear);\n    this.recordInlineStyles();\n    return this;\n  }\n  fit(state, scale, nested) {\n    let elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true),\n      toElStates = (state || this).idLookup,\n      i = 0,\n      fromNode,\n      toNode;\n    for (; i < elStatesInOrder.length; i++) {\n      fromNode = elStatesInOrder[i];\n      nested && (fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true)); // moving a parent affects the position of children\n      toNode = toElStates[fromNode.id];\n      toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);\n      fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true);\n    }\n    return this;\n  }\n  getProperty(element, property) {\n    let es = this.getElementState(element) || _emptyObj;\n    return property in es ? es[property] : (es.props || _emptyObj)[property];\n  }\n  recordInlineStyles() {\n    let props = _memoizedRemoveProps[this.props] || _removeProps,\n      i = this.elementStates.length;\n    while (i--) {\n      _recordInlineStyles(this.elementStates[i], props);\n    }\n  }\n  killFlips(clear) {\n    let found;\n    this.targets.forEach(tl => {\n      tl = tl._flip;\n      if (tl && tl.progress() < 1 && !tl.paused()) {\n        found = 1;\n        tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);\n        clear && tl.progress(1);\n        tl.kill(); // we should also kill it in case it was added to a parent timeline.\n      }\n    });\n    if (found && clear) {\n      // if we found an in-progress Flip animation, we must record all the values in their current state at that point BUT we should update the isVisible value AFTER pushing that flip to completion so that elements that are entering or leaving will populate those Arrays properly.\n      this.elementStates.forEach(es => {\n        let b = es.element.getBoundingClientRect();\n        es.isVisible = b.width || b.height || b.top || b.left;\n        es.uncache = 1;\n      });\n    }\n    this.interrupted = !!found;\n  }\n  getElementState(element) {\n    return this.elementStates[this.targets.indexOf(_getEl(element))];\n  }\n  makeAbsolute() {\n    return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);\n  }\n}\nclass ElementState {\n  constructor(element, props, simple) {\n    this.element = element;\n    this.update(props, simple);\n  }\n  update(props, simple) {\n    let element = this.element,\n      getProp = gsap.getProperty(element),\n      cache = gsap.core.getCache(element),\n      bounds = element.getBoundingClientRect(),\n      m = simple ? new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)()) : (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);\n    this.getProp = getProp;\n    this.element = element;\n    this.id = _getID(element);\n    this.matrix = m;\n    this.cache = cache;\n    this.bounds = bounds;\n    this.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);\n    this.display = getProp("display");\n    this.position = getProp("position");\n    this.parent = element.parentNode;\n    this.x = getProp("x");\n    this.y = getProp("y");\n    this.scaleX = cache.scaleX;\n    this.scaleY = cache.scaleY;\n    this.rotation = getProp("rotation");\n    this.skewX = getProp("skewX");\n    this.opacity = getProp("opacity");\n    this.width = _closestTenth(parseFloat(getProp("width", "px")) + 0.04); // round up to the closest 0.25 so that text doesn\'t wrap.\n    this.height = parseFloat(getProp("height", "px"));\n    props && _recordProps(this, _memoizedProps[props] || _memoizeProps(props));\n    this.ctm = _getCTMInverse(element);\n    this.simple = simple || _round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1; // allows us to speed through some other tasks if it\'s not scale/rotated\n    this.uncache = 0;\n  }\n}\nclass Flip {\n  static getState(targets, vars) {\n    return _parseState(targets, typeof vars === "string" ? {\n      props: vars\n    } : vars);\n  }\n  static from(state, vars) {\n    vars = vars || {};\n    "clearProps" in vars || (vars.clearProps = true);\n    return _fromTo(state, _parseState(vars.targets || state.targets, {\n      props: vars.props || state.props,\n      simple: vars.simple,\n      clear: !!vars.clear\n    }), vars, -1);\n  }\n  static to(state, vars) {\n    return _fromTo(state, _parseState(vars.targets || state.targets, {\n      props: vars.props || state.props,\n      simple: vars.simple,\n      clear: !!vars.clear\n    }), vars, 1);\n  }\n  static fromTo(fromState, toState, vars) {\n    return _fromTo(fromState, toState, vars);\n  }\n  static fit(fromEl, toEl, vars) {\n    if (!_bonusValidated) {\n      return;\n    }\n    let v = vars ? _copy(vars, _fitReserved) : {},\n      {\n        absolute,\n        scale,\n        getVars,\n        props,\n        runBackwards,\n        onComplete,\n        simple\n      } = vars || v,\n      fitChild = vars && vars.fitChild && _getEl(vars.fitChild),\n      before = _parseElementState(toEl, props, simple, fromEl),\n      after = _parseElementState(fromEl, 0, simple, before),\n      inlineProps = props ? _memoizedRemoveProps[props] : _removeProps;\n    props && _applyProps(v, before.props);\n    if (runBackwards) {\n      _recordInlineStyles(after, inlineProps);\n      "immediateRender" in v || (v.immediateRender = true);\n      v.onComplete = function () {\n        _applyInlineStyles(after);\n        onComplete && onComplete.apply(this, arguments);\n      };\n    }\n    absolute && _makeAbsolute(after, before);\n    v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);\n    return getVars ? v : v.duration ? gsap.to(after.element, v) : null;\n  }\n  static makeAbsolute(targetsOrStates, vars) {\n    return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();\n  }\n  static isFlipping(target) {\n    let f = Flip.getByTarget(target);\n    return !!f && f.isActive();\n  }\n  static getByTarget(target) {\n    return (_getEl(target) || _emptyObj)._flip;\n  }\n  static getElementState(target, props) {\n    return new ElementState(_getEl(target), props);\n  }\n  static convertCoordinates(fromElement, toElement, point) {\n    let m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromElement));\n    return point ? m.apply(point) : m;\n  }\n  static register(core) {\n    gsap = core;\n    (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._setDoc)(document.body);\n    _toArray = gsap.utils.toArray;\n    _closestTenth = gsap.utils.snap(0.1);\n  }\n}\n\n// function whenImagesLoad(el, func) {\n// \tlet pending = [],\n// \t\tonLoad = e => {\n// \t\t\tpending.splice(pending.indexOf(e.target), 1);\n// \t\t\te.target.removeEventListener("load", onLoad);\n// \t\t\tpending.length || func();\n// \t\t};\n// \tgsap.utils.toArray(el.tagName.toLowerCase() === "img" ? el : el.querySelectorAll("img")).forEach(img => img.complete || img.addEventListener("load", onLoad) || pending.push(img));\n// \tpending.length || func();\n// }\n\ntypeof window !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/Flip.js?')},"./build/scripts/vendor/gsap/src/GSDevTools.js":
/*!*****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/GSDevTools.js ***!
  \*****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GSDevTools: () => (/* binding */ GSDevTools),\n/* harmony export */   "default": () => (/* binding */ GSDevTools)\n/* harmony export */ });\n/* harmony import */ var _Draggable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draggable.js */ "./build/scripts/vendor/gsap/src/Draggable.js");\n/*!\n * GSDevTools 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet gsap,\n  _coreInitted,\n  _doc,\n  _docEl,\n  _win,\n  _recordedRoot,\n  Animation,\n  _rootTween,\n  _rootInstance,\n  _rootIsDirty,\n  _keyboardInstance,\n  _globalTimeline,\n  _independentRoot,\n  _delayedCall,\n  _recording = true,\n  _startupPhase = true,\n  //for the first 2 seconds, we don\'t record any zero-duration tweens because they\'re typically just setup stuff and/or the "from" or "startAt" tweens. In version 1.20.3 we started flagging those with data:"isStart"|"isFromStart" but this logic helps GSDevTools work with older versions too.\n  _globalStartTime = 0,\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isString = value => typeof value === "string",\n  _isFunction = value => typeof value === "function",\n  _isObject = value => typeof value === "object",\n  _isUndefined = value => typeof value === "undefined",\n  _bonusValidated = 1,\n  //<name>GSDevTools</name>\n  _svgNS = "http://www.w3.org/2000/svg",\n  _domNS = "http://www.w3.org/1999/xhtml",\n  _idSeed = 0,\n  //we assign an ID to each GSDevTools instance so that we can segregate the sessionStorage data accordingly.\n  _lookup = {},\n  _supportsStorage = function () {\n    try {\n      sessionStorage.setItem("gsTest", "1");\n      sessionStorage.removeItem("gsTest");\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }(),\n  _parseAnimation = animationOrId => animationOrId instanceof Animation ? animationOrId : animationOrId ? gsap.getById(animationOrId) : null,\n  _createElement = (type, container, cssText) => {\n    let element = _doc.createElementNS ? _doc.createElementNS(type === "svg" ? _svgNS : _domNS, type) : _doc.createElement(type);\n    if (container) {\n      if (_isString(container)) {\n        container = _doc.querySelector(container);\n      }\n      container.appendChild(element);\n    }\n    if (type === "svg") {\n      element.setAttribute("xmlns", _svgNS);\n      element.setAttribute("xmlns:xlink", _domNS);\n    }\n    cssText && (element.style.cssText = cssText);\n    return element;\n  },\n  _clearSelection = () => {\n    if (_doc.selection) {\n      _doc.selection.empty();\n    } else if (_win.getSelection) {\n      _win.getSelection().removeAllRanges();\n    }\n  },\n  _getChildrenOf = (timeline, includeTimelines) => {\n    let a = [],\n      cnt = 0,\n      Tween = gsap.core.Tween,\n      tween = timeline._first;\n    while (tween) {\n      if (tween instanceof Tween) {\n        if (tween.vars.id) {\n          a[cnt++] = tween;\n        }\n      } else {\n        if (includeTimelines && tween.vars.id) {\n          a[cnt++] = tween;\n        }\n        a = a.concat(_getChildrenOf(tween, includeTimelines));\n        cnt = a.length;\n      }\n      tween = tween._next;\n    }\n    return a;\n  },\n  _getClippedDuration = (animation, excludeRootRepeats) => {\n    let max = 0,\n      repeat = Math.max(0, animation._repeat),\n      t = animation._first;\n    if (!t) {\n      max = animation.duration();\n    }\n    while (t) {\n      max = Math.max(max, t.totalDuration() > 999 ? t.endTime(false) : t._start + t._tDur / t._ts);\n      t = t._next;\n    }\n    return !excludeRootRepeats && repeat ? max * (repeat + 1) + animation._rDelay * repeat : max;\n  },\n  _globalizeTime = function (animation, rawTime) {\n    let a = animation,\n      time = arguments.length > 1 ? +rawTime : a.rawTime();\n    while (a) {\n      time = a._start + time / (a._ts || 1);\n      a = a.parent;\n    }\n    return time;\n  },\n  _timeToProgress = (time, animation, defaultValue, relativeProgress) => {\n    let add, i, a;\n    if (_isString(time)) {\n      if (time.charAt(1) === "=") {\n        add = parseInt(time.charAt(0) + "1", 10) * parseFloat(time.substr(2));\n        if (add < 0 && relativeProgress === 0) {\n          //if something like inTime:"-=2", we measure it from the END, not the beginning\n          relativeProgress = 100;\n        }\n        time = relativeProgress / 100 * animation.duration() + add;\n      } else if (isNaN(time) && animation.labels && animation.labels[time] !== -1) {\n        time = animation.labels[time];\n      } else if (animation === _recordedRoot) {\n        //perhaps they defined an id of an animation, like "myAnimation+=2"\n        i = time.indexOf("=");\n        if (i > 0) {\n          add = parseInt(time.charAt(i - 1) + "1", 10) * parseFloat(time.substr(i + 1));\n          time = time.substr(0, i - 1);\n        } else {\n          add = 0;\n        }\n        a = gsap.getById(time);\n        if (a) {\n          time = _globalizeTime(a, defaultValue / 100 * a.duration()) + add;\n        }\n      }\n    }\n    time = isNaN(time) ? defaultValue : parseFloat(time);\n    return Math.min(100, Math.max(0, time / animation.duration() * 100));\n  },\n  _addedCSS,\n  _createRootElement = (element, minimal, css) => {\n    if (!_addedCSS) {\n      _createElement("style", _docEl).innerHTML = \'.gs-dev-tools{height:51px;bottom:0;left:0;right:0;display:block;position:fixed;overflow:visible;padding:0}.gs-dev-tools *{box-sizing:content-box;visibility:visible}.gs-dev-tools .gs-top{position:relative;z-index:499}.gs-dev-tools .gs-bottom{display:flex;align-items:center;justify-content:space-between;background-color:rgba(0,0,0,.6);height:42px;border-top:1px solid #999;position:relative}.gs-dev-tools .timeline{position:relative;height:8px;margin-left:15px;margin-right:15px;overflow:visible}.gs-dev-tools .progress-bar,.gs-dev-tools .timeline-track{height:8px;width:100%;position:absolute;top:0;left:0}.gs-dev-tools .timeline-track{background-color:#999;opacity:.6}.gs-dev-tools .progress-bar{background-color:#91e600;height:8px;top:0;width:0;pointer-events:none}.gs-dev-tools .seek-bar{width:100%;position:absolute;height:24px;top:-12px;left:0;background-color:transparent}.gs-dev-tools .in-point,.gs-dev-tools .out-point{width:15px;height:26px;position:absolute;top:-18px}.gs-dev-tools .in-point-shape{fill:#6d9900;stroke:rgba(0,0,0,.5);stroke-width:1}.gs-dev-tools .out-point-shape{fill:#994242;stroke:rgba(0,0,0,.5);stroke-width:1}.gs-dev-tools .in-point{transform:translateX(-100%)}.gs-dev-tools .out-point{left:100%}.gs-dev-tools .grab{stroke:rgba(255,255,255,.3);stroke-width:1}.gs-dev-tools .playhead{position:absolute;top:-5px;transform:translate(-50%,0);left:0;border-radius:50%;width:16px;height:16px;border:1px solid #6d9900;background-color:#91e600}.gs-dev-tools .gs-btn-white{fill:#fff}.gs-dev-tools .pause{opacity:0}.gs-dev-tools .select-animation{vertical-align:middle;position:relative;padding:6px 10px}.gs-dev-tools .select-animation-container{flex-grow:4;width:40%}.gs-dev-tools .select-arrow{display:inline-block;width:12px;height:7px;margin:0 7px;transform:translate(0,-2px)}.gs-dev-tools .select-arrow-shape{stroke:rgba(255,255,255,.6);stroke-width:2px;fill:none}.gs-dev-tools .rewind{height:16px;width:19px;padding:10px 4px;min-width:24px}.gs-dev-tools .rewind-path{opacity:.6}.gs-dev-tools .play-pause{width:24px;height:24px;padding:6px 10px;min-width:24px}.gs-dev-tools .ease{width:30px;height:30px;padding:10px;min-width:30px;display:none}.gs-dev-tools .ease-path{fill:none;stroke:rgba(255,255,255,.6);stroke-width:2px}.gs-dev-tools .ease-border{fill:rgba(255,255,255,.25)}.gs-dev-tools .time-scale{font-family:monospace;font-size:18px;text-align:center;color:rgba(255,255,255,.6);padding:4px 4px 4px 0;min-width:30px;margin-left:7px}.gs-dev-tools .loop{width:20px;padding:5px;min-width:20px}.gs-dev-tools .loop-path{fill:rgba(255,255,255,.6)}.gs-dev-tools label span{color:#fff;font-family:monospace;text-decoration:none;font-size:16px;line-height:18px}.gs-dev-tools .time-scale span{color:rgba(255,255,255,.6)}.gs-dev-tools button:focus,.gs-dev-tools select:focus{outline:0}.gs-dev-tools label{position:relative;cursor:pointer}.gs-dev-tools label.locked{text-decoration:none;cursor:auto}.gs-dev-tools label input,.gs-dev-tools label select{position:absolute;left:0;top:0;z-index:1;font:inherit;font-size:inherit;line-height:inherit;height:100%;width:100%;color:#000!important;opacity:0;background:0 0;border:none;padding:0;margin:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer}.gs-dev-tools label input+.display{position:relative;z-index:2}.gs-dev-tools .gs-bottom-right{vertical-align:middle;display:flex;align-items:center;flex-grow:4;width:40%;justify-content:flex-end}.gs-dev-tools .time-container{font-size:18px;font-family:monospace;color:rgba(255,255,255,.6);margin:0 5px}.gs-dev-tools .logo{width:32px;height:32px;position:relative;top:2px;margin:0 12px}.gs-dev-tools .gs-hit-area{background-color:transparent;width:100%;height:100%;top:0;position:absolute}.gs-dev-tools.minimal{height:auto;display:flex;align-items:stretch}.gs-dev-tools.minimal .gs-top{order:2;flex-grow:4;background-color:rgba(0,0,0,1)}.gs-dev-tools.minimal .gs-bottom{background-color:rgba(0,0,0,1);border-top:none}.gs-dev-tools.minimal .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools.minimal .in-point,.gs-dev-tools.minimal .out-point{display:none}.gs-dev-tools.minimal .select-animation-container{display:none}.gs-dev-tools.minimal .rewind{display:none}.gs-dev-tools.minimal .play-pause{width:20px;height:20px;padding:4px 6px;margin-left:14px}.gs-dev-tools.minimal .time-scale{min-width:26px}.gs-dev-tools.minimal .loop{width:18px;min-width:18px;display:none}.gs-dev-tools.minimal .gs-bottom-right{display:none}@media only screen and (max-width:600px){.gs-dev-tools{height:auto;display:flex;align-items:stretch}.gs-dev-tools .gs-top{order:2;flex-grow:4;background-color:rgba(0,0,0,1);height:42px}.gs-dev-tools .gs-bottom{background-color:rgba(0,0,0,1);border-top:none}.gs-dev-tools .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools .in-point,.gs-dev-tools .out-point{display:none}.gs-dev-tools .select-animation-container{display:none}.gs-dev-tools .rewind{display:none}.gs-dev-tools .play-pause{width:20px;height:20px;padding:4px 6px;margin-left:14px}.gs-dev-tools .time-scale{min-width:26px}.gs-dev-tools .loop{width:18px;min-width:18px;display:none}.gs-dev-tools .gs-bottom-right{display:none}}\';\n      _addedCSS = true;\n    }\n    if (_isString(element)) {\n      element = _doc.querySelector(element);\n    }\n    let root = _createElement("div", element || _docEl.getElementsByTagName("body")[0] || _docEl);\n    root.setAttribute("class", "gs-dev-tools" + (minimal ? " minimal" : ""));\n    root.innerHTML = \'<div class=gs-hit-area></div><div class=gs-top><div class=timeline><div class=timeline-track></div><div class=progress-bar></div><div class=seek-bar></div><svg class=in-point viewBox="0 0 15 26" xmlns=http://www.w3.org/2000/svg><polygon class=in-point-shape points=".5 .5 14.5 .5 14.5 25.5 .5 17.5"/><polyline class=grab points="5.5 4 5.5 15"/><polyline class=grab points="9.5 4 9.5 17"/></svg><svg class=out-point viewBox="0 0 15 26" xmlns=http://www.w3.org/2000/svg><polygon class=out-point-shape points=".5 .5 14.5 .5 14.5 17.5 .5 25.5"/><polyline class=grab points="5.5 4 5.5 17"/><polyline class=grab points="9.5 4 9.5 15"/></svg><div class=playhead></div></div></div><div class=gs-bottom><div class=select-animation-container><label class=select-animation><select class=animation-list><option>Global Timeline<option>myTimeline</select><nobr><span class="display animation-label">Global Timeline</span><svg class=select-arrow viewBox="0 0 12.05 6.73" xmlns=http://www.w3.org/2000/svg><polyline class=select-arrow-shape points="0.35 0.35 6.03 6.03 11.7 0.35"/></svg></nobr></label></div><svg class=rewind viewBox="0 0 12 15.38" xmlns=http://www.w3.org/2000/svg><path d=M0,.38H2v15H0Zm2,7,10,7.36V0Z class="gs-btn-white rewind-path"/></svg><svg class=play-pause viewBox="0 0 20.97 25.67" xmlns=http://www.w3.org/2000/svg><g class=play><path d="M8,4.88 C8,10.18 8,15.48 8,20.79 5.33,22.41 2.66,24.04 0,25.67 0,17.11 0,8.55 0,0 2.66,1.62 5.33,3.25 8,4.88" class="gs-btn-white play-1" style=stroke:#fff;stroke-width:.6px /><path d="M14.485,8.855 C16.64,10.18 18.8,11.5 20.97,12.83 16.64,15.48 12.32,18.13 8,20.79 8,15.48 8,10.18 8,4.88 10.16,6.2 12.32,7.53 14.48,8.85" class="gs-btn-white play-2" style=stroke:#fff;stroke-width:.6px /></g></svg> <svg class=loop viewBox="0 0 29 25.38" xmlns=http://www.w3.org/2000/svg><path d=M27.44,5.44,20.19,0V3.06H9.06A9.31,9.31,0,0,0,0,12.41,9.74,9.74,0,0,0,.69,16l3.06-2.23a6,6,0,0,1-.12-1.22,5.49,5.49,0,0,1,5.43-5.5H20.19v3.81Z class=loop-path /><path d=M25.25,11.54a5.18,5.18,0,0,1,.12,1.12,5.41,5.41,0,0,1-5.43,5.41H9.19V14.5L1.94,19.94l7.25,5.44V22.06H19.94A9.2,9.2,0,0,0,29,12.84a9.42,9.42,0,0,0-.68-3.53Z class=loop-path /></svg> <svg class=ease viewBox="0 0 25.67 25.67" xmlns=http://www.w3.org/2000/svg><path d=M.48,25.12c1.74-3.57,4.28-12.6,8.8-10.7s4.75,1.43,6.5-1.11S19.89,1.19,25.2.55 class=ease-path /><path d=M24.67,1V24.67H1V1H24.67m1-1H0V25.67H25.67V0Z class=ease-border /></svg><label class=time-scale><select><option value=10>10x<option value=5>5x<option value=2>2x<option value=1 selected>1x<option value=0.5>0.5x<option value=0.25>0.25x<option value=0.1>0.1x</select><span class="display time-scale-label">1x</span></label><div class=gs-bottom-right><div class=time-container><span class=time>0.00</span> / <span class=duration>0.00</span></div><a href="https://greensock.com/docs/v3/Plugins/GSDevTools?source=GSDevTools" target=_blank title=Docs><svg class=logo viewBox="0 0 100 100" xmlns=http://www.w3.org/2000/svg><path d="M60 15.4c-.3-.4-.5-.6-.5-.7.1-.6.2-1 .2-1.7v-.4c.6.6 1.3 1.3 1.8 1.7.2.2.5.3.8.3.2 0 .3 0 .5.1h1.6c.8 0 1.6.1 2 0 .1 0 .2 0 .3-.1.6-.3 1.4-1 2.1-1.6 0 .6.1 1.2.1 1.7v1.5c0 .3 0 .5.1.7-.1.1-.2.1-.4.2-.7.4-1.7 1-2.3.9-.5-.1-1.5-.3-2.6-.7-1.2-.3-2.4-.8-3.2-1.2 0 0-.1 0-.1-.1s-.2-.4-.4-.6zm24.6 21.9c-.5-1.7-1.9-2-4.2-.7.9-1.5 2.1-1.5 2.3-2.1.9-2.5-.6-4.6-1.2-5.3.7-1.8 1.4-4.5-1-6.8-1-1-2.4-1.2-3.6-1.1 1.8 1.7 3.4 4.4 2.5 7.2-.1.3-.9.7-1.7 1 0 0 .4 2-.3 3.5-.3.6-.8 1.5-1.3 2.6 1 .9 1.6 1 3 1.3-.9.1-1.2.4-1.2.5-.7 3 1 3.4 1.4 4.8 0 .1 0 .2.1.3v.4c-.3.3-1.4.5-2.5.5s-1.8 1-1.8 1c-.2.1-.3.3-.4.4v1c0 .1 0 .4.1.6.1.5.3 1.3.4 1.8.9.6 1.4.9 2.2 1.1.5.1 1 .2 1.5.1.3-.1.7-.3 1-.7 1.5-1.7 1.9-3.2 2.2-4.1 0-.1 0-.2.1-.2 0 .1.1.1.1.2 0 0 .1-.1.1-.2l.1-.1c1.3-1.6 2.9-4.5 2.1-7zM74.3 49.9c-.1-.3-.1-.7-.2-1.1v-.2c-.1-.2-.1-.4-.2-.6 0-.1-.1-.3-.1-.5s-.1-.5-.1-.7v-.1c0-.2-.1-.5-.1-.7-.1-.3-.1-.7-.2-1.1v-.1c0-.2 0-.3-.1-.5v-.9c0-.1 0-.2.1-.3V43h-.3c-1.1.1-3.8.4-6.7.2-1.2-.1-2.4-.3-3.6-.6-1-.3-1.8-.5-2.3-.7-1.2-.4-1.6-.6-1.8-.7 0 .2-.1.4-.1.7 0 .3-.1.5-.1.8-.1.2-.1.4-.2.6l.1.1c.5.5 1.5 1.3 1.5 2.1v.2c-.1.4-.4.5-.8.9-.1.1-.6.7-1.1 1.1l-.6.6c-.1 0-.1.1-.2.1-.1.1-.3.2-.4.3-.2.1-.7.5-.8.6-.1.1-.2.1-.3.1-2.8 8.8-2.2 13.5-1.5 16.1.1.5.3 1 .4 1.3-.4.5-.8 1-1.2 1.4-1.2 1.5-2 2.6-2.6 4.2 0 .1 0 .1-.1.2 0 .1 0 .2-.1.2-.2.5-.3 1-.4 1.5-.6 2.3-.8 4.5-.9 6.6-.1 2.4-.2 4.6-.5 6.9.7.3 3.1.9 4.7.6.2-.1 0-3.9.6-5.7l.6-1.5c.4-.9.9-1.9 1.3-3.1.3-.7.5-1.5.7-2.4.1-.5.2-1 .3-1.6V74v-.1c.1-.6.1-1.3.1-2 0-.2-.7.3-1.1.9.3-1.8 1.3-2.1 2-3.2.3-.5.6-1.1.6-2 2.5-1.7 4-3.7 5-5.7.2-.4.4-.9.6-1.4.3-.8.5-1.6.7-2.4.3-1.4.8-3.2 1.2-4.8v-.1c.4-1.2.8-2.2 1.2-2.6-.2.9-.4 1.7-.6 2.5v.2c-.6 3.5-.7 6.2-2 9.2 1 2.6 1.9 3.9 2 7.6-2 0-3.2 1.6-3.7 3.2 1.2.3 3.9.7 8.3.1h.3c.1-.5.3-1.1.5-1.5.3-.8.5-1.5.6-2.2.2-1.3.1-2.4 0-3.2 3.9-3.7 2.6-11 1.6-16.6zm.3-15.1c.1-.3.2-.6.4-.8.2-.3.3-.7.5-1 .1-.3.3-.6.4-.9.5-1.5.4-2.8.3-3.5-.1 0-.1-.1-.2-.1-.5-.2-.9-.4-1.4-.6-.1 0-.2-.1-.3-.1-3.8-1.2-7.9-.9-11.9.1-1 .2-1.9.5-2.9.1-2.3-.8-3.9-1.9-4.6-2.8l-.2-.2c-.1.2-.2.4-.4.6.2 2.3-.5 3.9-1.4 5.1.9 1.2 2.6 2.8 3.6 3.4 1.1.6 1.7.7 3.4.4-.6.7-1.1 1-1.9 1.4.1.7.2 2 .5 3.4.3.3 1.2.8 2.3 1.3.5.3 1.1.5 1.7.7.8.3 1.7.6 2.4.8.1 0 .2.1.3.1.5.1 1.1.2 1.8.2h.9c2.1 0 4.5-.2 5.4-.3h.1c-.1-2.7.2-4.6.7-6.2.2-.3.4-.7.5-1.1zm-23.2 9.3v.2c-.3 1.7.5 2.4 1.9 3.4.6.5 0 .5.5.8.3.2.7.3 1 .3.3 0 .5 0 .8-.1.2-.1.4-.3.6-.5.1-.1.3-.2.5-.4.3-.2.6-.5.7-.6.1-.1.2-.1.3-.2.2-.2.5-.5.6-.7.2-.2.4-.5.5-.7 0-.1.1-.1.1-.1v-.1c.1-.4-.3-.8-.8-1.3-.2-.2-.4-.3-.5-.5-.3-.3-.6-.5-1-.7-.9-.5-1.9-.7-3-.7l-.3-.3c-2.2-2.5-3.2-4.8-3.9-6.5-.9-2.1-1.9-3.3-3.9-4.9 1 .4 1.8.8 2.3 1.1.5.4 1.3.4 1.9.2.2-.1.5-.2.7-.3.2-.1.4-.2.6-.4 1.6-1.3 2.5-3.8 2.6-5.6v-.1c.2-.3.6-1.1.8-1.4l.1.1c.1.1.3.2.6.5.1 0 .1.1.2.1.1.1.2.1.2.2.8.6 1.9 1.3 2.6 1.7 1.4.7 2.3.7 5.3-.1 2.2-.6 4.8-.8 6.8-.8 1.4 0 2.7.3 4 .7.2.1.4.1.5.2.3.1.6.2.9.4 0 0 .1 0 .1.1.8.4 2.1 1.2 2.5-.3.1-2-.6-3.9-1.6-5.3 0 0-.1 0-.1-.1-.1-.1-.2-.2-.4-.3-.1-.1-.2-.1-.3-.2-.1-.1-.2-.2-.4-.2-.6-.4-1.2-.8-1.6-.9-.1-.1-.3-.1-.4-.2h-.1-.1c-.1 0-.3-.1-.4-.1-.1 0-.1 0-.2-.1h-.1l-.2-.4c-.2-.1-.4-.2-.5-.2h-.6c-.3 0-.5.1-.7.1-.7.1-1.2.3-1.7.4-.2 0-.3.1-.5.1-.5.1-1 .2-1.6.2-.4 0-.9-.1-1.5-.2-.4-.1-.8-.2-1.1-.3-.2-.1-.4-.1-.6-.2-.6-.2-1.1-.3-1.7-.4h-.2-1.8c-.3 0-.6.1-1 .1H57.9c-.8 0-1.5 0-2.3-.1-.2 0-.5-.1-.7-.1-.5-.1-.9-.2-1.3-.4-.2-.1-.3-.1-.4-.2-.1 0-.2 0-.2-.1-.3-.1-.6-.1-.9-.1H51h-.1c-.4 0-.9.1-1.4.2-1.1.2-2.1.6-3 1.3-.3.2-.6.5-.8.8-.1.1-.2.2-.2.3-.4.6-.8 1.2-.9 2 0 .2-.1.4-.1.6 0 .2 1.7.7 2.3 2.8-.8-1.2-2.3-2.5-4.1-1.4-1.5 1-1.1 3.1-2.4 5.4-.3.5-.6.9-1 1.4-.8 1-.7 2.1.2 4.4 1.4 3.4 7.6 5.3 11.5 8.3l.4.4zm8.7-36.3c0 .6.1 1 .2 1.6v.1c0 .3.1.6.1.9.1 1.2.4 2 1 2.9 0 .1.1.1.1.2.3.2.5.3.8.4 1.1.2 3.1.3 4.2 0 .2-.1.5-.3.7-.5.4-.4.7-1.1.9-1.7.1-.7.3-1.3.4-1.8 0-.2.1-.4.1-.5v-.1c0-.2 0-.3.1-.5.2-.7.2-2.4.3-2.8.1-.7 0-1.8-.1-2.5 0-.2-.1-.4-.1-.5v-.1c-.2-.5-1.4-1.4-4.3-1.4-3.1 0-4 1-4.1 1.5v.1c0 .1 0 .3-.1.5-.1.4-.2 1.4-.2 1.9v2.3zm-6 88.6c0-.1-.1-.2-.1-.3-.7-1.5-1.1-3.5-1.3-4.6.4.1.7.6.8.3.2-.5-.4-1.5-.5-2.2v-.1c-.5-.5-4-.5-3.7-.3-.4.8-1 .6-1.3 2.1-.1.7.8.1 1.7.1-1.4.9-3 2.1-3.4 3.2-.1.1-.1.2-.1.3 0 .2-.1.4-.1.5-.1 1.2.5 1.6 2 2.4H48.4c1.4.3 3 .3 4.3.3 1.2-.2 1.6-.7 1.6-1.4-.2-.1-.2-.2-.2-.3z" style=fill:#efefef /><path d="M56.1 36.5c.3 1.4.5 2.4.8 4.2h-.2c-.1.5-.1.9-.1 1.3-1-.4-2.2-.5-2.6-.5-3.7-4.4-2.9-6.1-4.4-8.3.4-.2 1-.4 1.5-.8 1.6 1.9 3.3 3 5 4.1zm-1.7 13.2s-1.4 0-2.3-1c0 0-.1-.5.1-.7 0 0-1.2-1-1.5-1.7-.2-.5-.3-1.1-.2-1.6-4.4-3.7-10.9-4.2-12.9-9.1-.5-1.2-1.3-2.9-.9-3.9-.3.1-.5.2-.8.3-2.9.9-11.7 5.3-17.9 8.8 1.6 1.7 2.6 4.3 3.2 7.2l.3 1.5c.1.5.1 1 .2 1.5.1 1.4.4 2.7.8 3.9.2.8.6 1.5.9 2.2.6 1 1.2 1.9 2.1 2.6.6.5 1.2.9 1.9 1.3 2.1 1.1 5 1.6 8.6 1.5H37.9c.5 0 1 .1 1.5.1h.1c.4.1.9.1 1.3.2h.2c.4.1.9.2 1.3.4h.1c.4.1.8.3 1.1.5h.1c.4.2.7.4 1.1.6h.1c.7.4 1.3.9 1.9 1.5l.1.1c.6.5 1.1 1.1 1.5 1.8 0 .1.1.1.1.2s.1.1.1.2c.4.6 1.2 1.1 1.9 1.3.7-.9 1.5-1.8 2.2-2.8-1.6-6 0-11.7 1.8-16.9zm-26-15.9c5-2.4 9-4.1 9.9-4.5.3-.6.6-1.4.9-2.6.1-.3.2-.5.3-.8 1-2.7 2.7-2.8 3.5-3v-.2c.1-1.1.5-2 1-2.8-8.8 2.5-18 5.5-28 11.7-.1.1-.2.2-.4.2C11.3 34.5 3 40.3 1.3 51c2.4-2.7 6-5.6 10.5-8.5.1-.1.3-.2.5-.3.2-.1.5-.3.7-.4 1.2-.7 2.4-1.4 3.6-2.2 2.2-1.2 4.5-2.4 6.7-3.5 1.8-.8 3.5-1.6 5.1-2.3zm54.9 61.3l-.3-.3c-.8-.6-4.1-1.2-5.5-2.3-.4-.3-1.1-.7-1.7-1.1-1.6-.9-3.5-1.8-3.5-2.1v-.1c-.2-1.7-.2-7 .1-8.8.3-1.8.7-4.4.8-5.1.1-.6.5-1.2.1-1.2h-.4c-.2 0-.4.1-.8.1-1.5.3-4.3.6-6.6.4-.9-.1-1.6-.2-2-.3-.5-.1-.7-.2-.9-.3H62.3c-.4.5 0 2.7.6 4.8.3 1.1.8 2 1.2 3 .3.8.6 1.8.8 3.1 0 .2.1.4.1.7.2 2.8.3 3.6-.2 4.9-.1.3-.3.6-.4 1-.4.9-.7 1.7-.6 2.3 0 .2.1.4.1.5.2.4.6.7 1.2.8.2 0 .3.1.5.1.3 0 .6.1.9.1 3.4 0 5.2 0 8.6.4 2.5.4 3.9.6 5.1.5.4 0 .9-.1 1.4-.1 1.2-.2 1.8-.5 1.9-.9-.1.2-.1.1-.2-.1zM60.2 16.4zm-.5 1.7zm3.8.5c.1 0 .3.1.5.1.4.1.7.2 1.2.3.3.1.6.1.9.1h1.3c.3-.1.7-.1 1-.2.7-.2 1.5-.4 2.7-.6h.3c.3 0 .6.1.9.3.1.1.2.1.4.2.3.2.8.2 1.2.4h.1c.1 0 .1.1.2.1.6.3 1.3.7 1.9 1.1l.3.3c.9-.1 1.6-.2 2.1-.2h.1c-.2-.4-.3-1.3-1.8-.6-.6-.7-.8-1.3-2.1-.9-.1-.2-.2-.3-.3-.4l-.1-.1c-.1-.1-.2-.3-.3-.4 0-.1-.1-.1-.1-.2-.2-.3-.5-.5-.9-.7-.7-.4-1.5-.6-2.3-.5-.2 0-.4.1-.6.2-.1 0-.2.1-.2.1-.1 0-.2.1-.3.2-.5.3-1.3.8-2.1 1-.1 0-.1 0-.2.1-.2 0-.4.1-.5.1H66.5h-.1c-.4-.1-1.1-.2-2-.5-.1 0-.2-.1-.3-.1-.9-.2-1.8-.5-2.7-.8-.3-.1-.7-.2-1-.3-.1 0-.1 0-.2-.1h-.1s-.1 0-.1-.1c-.3-.3-.7-.6-1.3-.8-.5-.2-1.2-.4-2.1-.5-.2 0-.5 0-.7.1-.4.2-.8.6-1.2.9.1.1.3.3.4.5.1.2.2.4.3.7l-.6-.6c-.5-.4-1.1-.8-1.7-.9-.8-.2-1.4.4-2.3.9 1 0 1.8.1 2.5.4.1 0 .1 0 .2.1h.1c.1 0 .2.1.3.1.9.4 1.8.6 2.7.6h1.3c.5 0 .8-.1 1.1-.1.1 0 .4 0 .7-.1h2.2c.4.4.9.6 1.6.8z" style=fill:#88ce02 /><path d="M100 51.8c0-19.5-12.5-36.1-30-42.1.1-1.2.2-2.4.3-3.1.1-1.5.2-3.9-.5-4.9-1.6-2.3-9.1-2.1-10.5-.1-.4.6-.7 3.6-.6 5.9-1.1-.1-2.2-.1-3.3-.1-16.5 0-30.9 9-38.6 22.3-2.4 1.4-4.7 2.8-6.1 4C5.4 38 2.2 43.2 1 47c-1.6 4.7-1.1 7.6.4 5.8 1.2-1.5 6.6-5.9 10.1-8.2-.4 2.3-.6 4.8-.6 7.2 0 21 14.5 38.5 34 43.3-.1 1.1.1 2 .7 2.6.9.8 3.2 2 6.4 1.6 2.9-.3 3.5-.5 3.2-2.9h.2c2.7 0 5.3-.2 7.8-.7.1.1.2.2.4.3 1.5 1 7.1.8 9.6.7s6.2.9 8.6.5c2.9-.5 3.4-2.3 1.6-3.2-1.5-.8-3.8-1.3-6.7-3.1C90.6 83.4 100 68.7 100 51.8zM60.1 5.5c0-.5.1-1.5.2-2.1 0-.2 0-.4.1-.5v-.1c.1-.5 1-1.5 4.1-1.5 2.9 0 4.2.9 4.3 1.4v.1c0 .1 0 .3.1.5.1.8.2 1.9.1 2.7 0 .5-.1 2.1-.2 2.9 0 .1 0 .3-.1.5v.1c0 .2-.1.3-.1.5-.1.5-.2 1.1-.4 1.8-.1.6-.5 1.2-.9 1.7-.2.3-.5.5-.7.5-1.1.3-3.1.3-4.2 0-.3-.1-.5-.2-.8-.4 0-.1-.1-.1-.1-.2-.6-.9-.9-1.7-1-2.9 0-.4-.1-.6-.1-.9v-.1c-.1-.6-.2-1-.2-1.6v-.3c-.1-1.3-.1-2.1-.1-2.1zm-.4 7.5v-.4c.6.6 1.3 1.3 1.8 1.7.2.2.5.3.8.3.2 0 .3 0 .5.1h1.6c.8 0 1.6.1 2 0 .1 0 .2 0 .3-.1.6-.3 1.4-1 2.1-1.6 0 .6.1 1.2.1 1.7v1.5c0 .3 0 .5.1.7-.1.1-.2.1-.4.2-.7.4-1.7 1-2.3.9-.5-.1-1.5-.3-2.6-.7-1.2-.3-2.4-.8-3.2-1.2 0 0-.1 0-.1-.1-.2-.3-.4-.5-.6-.7-.3-.4-.5-.6-.5-.7.3-.4.4-.9.4-1.6zm.5 3.4zm-7.3-.3c.6.1 1.2.5 1.7.9.2.2.5.4.6.6-.1-.2-.2-.5-.3-.7-.1-.2-.3-.4-.4-.5.4-.3.8-.7 1.2-.9.2-.1.4-.1.7-.1.9.1 1.6.2 2.1.5.6.2 1 .5 1.3.8 0 0 .1 0 .1.1h.1c.1 0 .1 0 .2.1.3.1.6.2 1 .3.9.3 1.9.6 2.7.8.1 0 .2.1.3.1.9.2 1.6.4 2 .5h.4c.2 0 .4 0 .5-.1.1 0 .1 0 .2-.1.7-.2 1.5-.7 2.1-1 .1-.1.2-.1.3-.2.1 0 .2-.1.2-.1.2-.1.4-.2.6-.2.8-.2 1.7.1 2.3.5.3.2.6.4.9.7 0 .1.1.1.1.2.1.2.2.3.3.4l.1.1c.1.1.2.2.3.4 1.3-.4 1.5.2 2.1.9 1.6-.7 1.7.2 1.8.6h-.1c-.5 0-1.2 0-2.1.2l-.3-.3c-.5-.4-1.2-.8-1.9-1.1-.1 0-.1-.1-.2-.1h-.1c-.4-.2-.8-.2-1.2-.4-.1-.1-.2-.1-.4-.2-.3-.1-.6-.3-.9-.3h-.3c-1.2.1-2 .4-2.7.6-.3.1-.7.2-1 .2-.4.1-.8.1-1.3 0-.3 0-.6-.1-.9-.1-.5-.1-.8-.2-1.2-.3-.2 0-.3-.1-.5-.1h-.1c-.6-.2-1.2-.3-1.8-.4h-.1-2.1c-.4.1-.6.1-.7.1-.3 0-.7.1-1.1.1h-1.3c-.9 0-1.9-.2-2.7-.6-.1 0-.2-.1-.3-.1H53c-.1 0-.1 0-.2-.1-.7-.3-1.6-.4-2.5-.4 1.2-.8 1.8-1.4 2.6-1.3zm6.8 2zm-15.2 4.1c.1-.7.4-1.4.9-2 .1-.1.2-.2.2-.3l.8-.8c.9-.6 1.9-1.1 3-1.3.5-.1 1-.2 1.4-.2H52c.3 0 .6.1.9.1.1 0 .2 0 .2.1.1.1.2.1.4.2.4.2.8.3 1.3.4.2 0 .5.1.7.1.7.1 1.5.1 2.3.1H58.7c.4 0 .7-.1 1-.1H61.7c.6.1 1.1.2 1.7.4.2 0 .4.1.6.2.3.1.7.2 1.1.3.6.1 1.1.2 1.5.2.6 0 1.1-.1 1.6-.2.2 0 .3-.1.5-.1.5-.1 1-.3 1.7-.4.2 0 .5-.1.7-.1h.6c.2 0 .4.1.5.2l.1.1h.1c.1 0 .1 0 .2.1.2.1.3.1.4.1h.2c.1.1.3.1.4.2.4.2 1 .6 1.6.9.1.1.2.2.4.2.1.1.2.1.3.2.2.1.3.3.4.3l.1.1c1.1 1.4 1.8 3.3 1.6 5.3-.3 1.5-1.6.7-2.5.3 0 0-.1 0-.1-.1-.3-.1-.6-.2-.9-.4-.2-.1-.4-.1-.5-.2-1.2-.4-2.5-.7-4-.7-2 0-4.6.1-6.8.8-3 .8-4 .8-5.3.1-.8-.4-1.8-1.1-2.6-1.7-.1-.1-.2-.1-.2-.2-.1-.1-.1-.1-.2-.1-.3-.2-.6-.4-.6-.5l-.1-.1c-.2.3-.6 1-.8 1.4v.1c-.1 1.7-1 4.2-2.6 5.6-.2.1-.4.3-.6.4-.2.1-.5.2-.7.3-.7.2-1.4.2-1.9-.2-.5-.3-1.3-.7-2.3-1.1 2 1.6 3 2.8 3.9 4.9.7 1.7 1.7 4 3.9 6.5l.3.3c1.1 0 2.1.2 3 .7.4.2.7.4 1 .7.2.2.4.3.5.5.5.4.9.8.8 1.3v.1s0 .1-.1.1c-.1.2-.3.5-.5.7-.1.1-.4.4-.6.7-.1.1-.2.2-.3.2-.1.1-.4.3-.7.6-.2.2-.4.3-.5.4-.2.1-.4.4-.6.5-.3.1-.5.2-.8.1-.3 0-.7-.2-1-.3-.5-.3.1-.3-.5-.8-1.4-1-2.2-1.7-1.9-3.4v-.2c-.2-.1-.3-.3-.5-.4-3.9-3-10.1-4.9-11.5-8.3-.9-2.3-1-3.4-.2-4.4.4-.5.8-1 1-1.4 1.3-2.3.9-4.4 2.4-5.4 1.8-1.2 3.3.2 4.1 1.4-.5-2.1-2.3-2.6-2.3-2.8.3.1.3-.1.3-.3zm29 20s-.1 0 0 0c-.1 0-.1 0 0 0-.9.1-3.3.3-5.4.3h-.9c-.7 0-1.3-.1-1.8-.2-.1 0-.2 0-.3-.1-.7-.2-1.6-.5-2.4-.8-.6-.2-1.2-.5-1.7-.7-1.1-.5-2.1-1.1-2.3-1.3-.5-1.4-.7-2.7-.7-3.4.8-.4 1.3-.7 1.9-1.4-1.7.3-2.4.2-3.4-.4-1-.5-2.6-2.2-3.6-3.4 1-1.2 1.7-2.9 1.4-5.1.1-.2.3-.4.4-.6 0 .1.1.1.2.2.7.9 2.4 2 4.6 2.8 1.1.4 2 .1 2.9-.1 4-1 8.1-1.3 11.9-.1.1 0 .2.1.3.1.5.2.9.4 1.4.6.1 0 .1.1.2.1.1.7.2 2-.3 3.5-.1.3-.2.6-.4.9-.2.3-.3.6-.5 1-.1.3-.2.5-.4.8-.2.4-.3.8-.5 1.3-.4 1.4-.7 3.4-.6 6zm-23.9-9c.4-.2 1-.4 1.5-.8 1.6 1.8 3.3 3 5 4.1.3 1.4.5 2.4.8 4.2h-.2c-.1.5-.1.9-.1 1.3-1-.4-2.2-.5-2.6-.5-3.7-4.3-3-6-4.4-8.3zm-32.9 6.5c-1.3.7-2.5 1.4-3.6 2.2-.2.1-.5.3-.7.4-.1.1-.3.2-.5.3-4.5 2.9-8.1 5.8-10.5 8.5 1.7-10.8 10-16.5 14.3-19.2.1-.1.2-.2.4-.2 10-6.2 19.2-9.2 28-11.7-.5.8-.9 1.7-1 2.8v.2c-.8.1-2.5.2-3.5 3-.1.2-.2.5-.3.8-.3 1.2-.6 2-.9 2.6-.9.4-5 2.2-9.9 4.5-1.6.8-3.3 1.6-5 2.4-2.3 1-4.6 2.2-6.8 3.4zm28 24.8s0-.1 0 0c-.4-.3-.8-.5-1.2-.7h-.1c-.4-.2-.7-.3-1.1-.5h-.1c-.4-.1-.8-.3-1.3-.4h-.2c-.4-.1-.8-.2-1.3-.2h-.1c-.5-.1-1-.1-1.5-.1H35.9c-3.7.1-6.5-.4-8.6-1.5-.7-.4-1.4-.8-1.9-1.3-.9-.7-1.5-1.6-2.1-2.6-.4-.7-.7-1.4-.9-2.2-.4-1.2-.6-2.5-.8-3.9 0-.5-.1-1-.2-1.5l-.3-1.5c-.6-2.9-1.6-5.5-3.2-7.2 6.3-3.5 15-7.9 17.8-8.8.3-.1.6-.2.8-.3-.3 1.1.4 2.7.9 3.9 2.1 4.9 8.6 5.4 12.9 9.1 0 .5 0 1.1.2 1.6.5.6 1.7 1.6 1.7 1.6-.2.2-.1.7-.1.7.9 1 2.3 1 2.3 1-1.8 5.2-3.4 10.9-1.9 16.9-.7 1-1.5 1.8-2.2 2.8-.7-.2-1.4-.6-1.9-1.3 0-.1-.1-.1-.1-.2s-.1-.1-.1-.2l-1.5-1.8-.1-.1c-.5-.4-1.2-.9-1.9-1.3zm7.9 33.6c-1.3.1-2.9 0-4.3-.3h-.2-.1c-1.5-.8-2.1-1.2-2-2.4 0-.2 0-.3.1-.5 0-.1.1-.2.1-.3.5-1.1 2.1-2.2 3.4-3.2-.8 0-1.8.7-1.7-.1.2-1.5.9-1.3 1.3-2.1-.2-.3 3.3-.2 3.8.3v.1c0 .7.7 1.7.5 2.2-.1.3-.4-.2-.8-.3.2 1.1.6 3.1 1.3 4.6.1.1.1.2.1.3 0 .1.1.2.1.3 0 .7-.4 1.2-1.6 1.4zM59 67.7c0 .9-.3 1.6-.6 2-.7 1.1-1.7 1.4-2 3.2.4-.6 1.1-1.1 1.1-.9 0 .8-.1 1.4-.1 2v.2c-.1.6-.2 1.1-.3 1.6-.2.9-.5 1.7-.7 2.4-.4 1.2-.9 2.1-1.3 3.1l-.6 1.5c-.6 1.7-.4 5.6-.6 5.7-1.6.3-4.1-.3-4.7-.6.3-2.2.4-4.5.5-6.9.1-2.1.3-4.3.9-6.6.1-.5.3-1 .4-1.5 0-.1 0-.2.1-.2 0-.1 0-.1.1-.2.5-1.6 1.4-2.7 2.6-4.2.4-.4.7-.9 1.2-1.4-.1-.4-.2-.8-.4-1.3-.7-2.6-1.3-7.3 1.5-16.1.1 0 .2-.1.3-.1.2-.1.7-.5.8-.6.1-.1.3-.2.4-.3.1 0 .1-.1.2-.1l.6-.6 1.1-1.1c.4-.4.7-.5.8-.9v-.2c0-.8-1.1-1.5-1.5-2.1l-.1-.1c.1-.2.1-.4.2-.6 0-.2.1-.5.1-.8 0-.2.1-.5.1-.7.1.1.6.4 1.8.7.6.2 1.3.4 2.3.7 1.1.3 2.4.5 3.6.6 2.9.2 5.6 0 6.7-.2h.3v.1c0 .1 0 .2-.1.3v.9c0 .2 0 .3.1.5v.1c0 .4.1.7.2 1.1 0 .3.1.5.1.7v.1c0 .3.1.5.1.7 0 .2.1.3.1.5.1.2.1.4.2.6v.2c.1.4.2.8.2 1.1 1 5.7 2.3 12.9-1.1 16.7.2.8.3 1.9 0 3.2-.1.7-.3 1.4-.6 2.2-.2.5-.3 1-.5 1.5h-.3c-4.5.6-7.1.2-8.3-.1.5-1.6 1.7-3.3 3.7-3.2-.1-3.7-1.1-5-2-7.6 1.3-3 1.3-5.7 2-9.2v-.2c.2-.8.3-1.6.6-2.5-.4.5-.8 1.5-1.2 2.6v.1c-.5 1.5-.9 3.4-1.2 4.8-.2.8-.4 1.6-.7 2.4-.2.5-.4.9-.6 1.4-1.5 1.9-3 3.9-5.5 5.6zm18.5 24.9c1.5 1.1 4.7 1.8 5.5 2.3l.3.3c.1.1.1.2.1.3-.1.4-.7.7-1.9.9-.5.1-.9.1-1.4.1-1.3 0-2.6-.2-5.1-.5-3.4-.5-5.2-.4-8.6-.4-.3 0-.6 0-.9-.1-.2 0-.4-.1-.5-.1-.6-.2-1-.5-1.2-.8-.1-.2-.1-.3-.1-.5-.1-.7.2-1.5.6-2.3.2-.4.3-.7.4-1 .5-1.3.4-2.1.2-4.9 0-.2-.1-.4-.1-.7-.2-1.3-.5-2.3-.8-3.1-.4-1.1-.9-1.9-1.2-3-.6-2.1-1-4.3-.6-4.8H62.5c.2.1.5.2.9.3.5.1 1.1.2 2 .3 2.2.2 5.1-.2 6.6-.4.3-.1.6-.1.8-.1h.4c.4 0 .1.6-.1 1.2-.1.7-.5 3.3-.8 5.1-.3 1.8-.2 7.1-.1 8.8v.1c0 .3 1.9 1.2 3.5 2.1.7.2 1.4.5 1.8.9zm4.8-48.2c0 .1 0 .1 0 0-.1.1-.2.2-.2.3 0-.1-.1-.1-.1-.2 0 .1 0 .2-.1.2-.2.9-.6 2.4-2.2 4.1-.4.4-.7.6-1 .7-.5.1-.9 0-1.5-.1-.9-.2-1.3-.6-2.2-1.1-.1-.6-.3-1.3-.4-1.8 0-.3-.1-.5-.1-.6v-1l.4-.4s.7-1 1.8-1 2.2-.2 2.5-.5v-.1-.3c0-.1 0-.2-.1-.3-.4-1.4-2.1-1.8-1.4-4.8 0-.2.3-.5 1.2-.5-1.4-.3-2-.4-3-1.3.5-1.1 1-1.9 1.3-2.6.8-1.5.3-3.5.3-3.5.8-.3 1.6-.7 1.7-1 .9-2.8-.7-5.5-2.5-7.2 1.2-.1 2.6.1 3.6 1.1 2.4 2.4 1.8 5 1 6.8.6.7 2.1 2.9 1.2 5.3-.2.6-1.4.6-2.3 2.1 2.3-1.3 3.7-1 4.2.7 1 2.4-.6 5.3-2.1 7z"/><path d="M22 53.4v-.2c0-.2-.1-.5-.2-.9s-.1-.8-.2-1.3c-.5-4.7-1.9-9.4-4.9-11.3 3.7-2 16.8-8.5 21.9-10.5 2.9-1.2.8-.4-.2 1.4-.8 1.4-.3 2.9-.5 3.2-.6.8-12.6 10.5-15.9 19.6zm32.2-2.3c-3.4 3.8-12 11-18.2 11.4 8.7-.2 12.2 4.1 14.7 9.7 2.6-5.2 2.7-10.3 2.6-16.1 0-2.6 1.8-6 .9-5zm5.3-23L54.3 24s-1.1 3.1-1 4.6c.1 1.6-1.8 2.7-.9 3.6.9.9 3.2 2.5 4 3.4.7.9 1.1 7.1 1.1 7.1l2.2 2.7s1-1.8 1.1-6.3c.2-5.4-2.9-7.1-3.3-8.6-.4-1.4.6-2.9 2-2.4zm3.1 45.6l3.9.3s1.2-2.2 2.1-3.5c.9-1.4.4-1.6 0-4.6-.4-3-1.4-9.3-1.2-13.6l-3.1 10.2s1.8 5.6 1.6 6.4c-.1.8-3.3 4.8-3.3 4.8zm5 18.8c-1.1 0-2.5-.4-3.5-.8l-1 .3.2 4s5.2.7 4.6-.4c-.6-1.2-.3-3.1-.3-3.1zm12 .6c-1 0-.3.2.4 1.2.8 1 .1 2-.8 2.3l3.2.5 1.9-1.7c.1 0-3.7-2.3-4.7-2.3zM73 76c-1.6.5-4.2.8-5.9.8-1.7.1-3.7-.1-5-.5v1.4s1.2.5 5.4.5c3.5.1 5.7-.8 5.7-.8l.9-.8c-.1.1.5-1.1-1.1-.6zm-.2 3.1c-1.6.6-3.9.6-5.6.7-1.7.1-3.7-.1-5-.5l.1 1.4s.7.3 4.9.4c3.5.1 5.7-.7 5.7-.7l.3-.5c-.1-.1.3-1-.4-.8zm5.9-42.7c-.9-.8-1.4-2.4-1.5-3.3l-1.9 2.5.7 1.2s2.5.1 2.8.1c.4 0 .3-.1-.1-.5zM69 14.7c.6-.7.2-2.7.2-2.7L66 14.6l-4.4-.8-.5-1.3-1.3-.1c.8 1.8 1.8 2.5 3.3 3.1.9.4 4.5.9 5.9-.8z" style=opacity:.4;fill-rule:evenodd;clip-rule:evenodd /></svg></a></div></div>\';\n    if (element) {\n      root.style.position = "absolute";\n      root.style.top = minimal ? "calc(100% - 42px)" : "calc(100% - 51px)";\n    }\n    if (css) {\n      if (_isString(css)) {\n        root.style.cssText = css;\n      } else if (_isObject(css)) {\n        css.data = "root";\n        gsap.set(root, css).kill();\n      }\n      if (root.style.top) {\n        root.style.bottom = "auto";\n      }\n      if (root.style.width) {\n        gsap.set(root, {\n          xPercent: -50,\n          left: "50%",\n          right: "auto",\n          data: "root"\n        }).kill();\n      }\n    }\n    if (!minimal && root.offsetWidth < 600) {\n      root.setAttribute("class", "gs-dev-tools minimal");\n      if (element) {\n        root.style.top = "calc(100% - 42px)";\n      }\n    }\n    return root;\n  },\n  _clickedOnce = true,\n  //perhaps we shouldn\'t preventDefault() on the first mousedown/touchstart/pointerdown so that iframes get focus properly. Did that previously, but now it seems to prevent interaction on the first click (annoying).\n  _addListener = (e, type, callback, capture) => {\n    let handler, altType;\n    if (type === "mousedown" || type === "mouseup") {\n      e.style.cursor = "pointer";\n    }\n    if (type === "mousedown") {\n      //some browsers call BOTH mousedown AND touchstart, for example, on a single interaction so we need to skip one of them if both are called within 100ms.\n      altType = !_isUndefined(e.onpointerdown) ? "pointerdown" : !_isUndefined(e.ontouchstart) ? "touchstart" : null;\n      if (altType) {\n        handler = event => {\n          if (event.target.nodeName.toLowerCase() !== "select" && event.type === altType) {\n            //don\'t preventDefault() on a <select> or else it won\'t open!\n            event.stopPropagation();\n            if (_clickedOnce) {\n              //otherwise, both touchstart and mousedown will get called.\n              event.preventDefault();\n              callback.call(e, event);\n            }\n          } else if (event.type !== altType) {\n            callback.call(e, event);\n          }\n          _clickedOnce = true;\n        };\n        e.addEventListener(altType, handler, capture);\n        if (altType !== "pointerdown") {\n          e.addEventListener(type, handler, capture);\n        }\n        return;\n      }\n    }\n    e.addEventListener(type, callback, capture);\n  },\n  _removeListener = (e, type, callback) => {\n    e.removeEventListener(type, callback);\n    type = type !== "mousedown" ? null : !_isUndefined(e.onpointerdown) ? "pointerdown" : !_isUndefined(e.ontouchstart) ? "touchstart" : null;\n    if (type) {\n      e.removeEventListener(type, callback);\n    }\n  },\n  _selectValue = (element, value, label, insertIfAbsent) => {\n    let options = element.options,\n      i = options.length,\n      option;\n    value += "";\n    while (--i > -1) {\n      if (options[i].innerHTML === value || options[i].value === value) {\n        element.selectedIndex = i;\n        label.innerHTML = options[i].innerHTML;\n        return options[i];\n      }\n    }\n    if (insertIfAbsent) {\n      option = _createElement("option", element);\n      option.setAttribute("value", value);\n      option.innerHTML = label.innerHTML = _isString(insertIfAbsent) ? insertIfAbsent : value;\n      element.selectedIndex = options.length - 1;\n    }\n  },\n  //increments the selected value of a <select> up or down by a certain amount.\n  _shiftSelectedValue = (element, amount, label) => {\n    let options = element.options,\n      i = Math.min(options.length - 1, Math.max(0, element.selectedIndex + amount));\n    element.selectedIndex = i;\n    if (label) {\n      label.innerHTML = options[i].innerHTML;\n    }\n    return options[i].value;\n  },\n  //moves everything from _globalTimeline into _recordedRoot and updates the _rootTween if it is currently controlling the Global timeline (_recordedRoot). _recordedTemp is just a temporary recording area for anything that happens while _recordedRoot is paused. Returns true if the _recordedRoot\'s duration changed due to the merge.\n  _merge = () => {\n    let t = _globalTimeline._first,\n      duration,\n      next,\n      target;\n    if (_rootInstance) {\n      duration = _recordedRoot._dur;\n      while (t) {\n        next = t._next;\n        target = t._targets && t._targets[0];\n        if (!(_isFunction(target) && target === t.vars.onComplete && !t._dur) && !(target && target._gsIgnore)) {\n          //typically, delayedCalls aren\'t included in the _recordedTemp, but since the hijacked add() below fires BEFORE TweenLite\'s constructor sets the target, we couldn\'t check that target === vars.onComplete there. And Draggable creates a tween with just an onComplete (no onReverseComplete), thus it fails that test. Therefore, we test again here to avoid merging that in.\n          _recordedRoot.add(t, t._start - t._delay);\n        }\n        t = next;\n      }\n      return duration !== _recordedRoot.duration();\n    }\n  },\n  _updateRootDuration = () => {\n    if (_rootInstance) {\n      _rootInstance.update();\n      _rootIsDirty = false;\n    }\n    gsap.ticker.remove(_updateRootDuration);\n  },\n  _buildPlayPauseMorph = svg => {\n    let tl = gsap.timeline({\n      data: "root",\n      parent: _independentRoot,\n      onComplete: () => tl.kill()\n    });\n    tl.to(svg.querySelector(".play-1"), {\n      duration: 0.4,\n      attr: {\n        d: "M5.75,3.13 C5.75,9.79 5.75,16.46 5.75,23.13 4.08,23.13 2.41,23.13 0.75,23.13 0.75,16.46 0.75,9.79 0.75,3.12 2.41,3.12 4.08,3.12 5.75,3.12"\n      },\n      ease: "power2.inOut",\n      rotation: 360,\n      transformOrigin: "50% 50%"\n    }).to(svg.querySelector(".play-2"), {\n      duration: 0.4,\n      attr: {\n        d: "M16.38,3.13 C16.38,9.79 16.38,16.46 16.38,23.13 14.71,23.13 13.04,23.13 11.38,23.13 11.38,16.46 11.38,9.79 11.38,3.12 13.04,3.12 14.71,3.12 16.38,3.12"\n      },\n      ease: "power2.inOut",\n      rotation: 360,\n      transformOrigin: "50% 50%"\n    }, 0.05);\n    return tl;\n  },\n  _buildLoopAnimation = svg => {\n    let tl = gsap.timeline({\n      data: "root",\n      id: "loop",\n      parent: _independentRoot,\n      paused: true,\n      onComplete: () => tl.kill()\n    });\n    tl.to(svg, {\n      duration: 0.5,\n      rotation: 360,\n      ease: "power3.inOut",\n      transformOrigin: "50% 50%"\n    }).to(svg.querySelectorAll(".loop-path"), {\n      duration: 0.5,\n      fill: "#91e600",\n      ease: "none"\n    }, 0);\n    return tl;\n  },\n  _getAnimationById = id => gsap.getById(id) || _independentRoot.getById(id) || id === _recordedRoot.vars.id && _recordedRoot,\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (!_coreInitted) {\n      if (gsap && _windowExists()) {\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _win = window;\n        gsap.registerPlugin(_Draggable_js__WEBPACK_IMPORTED_MODULE_0__.Draggable);\n        _globalTimeline = gsap.globalTimeline;\n        _globalTimeline._sort = true;\n        _globalTimeline.autoRemoveChildren = false;\n        Animation = gsap.core.Animation;\n        _independentRoot = gsap.timeline({\n          data: "indy",\n          autoRemoveChildren: true,\n          smoothChildTiming: true\n        });\n        _independentRoot.kill();\n        _independentRoot._dp = 0; //don\'t let it revert to the global timeline as its parent.\n        _independentRoot.to({}, {\n          duration: 1e12\n        });\n        _recordedRoot = gsap.timeline({\n          data: "root",\n          id: "Global Timeline",\n          autoRemoveChildren: false,\n          smoothChildTiming: true,\n          parent: _independentRoot\n        });\n        _rootTween = gsap.to(_recordedRoot, {\n          duration: 1,\n          time: 1,\n          ease: "none",\n          data: "root",\n          id: "_rootTween",\n          paused: true,\n          immediateRender: false,\n          parent: _independentRoot\n        });\n        // so that auto-overwriting works. Initially we transferred the tweens to the _recordedRoot.\n        _globalTimeline.killTweensOf = function (targets, props, onlyActive) {\n          _recordedRoot.killTweensOf(targets, props, onlyActive);\n          _recordedRoot.killTweensOf.call(_globalTimeline, targets, props, onlyActive);\n        };\n        _independentRoot._start = gsap.ticker.time;\n        gsap.ticker.add(time => _independentRoot.render(time - _independentRoot._start));\n\n        //align the all of the playheads so they\'re starting at 0 now.\n        _globalTimeline._start += _globalTimeline._time;\n        _recordedRoot._start = _globalTimeline._time = _globalTimeline._tTime = 0;\n        _delayedCall = (delay, callback, params, scope) => gsap.to(callback, {\n          delay: delay,\n          duration: 0,\n          onComplete: callback,\n          onReverseComplete: callback,\n          onCompleteParams: params,\n          onReverseCompleteParams: params,\n          callbackScope: scope,\n          parent: _independentRoot\n        });\n\n        //in case GSDevTools.create() is called before anything is actually on the global timeline, we\'ve gotta update it or else the duration will be 0 and it\'ll be stuck.\n        _delayedCall(0.01, () => _rootInstance ? _rootInstance.update() : _merge());\n\n        //initially we record everything into the _recordedRoot Timeline because developers might call GSDevTools.create() AFTER some of their code executes, but after 2 seconds if there aren\'t any GSDevTool instances that have globalSync enabled, we should dump all the stuff from _recordedRoot into the global timeline to improve performance and avoid issues where _recordedRoot is paused and reaches its end and wants to stop the playhead.\n        _delayedCall(2, () => {\n          let t, next, offset;\n          if (!_rootInstance) {\n            _merge();\n            t = _recordedRoot._first;\n            offset = _recordedRoot._start;\n            while (t) {\n              next = t._next;\n              //any animations that aren\'t finished should be dumped into the root timeline. If they\'re done, just kill them.\n              if (t._tDur !== t._tTime || !t._dur && t.progress() !== 1) {\n                _globalTimeline.add(t, t._start - t._delay + offset);\n              } else {\n                t.kill();\n              }\n              t = next;\n            }\n          }\n          if (GSDevTools.globalRecordingTime > 2) {\n            _delayedCall(GSDevTools.globalRecordingTime - 2, () => {\n              _rootInstance && _rootInstance.update();\n              _recording = false;\n              _globalTimeline.autoRemoveChildren = true;\n            });\n          } else {\n            _recording = false;\n            _globalTimeline.autoRemoveChildren = true;\n          }\n          _startupPhase = false;\n        });\n        _coreInitted = 1;\n      }\n    }\n  },\n  _checkIndependence = (animation, vars) => {\n    if (!vars.globalSync && animation.parent !== _globalTimeline) {\n      //in case it\'s nested in a timeline (playing it won\'t help if the parent timeline isn\'t playing).\n      _globalTimeline.add(animation, _globalTimeline.time());\n    }\n  },\n  GSDevTools = function (vars) {\n    if (!_coreInitted) {\n      _initCore();\n      gsap || console.warn("Please gsap.registerPlugin(GSDevTools)");\n    }\n    this.vars = vars = vars || {};\n    if (vars.animation) {\n      (GSDevTools.getByAnimation(vars.animation) || {\n        kill: () => 0\n      }).kill();\n    }\n    vars.id = vars.id || (_isString(vars.animation) ? vars.animation : _idSeed++); //try to find a unique ID so that sessionStorage can be mapped to it (otherwise, for example, all the embedded codepens on a page would share the same settings). So if no id is defined, see if there\'s a string-based "animation" defined. Last of all, we default to a numeric counter that we increment.\n    _lookup[vars.id + ""] = this;\n    "globalSync" in vars || (vars.globalSync = !vars.animation); //if the user calls create() and passes in an animation AFTER the initial recording time has elapsed, there\'s a good chance the animation won\'t be in the recordedRoot, so we change the default globalSync to false because that\'s the most intuitive behavior.\n\n    //GENERAL/UTILITY\n    let _self = this,\n      root = _createRootElement(vars.container, vars.minimal, vars.css),\n      find = s => root.querySelector(s),\n      record = (key, value) => {\n        if (vars.persist !== false && _supportsStorage) {\n          sessionStorage.setItem("gs-dev-" + key + vars.id, value);\n        }\n        return value;\n      },\n      recall = key => {\n        let value;\n        if (vars.persist !== false && _supportsStorage) {\n          value = sessionStorage.getItem("gs-dev-" + key + vars.id);\n          return key === "animation" ? value : key === "loop" ? value === "true" : parseFloat(value); // handle data typing too.\n        }\n      },\n      //SCRUBBER/PROGRESS\n      playhead = find(".playhead"),\n      timelineTrack = find(".timeline-track"),\n      progressBar = find(".progress-bar"),\n      timeLabel = find(".time"),\n      durationLabel = find(".duration"),\n      pixelToTimeRatio,\n      timeAtDragStart,\n      dragged,\n      skipDragUpdates,\n      progress = 0,\n      inPoint = find(".in-point"),\n      outPoint = find(".out-point"),\n      inProgress = 0,\n      outProgress = 100,\n      pausedWhenDragStarted,\n      list = find(".animation-list"),\n      animationLabel = find(".animation-label"),\n      selectedAnimation,\n      //the currently selected animation\n      linkedAnimation,\n      //the animation that\'s linked to all the controls and scrubber. This is always _rootTween if globalSync is true, so it can be different than the selectedAnimation!\n      declaredAnimation,\n      //whatever the user defines in the config object initially (often this will be null). If the user defines a string, it\'ll be resolved to a real Animation instance for this variable.\n      startTime,\n      endTime,\n      _fullyInitialized,\n      //we call initialize() initially, and then again on the very next tick just in case someone called GSDevTools.create() BEFORE they create their animations. This variable tracks that state. Note: we don\'t record sessionStorage.setItem() until we\'re fully initialized, otherwise we may inadvertently set in/out points to the defaults just because the animation couldn\'t be found (yet).\n      keyboardHandler,\n      playPauseButton = find(".play-pause"),\n      playPauseMorph = _buildPlayPauseMorph(playPauseButton),\n      paused = false,\n      loopButton = find(".loop"),\n      loopAnimation = _buildLoopAnimation(loopButton),\n      loopEnabled,\n      timeScale = find(".time-scale select"),\n      timeScaleLabel = find(".time-scale-label"),\n      //spits back a common onPress function for anything that\'s dragged along the timeline (playhead, inPoint, outPoint). The originRatio is a value from 0-1 indicating how far along the x-axis the origin is located (0.5 is in the center, 0 is left, 1 is on right side). limitElement is optional, and sets the bounds such that the element can\'t be dragged past the limitElement.\n      onPressTimeline = (element, originRatio, limitToInOut) => {\n        return function (e) {\n          let trackBounds = timelineTrack.getBoundingClientRect(),\n            elementBounds = element.getBoundingClientRect(),\n            left = elementBounds.width * originRatio,\n            x = gsap.getProperty(element, "x"),\n            minX = trackBounds.left - elementBounds.left - left + x,\n            maxX = trackBounds.right - elementBounds.right + (elementBounds.width - left) + x,\n            unlimitedMinX = minX,\n            limitBounds;\n          if (limitToInOut) {\n            if (element !== inPoint) {\n              limitBounds = inPoint.getBoundingClientRect();\n              if (limitBounds.left) {\n                //if inPoint is hidden (like display:none), ignore.\n                minX += limitBounds.left + limitBounds.width - trackBounds.left;\n              }\n            }\n            if (element !== outPoint) {\n              limitBounds = outPoint.getBoundingClientRect();\n              if (limitBounds.left) {\n                //if outPoint is hidden (like display:none), ignore.\n                maxX -= trackBounds.left + trackBounds.width - limitBounds.left;\n              }\n            }\n          }\n          pausedWhenDragStarted = paused;\n          this.applyBounds({\n            minX: minX,\n            maxX: maxX\n          });\n          pixelToTimeRatio = linkedAnimation.duration() / trackBounds.width;\n          timeAtDragStart = -unlimitedMinX * pixelToTimeRatio;\n          if (!skipDragUpdates) {\n            linkedAnimation.pause(timeAtDragStart + pixelToTimeRatio * this.x);\n          } else {\n            linkedAnimation.pause();\n          }\n          if (this.target === playhead) {\n            if (this.activated) {\n              this.allowEventDefault = false;\n            }\n            this.activated = true;\n          }\n          dragged = true;\n        };\n      },\n      progressDrag = _Draggable_js__WEBPACK_IMPORTED_MODULE_0__.Draggable.create(playhead, {\n        type: "x",\n        cursor: "ew-resize",\n        allowNativeTouchScrolling: false,\n        allowEventDefault: true,\n        //otherwise, when dragged outside an iframe, the mouseup doesn\'t bubble up so it could seem "stuck" to the mouse.\n        onPress: onPressTimeline(playhead, 0.5, true),\n        onDrag: function () {\n          let time = timeAtDragStart + pixelToTimeRatio * this.x;\n          if (time < 0) {\n            time = 0;\n          } else if (time > linkedAnimation._dur) {\n            time = linkedAnimation._dur;\n          }\n          if (!skipDragUpdates) {\n            linkedAnimation.time(time);\n          }\n          progressBar.style.width = Math.min(outProgress - inProgress, Math.max(0, time / linkedAnimation._dur * 100 - inProgress)) + "%";\n          timeLabel.innerHTML = time.toFixed(2);\n        },\n        onRelease: function () {\n          paused || linkedAnimation.resume();\n        }\n      })[0],\n      resetInOut = () => {\n        inProgress = 0;\n        outProgress = 100;\n        inPoint.style.left = "0%";\n        outPoint.style.left = "100%";\n        record("in", inProgress);\n        record("out", outProgress);\n        updateProgress(true);\n      },\n      inDrag = _Draggable_js__WEBPACK_IMPORTED_MODULE_0__.Draggable.create(inPoint, {\n        type: "x",\n        cursor: "ew-resize",\n        zIndexBoost: false,\n        allowNativeTouchScrolling: false,\n        allowEventDefault: true,\n        //otherwise, when dragged outside an iframe, the mouseup doesn\'t bubble up so it could seem "stuck" to the mouse.\n        onPress: onPressTimeline(inPoint, 1, true),\n        onDoubleClick: resetInOut,\n        onDrag: function () {\n          inProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;\n          linkedAnimation.progress(inProgress / 100);\n          updateProgress(true);\n        },\n        onRelease: function () {\n          if (inProgress < 0) {\n            inProgress = 0;\n          }\n          _clearSelection();\n          //for responsiveness, convert the px-based transform into %-based left position.\n          inPoint.style.left = inProgress + "%";\n          record("in", inProgress);\n          gsap.set(inPoint, {\n            x: 0,\n            data: "root",\n            display: "block"\n          }); //set display:block so that it remains visible even when the minimal skin is enabled.\n          if (!paused) {\n            linkedAnimation.resume();\n          }\n        }\n      })[0],\n      outDrag = _Draggable_js__WEBPACK_IMPORTED_MODULE_0__.Draggable.create(outPoint, {\n        type: "x",\n        cursor: "ew-resize",\n        allowNativeTouchScrolling: false,\n        allowEventDefault: true,\n        //otherwise, when dragged outside an iframe, the mouseup doesn\'t bubble up so it could seem "stuck" to the mouse.\n        zIndexBoost: false,\n        onPress: onPressTimeline(outPoint, 0, true),\n        onDoubleClick: resetInOut,\n        onDrag: function () {\n          outProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;\n          linkedAnimation.progress(outProgress / 100);\n          updateProgress(true);\n        },\n        onRelease: function () {\n          if (outProgress > 100) {\n            outProgress = 100;\n          }\n          _clearSelection();\n          //for responsiveness, convert the px-based transform into %-based left position.\n          outPoint.style.left = outProgress + "%";\n          record("out", outProgress);\n          gsap.set(outPoint, {\n            x: 0,\n            data: "root",\n            display: "block"\n          }); //set display:block so that it remains visible even when the minimal skin is enabled.\n          if (!pausedWhenDragStarted) {\n            play();\n            linkedAnimation.resume();\n          }\n        }\n      })[0],\n      updateProgress = function (force) {\n        // NOTE: "force" is actually the "time" when this method gets called by the gsap.ticker!\n        if (progressDrag.isPressed && force !== true) {\n          return;\n        }\n        let p = !loopEnabled && selectedAnimation._repeat === -1 ? selectedAnimation.totalTime() / selectedAnimation.duration() * 100 : linkedAnimation.progress() * 100 || 0,\n          repeatDelayPhase = selectedAnimation._repeat && selectedAnimation._rDelay && selectedAnimation.totalTime() % (selectedAnimation.duration() + selectedAnimation._rDelay) > selectedAnimation.duration(),\n          target;\n        if (p > 100) {\n          p = 100;\n        }\n        if (p >= outProgress) {\n          if (loopEnabled && !linkedAnimation.paused() && !progressDrag.isDragging) {\n            if (!repeatDelayPhase) {\n              p = inProgress;\n              target = linkedAnimation._targets && linkedAnimation._targets[0];\n              if (target === selectedAnimation) {\n                //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn\'t drag [backward] past those and trigger them.\n                target.seek(startTime + (endTime - startTime) * inProgress / 100);\n              }\n              if (selectedAnimation._repeat > 0 && !inProgress && outProgress === 100) {\n                if (selectedAnimation.totalProgress() === 1) {\n                  linkedAnimation.totalProgress(0, true).resume();\n                }\n              } else {\n                linkedAnimation.progress(p / 100, true).resume();\n              }\n            }\n          } else {\n            if (p !== outProgress || selectedAnimation._repeat === -1) {\n              p = outProgress;\n              linkedAnimation.progress(p / 100);\n            }\n            if (!paused && (outProgress < 100 || selectedAnimation.totalProgress() === 1 || selectedAnimation._repeat === -1)) {\n              pause();\n            }\n          }\n        } else if (p < inProgress) {\n          p = inProgress;\n          linkedAnimation.progress(p / 100, true);\n        }\n        if (p !== progress || force === true) {\n          progressBar.style.left = inProgress + "%";\n          progressBar.style.width = Math.max(0, p - inProgress) + "%";\n          playhead.style.left = p + "%";\n          timeLabel.innerHTML = linkedAnimation._time.toFixed(2);\n          durationLabel.innerHTML = linkedAnimation._dur.toFixed(2);\n          if (dragged) {\n            playhead.style.transform = "translate(-50%,0)";\n            playhead._gsap.x = "0px";\n            playhead._gsap.xPercent = -50;\n            dragged = false;\n          }\n          progress = p;\n        }\n        linkedAnimation.paused() !== paused && togglePlayPause(); // if the user has an addPause() in the middle of the animation.\n      },\n      onPressSeekBar = function (e) {\n        if (progressDrag.isPressed) {\n          return;\n        }\n        let bounds = e.target.getBoundingClientRect(),\n          x = (e.changedTouches ? e.changedTouches[0] : e).clientX,\n          p = (x - bounds.left) / bounds.width * 100;\n        if (p < inProgress) {\n          inProgress = p = Math.max(0, p);\n          inPoint.style.left = inProgress + "%";\n          inDrag.startDrag(e);\n          return;\n        } else if (p > outProgress) {\n          outProgress = p = Math.min(100, p);\n          outPoint.style.left = outProgress + "%";\n          outDrag.startDrag(e);\n          return;\n        }\n        linkedAnimation.progress(p / 100).pause();\n        updateProgress(true);\n        progressDrag.startDrag(e);\n      },\n      //PLAY/PAUSE button\n      play = () => {\n        if (linkedAnimation.progress() >= outProgress / 100) {\n          _checkIndependence(linkedAnimation, vars);\n          let target = linkedAnimation._targets && linkedAnimation._targets[0];\n          if (target === selectedAnimation) {\n            //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn\'t drag [backward] past those and trigger them.\n            target.seek(startTime + (endTime - startTime) * inProgress / 100);\n          }\n          if (linkedAnimation._repeat && !inProgress) {\n            linkedAnimation.totalProgress(0, true); //for repeating animations, don\'t get stuck in the last iteration - jump all the way back to the start.\n          } else if (!linkedAnimation.reversed()) {\n            linkedAnimation.progress(inProgress / 100, true);\n          }\n        }\n        playPauseMorph.play();\n        linkedAnimation.resume();\n        if (paused) {\n          _self.update();\n        }\n        paused = false;\n      },\n      pause = () => {\n        playPauseMorph.reverse();\n        if (linkedAnimation) {\n          linkedAnimation.pause();\n        }\n        paused = true;\n      },\n      togglePlayPause = () => {\n        if (paused) {\n          play();\n        } else {\n          pause();\n        }\n      },\n      //REWIND button\n      onPressRewind = e => {\n        if (progressDrag.isPressed) {\n          return;\n        }\n        //_self.update();\n        _checkIndependence(linkedAnimation, vars);\n        let target = linkedAnimation._targets && linkedAnimation._targets[0];\n        if (target === selectedAnimation) {\n          //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn\'t drag [backward] past those and trigger them.\n          target.seek(startTime + (endTime - startTime) * inProgress / 100);\n        }\n        linkedAnimation.progress(inProgress / 100, true);\n        if (!paused) {\n          linkedAnimation.resume();\n        }\n      },\n      //LOOP button\n      loop = value => {\n        loopEnabled = value;\n        record("loop", loopEnabled);\n        if (loopEnabled) {\n          loopAnimation.play();\n          if (linkedAnimation.progress() >= outProgress / 100) {\n            let target = linkedAnimation._targets && linkedAnimation._targets[0];\n            if (target === selectedAnimation) {\n              //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn\'t drag [backward] past those and trigger them.\n              target.seek(startTime + (endTime - startTime) * inProgress / 100);\n            }\n            if (selectedAnimation._repeat && !inProgress && outProgress === 100) {\n              linkedAnimation.totalProgress(0, true);\n            } else {\n              linkedAnimation.progress(inProgress / 100, true);\n            }\n            play();\n          }\n        } else {\n          loopAnimation.reverse();\n        }\n      },\n      toggleLoop = () => loop(!loopEnabled),\n      //ANIMATIONS list\n      updateList = () => {\n        let animations = _getChildrenOf(declaredAnimation && !vars.globalSync ? declaredAnimation : _recordedRoot, true),\n          options = list.children,\n          matches = 0,\n          option,\n          i;\n        if (declaredAnimation && !vars.globalSync) {\n          animations.unshift(declaredAnimation);\n        } else if (!vars.hideGlobalTimeline) {\n          animations.unshift(_recordedRoot);\n        }\n        for (i = 0; i < animations.length; i++) {\n          option = options[i] || _createElement("option", list);\n          option.animation = animations[i];\n          matches = i && animations[i].vars.id === animations[i - 1].vars.id ? matches + 1 : 0;\n          option.setAttribute("value", option.innerHTML = animations[i].vars.id + (matches ? " [" + matches + "]" : animations[i + 1] && animations[i + 1].vars.id === animations[i].vars.id ? " [0]" : ""));\n        }\n        for (; i < options.length; i++) {\n          list.removeChild(options[i]);\n        }\n      },\n      animation = function (anim) {\n        let ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,\n          tl,\n          maxDuration;\n        if (!arguments.length) {\n          return selectedAnimation;\n        }\n        if (_isString(anim)) {\n          anim = _getAnimationById(anim);\n        }\n        //console.log("animation() ", anim.vars.id);\n        if (!(anim instanceof Animation)) {\n          console.warn("GSDevTools error: invalid animation.");\n        }\n        if (anim === selectedAnimation) {\n          return;\n        }\n        if (selectedAnimation) {\n          selectedAnimation._inProgress = inProgress;\n          selectedAnimation._outProgress = outProgress;\n        }\n        selectedAnimation = anim;\n        if (linkedAnimation) {\n          ts = linkedAnimation.timeScale();\n          if (linkedAnimation._targets && linkedAnimation._targets[0] === declaredAnimation) {\n            declaredAnimation.resume();\n            linkedAnimation.kill();\n          }\n        }\n        inProgress = selectedAnimation._inProgress || 0;\n        outProgress = selectedAnimation._outProgress || 100;\n        inPoint.style.left = inProgress + "%";\n        outPoint.style.left = outProgress + "%";\n        if (_fullyInitialized) {\n          //don\'t record inProgress/outProgress unless we\'re fully instantiated because people may call GSDevTools.create() before creating/defining their animations, thus the inTime/outTime may not exist yet.\n          record("animation", selectedAnimation.vars.id);\n          record("in", inProgress);\n          record("out", outProgress);\n        }\n        startTime = 0;\n        maxDuration = vars.maxDuration || Math.min(1000, _getClippedDuration(selectedAnimation));\n        if (selectedAnimation === _recordedRoot || vars.globalSync) {\n          _merge();\n          linkedAnimation = _rootTween;\n          _rootInstance && _rootInstance !== _self && console.warn("Error: GSDevTools can only have one instance that\'s globally synchronized.");\n          _rootInstance = _self;\n          if (selectedAnimation !== _recordedRoot) {\n            tl = selectedAnimation;\n            endTime = tl.totalDuration();\n            if (endTime > 99999999) {\n              //in the case of an infinitely repeating animation, just use a single iteration\'s duration instead.\n              endTime = tl.duration();\n            }\n            while (tl.parent.parent) {\n              startTime = startTime / tl._ts + tl._start;\n              endTime = endTime / tl._ts + tl._start;\n              tl = tl.parent;\n            }\n          } else {\n            endTime = _recordedRoot.duration();\n          }\n          if (endTime - startTime > maxDuration) {\n            //cap end time at 1000 because it doesn\'t seem reasonable to accommodate super long stuff.\n            endTime = startTime + maxDuration;\n          }\n          _recordedRoot.pause(startTime);\n          _rootTween.vars.time = endTime;\n          _rootTween.invalidate();\n          _rootTween.duration(endTime - startTime).timeScale(ts);\n          //wait for a tick before starting because some browsers freeze things immediately following a <select> selection, like on MacOS it flashes a few times before disappearing, so this prevents a "jump".\n          if (paused) {\n            //jump forward and then back in order to make sure the start/end values are recorded internally right away and don\'t drift outside this tween.\n            _rootTween.progress(1).pause(0);\n          } else {\n            _delayedCall(0.01, () => {\n              _rootTween.resume().progress(inProgress / 100);\n              if (paused) {\n                play();\n              }\n            });\n          }\n        } else {\n          if (_rootInstance === _self) {\n            _rootInstance = null;\n          }\n          if (selectedAnimation === declaredAnimation || !declaredAnimation) {\n            linkedAnimation = selectedAnimation;\n            if (!loopEnabled && linkedAnimation._repeat) {\n              loop(true);\n            }\n          } else {\n            //if an animation is declared in the config object, and the user chooses a sub-animation (nested), we tween the playhead of the declaredAnimation to keep everything synchronized even though globalSync isn\'t true.\n            tl = selectedAnimation;\n            endTime = tl.totalDuration();\n            if (endTime > 99999999) {\n              //in the case of an infinitely repeating animation, just use a single iteration\'s duration instead.\n              endTime = tl.duration();\n            }\n            while (tl.parent.parent && tl !== declaredAnimation) {\n              startTime = startTime / (tl._ts || tl._pauseTS) + tl._start;\n              endTime = endTime / (tl._ts || tl._pauseTS) + tl._start;\n              tl = tl.parent;\n            }\n            if (endTime - startTime > maxDuration) {\n              //cap end time at 1000 because it doesn\'t seem reasonable to accommodate super long stuff.\n              endTime = startTime + maxDuration;\n            }\n            declaredAnimation.pause(startTime);\n            linkedAnimation = gsap.to(declaredAnimation, {\n              duration: endTime - startTime,\n              time: endTime,\n              ease: "none",\n              data: "root",\n              parent: _independentRoot\n            });\n          }\n          linkedAnimation.timeScale(ts);\n          _rootTween.pause();\n          _recordedRoot.resume();\n          linkedAnimation.seek(0);\n        }\n        durationLabel.innerHTML = linkedAnimation.duration().toFixed(2);\n        _selectValue(list, selectedAnimation.vars.id, animationLabel);\n      },\n      updateRootDuration = () => {\n        let time, ratio, duration;\n        if (selectedAnimation === _recordedRoot) {\n          time = _recordedRoot._time;\n          _recordedRoot.progress(1, true).time(time, true); //jump to the end and back again because sometimes a tween that hasn\'t rendered yet will affect duration, like a TimelineMax.tweenTo() where the duration gets set in the onStart.\n          time = (_rootTween._dp._time - _rootTween._start) * _rootTween._ts;\n          duration = Math.min(1000, _recordedRoot.duration());\n          if (duration === 1000) {\n            duration = Math.min(1000, _getClippedDuration(_recordedRoot));\n          }\n          ratio = _rootTween.duration() / duration;\n          if (ratio !== 1 && duration) {\n            inProgress *= ratio;\n            if (outProgress < 100) {\n              outProgress *= ratio;\n            }\n            _rootTween.seek(0);\n            _rootTween.vars.time = duration;\n            _rootTween.invalidate();\n            _rootTween.duration(duration);\n            _rootTween.time(time);\n            durationLabel.innerHTML = duration.toFixed(2);\n            inPoint.style.left = inProgress + "%";\n            outPoint.style.left = outProgress + "%";\n            updateProgress(true);\n          }\n        }\n      },\n      onChangeAnimation = e => {\n        animation(list.options[list.selectedIndex].animation);\n        if (e.target && e.target.blur) {\n          //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn\'t just try selecting something else in the <select>.\n          e.target.blur();\n        }\n        paused && play();\n      },\n      //TIMESCALE button\n      onChangeTimeScale = e => {\n        let ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,\n          target;\n        linkedAnimation.timeScale(ts);\n        record("timeScale", ts);\n        if (!paused) {\n          if (linkedAnimation.progress() >= outProgress / 100) {\n            target = linkedAnimation._targets && linkedAnimation._targets[0];\n            if (target === selectedAnimation) {\n              //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn\'t drag [backward] past those and trigger them.\n              target.seek(startTime + (endTime - startTime) * inProgress / 100);\n            }\n            linkedAnimation.progress(inProgress / 100, true).pause();\n          } else {\n            linkedAnimation.pause();\n          }\n          _delayedCall(0.01, () => linkedAnimation.resume());\n        }\n        timeScaleLabel.innerHTML = ts + "x";\n        if (timeScale.blur) {\n          //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn\'t just try selecting something else in the <select>.\n          timeScale.blur();\n        }\n      },\n      //AUTOHIDE\n      autoHideTween = gsap.to([find(".gs-bottom"), find(".gs-top")], {\n        duration: 0.3,\n        autoAlpha: 0,\n        y: 50,\n        ease: "power2.in",\n        data: "root",\n        paused: true,\n        parent: _independentRoot\n      }),\n      hidden = false,\n      onMouseOut = e => {\n        if (!_Draggable_js__WEBPACK_IMPORTED_MODULE_0__.Draggable.hitTest(e, root) && !progressDrag.isDragging && !inDrag.isDragging && !outDrag.isDragging) {\n          autoHideDelayedCall.restart(true);\n        }\n      },\n      hide = () => {\n        if (!hidden) {\n          autoHideTween.play();\n          autoHideDelayedCall.pause();\n          hidden = true;\n        }\n      },\n      show = () => {\n        autoHideDelayedCall.pause();\n        if (hidden) {\n          autoHideTween.reverse();\n          hidden = false;\n        }\n      },\n      toggleHide = () => {\n        if (hidden) {\n          show();\n        } else {\n          hide();\n        }\n      },\n      autoHideDelayedCall = _delayedCall(1.3, hide).pause(),\n      initialize = preliminary => {\n        //if on startup, someone does a timeline.seek(), we must honor it, so when initialize() is called, we record _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).\n        if (_startupPhase && !_globalStartTime) {\n          _globalStartTime = _recordedRoot._start;\n        }\n        _fullyInitialized = !preliminary;\n        declaredAnimation = _parseAnimation(vars.animation);\n        if (declaredAnimation && !declaredAnimation.vars.id) {\n          declaredAnimation.vars.id = "[no id]";\n        }\n        _merge();\n        updateList();\n        let savedAnimation = _getAnimationById(recall("animation"));\n        if (savedAnimation) {\n          savedAnimation._inProgress = recall("in") || 0;\n          savedAnimation._outProgress = recall("out") || 100;\n        }\n        vars.paused && pause();\n        selectedAnimation = null;\n        animation(declaredAnimation || savedAnimation || _recordedRoot);\n        let ts = vars.timeScale || recall("timeScale"),\n          savedInOut = savedAnimation === selectedAnimation;\n        if (ts) {\n          _selectValue(timeScale, ts, timeScaleLabel, ts + "x");\n          linkedAnimation.timeScale(ts);\n        }\n        inProgress = ("inTime" in vars ? _timeToProgress(vars.inTime, selectedAnimation, 0, 0) : savedInOut ? savedAnimation._inProgress : 0) || 0;\n        if (inProgress === 100 && !vars.animation && savedAnimation) {\n          //in case there\'s a recorded animation (sessionStorage) and then the user defines an inTime that exceeds that animation\'s duration, just default back to the Global Timeline. Otherwise the in/out point will be at the very end and it\'d be weird.\n          animation(_recordedRoot);\n          inProgress = _timeToProgress(vars.inTime, selectedAnimation, 0, 0) || 0;\n        }\n        if (inProgress) {\n          inPoint.style.left = inProgress + "%";\n          inPoint.style.display = outPoint.style.display = "block"; //set display:block so that it remains visible even when the minimal skin is enabled.\n        }\n        outProgress = ("outTime" in vars ? _timeToProgress(vars.outTime, selectedAnimation, 100, inProgress) : savedInOut ? savedAnimation._outProgress : 0) || 100;\n        if (outProgress < inProgress) {\n          outProgress = 100;\n        }\n        if (outProgress !== 100) {\n          outPoint.style.left = outProgress + "%";\n          inPoint.style.display = outPoint.style.display = "block"; //set display:block so that it remains visible even when the minimal skin is enabled.\n        }\n        loopEnabled = "loop" in vars ? vars.loop : recall("loop");\n        loopEnabled && loop(true);\n        vars.paused && linkedAnimation.progress(inProgress / 100, true).pause();\n        if (_startupPhase && selectedAnimation === _recordedRoot && _globalStartTime && vars.globalSync && !paused) {\n          linkedAnimation.time(-_globalStartTime, true);\n        }\n        updateProgress(true);\n      };\n\n    //INITIALIZATION TASKS\n    _addListener(list, "change", onChangeAnimation);\n    _addListener(list, "mousedown", updateList);\n    _addListener(playPauseButton, "mousedown", togglePlayPause);\n    _addListener(find(".seek-bar"), "mousedown", onPressSeekBar);\n    _addListener(find(".rewind"), "mousedown", onPressRewind);\n    _addListener(loopButton, "mousedown", toggleLoop);\n    _addListener(timeScale, "change", onChangeTimeScale);\n    if (vars.visibility === "auto") {\n      _addListener(root, "mouseout", onMouseOut);\n      //_addListener(find(".gs-hit-area"), "mouseover", show);\n      _addListener(root, "mouseover", show);\n    } else if (vars.visibility === "hidden") {\n      hidden = true;\n      autoHideTween.progress(1);\n    }\n    if (vars.keyboard !== false) {\n      if (_keyboardInstance && vars.keyboard) {\n        console.warn("[GSDevTools warning] only one instance can be affected by keyboard shortcuts. There is already one active.");\n      } else {\n        _keyboardInstance = _self; //we can\'t have multiple instances all affected by the keyboard.\n        keyboardHandler = e => {\n          //window.parent allows things to work inside of an iframe, like on codepen.\n          let key = e.keyCode ? e.keyCode : e.which,\n            ts;\n          if (key === 32) {\n            //spacebar\n            togglePlayPause();\n          } else if (key === 38) {\n            //up arrow\n            ts = parseFloat(_shiftSelectedValue(timeScale, -1, timeScaleLabel));\n            linkedAnimation.timeScale(ts);\n            record("timeScale", ts);\n          } else if (key === 40) {\n            //down arrow\n            ts = parseFloat(_shiftSelectedValue(timeScale, 1, timeScaleLabel));\n            linkedAnimation.timeScale(ts);\n            record("timeScale", ts);\n          } else if (key === 37) {\n            //left arrow\n            onPressRewind(e);\n          } else if (key === 39) {\n            //right arrow\n            linkedAnimation.progress(outProgress / 100);\n          } else if (key === 76) {\n            //"L" key\n            toggleLoop();\n          } else if (key === 72) {\n            //"H" key\n            toggleHide();\n          } else if (key === 73) {\n            //"I" key\n            inProgress = linkedAnimation.progress() * 100;\n            record("in", inProgress);\n            inPoint.style.left = inProgress + "%";\n            updateProgress(true);\n          } else if (key === 79) {\n            //"O" key\n            outProgress = linkedAnimation.progress() * 100;\n            record("out", outProgress);\n            outPoint.style.left = outProgress + "%";\n            updateProgress(true);\n          }\n        };\n        _addListener(_docEl, "keydown", keyboardHandler);\n      }\n    }\n    gsap.set(playhead, {\n      xPercent: -50,\n      x: 0,\n      data: "root"\n    }); //so that when we drag, x is properly discerned (browsers report in pure pixels rather than percents)\n    gsap.set(inPoint, {\n      xPercent: -100,\n      x: 0,\n      data: "root"\n    });\n    inPoint._gsIgnore = outPoint._gsIgnore = playhead._gsIgnore = playPauseButton._gsIgnore = loopButton._gsIgnore = true;\n\n    //Draggable fires off a TweenLite.set() that affects the transforms, and we don\'t want them to get into the _recordedRoot, so kill those tweens.\n    gsap.killTweensOf([inPoint, outPoint, playhead]);\n    initialize(_startupPhase);\n    if (_startupPhase) {\n      //developers may call GSDevTools.create() before they even create some of their animations, so the inTime/outTime or animation values may not exist, thus we wait for 1 tick and initialize again, just in case.\n      _delayedCall(0.0001, initialize, [false], this);\n    }\n    gsap.ticker.add(updateProgress);\n    this.update = forceMerge => {\n      if (_rootInstance === _self) {\n        if (!_rootTween.paused() || forceMerge) {\n          _merge();\n        }\n        updateRootDuration();\n      }\n    };\n    this.kill = () => {\n      _removeListener(list, "change", onChangeAnimation);\n      _removeListener(list, "mousedown", updateList);\n      _removeListener(playPauseButton, "mousedown", togglePlayPause);\n      _removeListener(find(".seek-bar"), "mousedown", onPressSeekBar);\n      _removeListener(find(".rewind"), "mousedown", onPressRewind);\n      _removeListener(loopButton, "mousedown", toggleLoop);\n      _removeListener(timeScale, "change", onChangeTimeScale);\n      progressDrag.disable();\n      inDrag.disable();\n      outDrag.disable();\n      gsap.ticker.remove(updateProgress);\n      _removeListener(root, "mouseout", onMouseOut);\n      _removeListener(root, "mouseover", show);\n      _removeListener(_docEl, "keydown", keyboardHandler);\n      root.parentNode.removeChild(root);\n      if (_rootInstance === _self) {\n        _rootInstance = null;\n      }\n      delete _lookup[vars.id + ""];\n    };\n    this.minimal = function (value) {\n      let isMinimal = root.classList.contains("minimal"),\n        p;\n      if (!arguments.length || isMinimal === value) {\n        return isMinimal;\n      }\n      if (value) {\n        root.classList.add("minimal");\n      } else {\n        root.classList.remove("minimal");\n      }\n      if (vars.container) {\n        root.style.top = value ? "calc(100% - 42px)" : "calc(100% - 51px)";\n      }\n      if (progressDrag.isPressed) {\n        skipDragUpdates = true; //just in case there\'s actually a tween/timeline in the linkedAnimation that is altering this GSDevTool instance\'s "minimal()" value, it could trigger a recursive loop in the drag handlers, like if they update linkedAnimation\'s time/progress which in turn triggers this minimal() function which in turn dues the same, and so on.\n        progressDrag.endDrag(progressDrag.pointerEvent);\n        skipDragUpdates = false;\n        p = linkedAnimation.progress() * 100;\n        progressBar.style.width = Math.max(0, p - inProgress) + "%";\n        playhead.style.left = p + "%";\n        playhead.style.transform = "translate(-50%,0)";\n        playhead._gsap.x = "0px";\n        playhead._gsap.xPercent = -50;\n        progressDrag.startDrag(progressDrag.pointerEvent, true);\n      }\n    };\n\n    //expose methods:\n    this.animation = animation;\n    this.updateList = updateList;\n  }; //if on startup, someone does a timeline.seek(), we need to honor it, so when initialize() is called, it\'ll check the _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).\n\nGSDevTools.version = "3.6.1";\nGSDevTools.globalRecordingTime = 2;\nGSDevTools.getById = id => id ? _lookup[id] : _rootInstance;\nGSDevTools.getByAnimation = animation => {\n  if (_isString(animation)) {\n    animation = gsap.getById(animation);\n  }\n  for (let p in _lookup) {\n    if (_lookup[p].animation() === animation) {\n      return _lookup[p];\n    }\n  }\n};\nGSDevTools.create = vars => new GSDevTools(vars);\nGSDevTools.register = _initCore;\n_getGSAP() && gsap.registerPlugin(GSDevTools);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/GSDevTools.js?')},"./build/scripts/vendor/gsap/src/InertiaPlugin.js":
/*!********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/InertiaPlugin.js ***!
  \********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InertiaPlugin: () => (/* binding */ InertiaPlugin),\n/* harmony export */   VelocityTracker: () => (/* reexport safe */ _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker),\n/* harmony export */   "default": () => (/* binding */ InertiaPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/VelocityTracker.js */ "./build/scripts/vendor/gsap/src/utils/VelocityTracker.js");\n/*!\n * InertiaPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet gsap,\n  _coreInitted,\n  _parseEase,\n  _toArray,\n  _power3,\n  _config,\n  _getUnit,\n  PropTween,\n  _getCache,\n  _checkPointRatio,\n  _clamp,\n  _processingVars,\n  _getTracker = _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker.getByTarget,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isString = value => typeof value === "string",\n  _isNumber = value => typeof value === "number",\n  _isObject = value => typeof value === "object",\n  _isFunction = value => typeof value === "function",\n  _bonusValidated = 1,\n  //<name>InertiaPlugin</name>\n  _isArray = Array.isArray,\n  _emptyFunc = p => p,\n  _bigNum = 1e10,\n  _tinyNum = 1 / _bigNum,\n  _checkPoint = 0.05,\n  _round = value => Math.round(value * 10000) / 10000,\n  _extend = (obj, defaults, exclude) => {\n    for (let p in defaults) {\n      if (!(p in obj) && p !== exclude) {\n        obj[p] = defaults[p];\n      }\n    }\n    return obj;\n  },\n  _deepClone = obj => {\n    let copy = {},\n      p,\n      v;\n    for (p in obj) {\n      copy[p] = _isObject(v = obj[p]) ? _deepClone(v) : v;\n    }\n    return copy;\n  },\n  _getClosest = (n, values, max, min, radius) => {\n    let i = values.length,\n      closest = 0,\n      absDif = _bigNum,\n      val,\n      dif,\n      p,\n      dist;\n    if (_isObject(n)) {\n      while (i--) {\n        val = values[i];\n        dif = 0;\n        for (p in n) {\n          dist = val[p] - n[p];\n          dif += dist * dist;\n        }\n        if (dif < absDif) {\n          closest = i;\n          absDif = dif;\n        }\n      }\n      if ((radius || _bigNum) < _bigNum && radius < Math.sqrt(absDif)) {\n        return n;\n      }\n    } else {\n      while (i--) {\n        val = values[i];\n        dif = val - n;\n        if (dif < 0) {\n          dif = -dif;\n        }\n        if (dif < absDif && val >= min && val <= max) {\n          closest = i;\n          absDif = dif;\n        }\n      }\n    }\n    return values[closest];\n  },\n  _parseEnd = (curProp, end, max, min, name, radius) => {\n    if (curProp.end === "auto") {\n      return curProp;\n    }\n    let endVar = curProp.end,\n      adjustedEnd,\n      p;\n    max = isNaN(max) ? _bigNum : max;\n    min = isNaN(min) ? -_bigNum : min;\n    if (_isObject(end)) {\n      //for objects, like {x, y} where they\'re linked and we must pass an object to the function or find the closest value in an array.\n      adjustedEnd = end.calculated ? end : (_isFunction(endVar) ? endVar(end) : _getClosest(end, endVar, max, min, radius)) || end;\n      if (!end.calculated) {\n        for (p in adjustedEnd) {\n          end[p] = adjustedEnd[p];\n        }\n        end.calculated = true;\n      }\n      adjustedEnd = adjustedEnd[name];\n    } else {\n      adjustedEnd = _isFunction(endVar) ? endVar(end) : _isArray(endVar) ? _getClosest(end, endVar, max, min, radius) : parseFloat(endVar);\n    }\n    if (adjustedEnd > max) {\n      adjustedEnd = max;\n    } else if (adjustedEnd < min) {\n      adjustedEnd = min;\n    }\n    return {\n      max: adjustedEnd,\n      min: adjustedEnd,\n      unitFactor: curProp.unitFactor\n    };\n  },\n  _getNumOrDefault = (vars, property, defaultValue) => isNaN(vars[property]) ? defaultValue : +vars[property],\n  _calculateChange = (velocity, duration) => duration * _checkPoint * velocity / _checkPointRatio,\n  _calculateDuration = (start, end, velocity) => Math.abs((end - start) * _checkPointRatio / velocity / _checkPoint),\n  _reservedProps = {\n    resistance: 1,\n    checkpoint: 1,\n    preventOvershoot: 1,\n    linkedProps: 1,\n    radius: 1,\n    duration: 1\n  },\n  _processLinkedProps = (target, vars, getVal, resistance) => {\n    if (vars.linkedProps) {\n      //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we\'ll do later in the "real" loop.\n      let linkedPropNames = vars.linkedProps.split(","),\n        linkedProps = {},\n        i,\n        p,\n        curProp,\n        curVelocity,\n        tracker,\n        curDuration;\n      for (i = 0; i < linkedPropNames.length; i++) {\n        p = linkedPropNames[i];\n        curProp = vars[p];\n        if (curProp) {\n          if (_isNumber(curProp.velocity)) {\n            curVelocity = curProp.velocity;\n          } else {\n            tracker = tracker || _getTracker(target);\n            curVelocity = tracker && tracker.isTracking(p) ? tracker.get(p) : 0;\n          }\n          curDuration = Math.abs(curVelocity / _getNumOrDefault(curProp, "resistance", resistance));\n          linkedProps[p] = parseFloat(getVal(target, p)) + _calculateChange(curVelocity, curDuration);\n        }\n      }\n      return linkedProps;\n    }\n  },\n  _calculateTweenDuration = function (target, vars) {\n    let maxDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    let minDuration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.2;\n    let overshootTolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    let recordEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    _isString(target) && (target = _toArray(target)[0]);\n    if (!target) {\n      return 0;\n    }\n    let duration = 0,\n      clippedDuration = _bigNum,\n      inertiaVars = vars.inertia || vars,\n      getVal = _getCache(target).get,\n      resistance = _getNumOrDefault(inertiaVars, "resistance", _config.resistance),\n      p,\n      curProp,\n      curDuration,\n      curVelocity,\n      curVal,\n      end,\n      curClippedDuration,\n      tracker,\n      unitFactor,\n      linkedProps;\n\n    //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we\'ll do later in the "real" loop.\n    linkedProps = _processLinkedProps(target, inertiaVars, getVal, resistance);\n    for (p in inertiaVars) {\n      if (!_reservedProps[p]) {\n        curProp = inertiaVars[p];\n        if (!_isObject(curProp)) {\n          tracker = tracker || _getTracker(target);\n          if (tracker && tracker.isTracking(p)) {\n            curProp = _isNumber(curProp) ? {\n              velocity: curProp\n            } : {\n              velocity: tracker.get(p)\n            }; //if we\'re tracking this property, we should use the tracking velocity and then use the numeric value that was passed in as the min and max so that it tweens exactly there.\n          } else {\n            curVelocity = +curProp || 0;\n            curDuration = Math.abs(curVelocity / resistance);\n          }\n        }\n        if (_isObject(curProp)) {\n          if (_isNumber(curProp.velocity)) {\n            curVelocity = curProp.velocity;\n          } else {\n            tracker = tracker || _getTracker(target);\n            curVelocity = tracker && tracker.isTracking(p) ? tracker.get(p) : 0;\n          }\n          curDuration = _clamp(minDuration, maxDuration, Math.abs(curVelocity / _getNumOrDefault(curProp, "resistance", resistance)));\n          curVal = parseFloat(getVal(target, p)) || 0;\n          end = curVal + _calculateChange(curVelocity, curDuration);\n          if ("end" in curProp) {\n            curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, inertiaVars.radius);\n            if (recordEnd) {\n              _processingVars === vars && (_processingVars = inertiaVars = _deepClone(vars));\n              inertiaVars[p] = _extend(curProp, inertiaVars[p], "end");\n            }\n          }\n          if ("max" in curProp && end > +curProp.max + _tinyNum) {\n            unitFactor = curProp.unitFactor || _config.unitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.\n            //if the value is already exceeding the max or the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive. If the max and min match, it means we\'re animating to a particular value and we don\'t want to shorten the time unless the velocity is really slow. Example: a rotation where the start and natural end value are less than the snapping spot, but the natural end is pretty close to the snap.\n            curClippedDuration = curVal > curProp.max && curProp.min !== curProp.max || curVelocity * unitFactor > -15 && curVelocity * unitFactor < 45 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.max, curVelocity);\n            if (curClippedDuration + overshootTolerance < clippedDuration) {\n              clippedDuration = curClippedDuration + overshootTolerance;\n            }\n          } else if ("min" in curProp && end < +curProp.min - _tinyNum) {\n            unitFactor = curProp.unitFactor || _config.unitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.\n            //if the value is already exceeding the min or if the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive.\n            curClippedDuration = curVal < curProp.min && curProp.min !== curProp.max || curVelocity * unitFactor > -45 && curVelocity * unitFactor < 15 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.min, curVelocity);\n            if (curClippedDuration + overshootTolerance < clippedDuration) {\n              clippedDuration = curClippedDuration + overshootTolerance;\n            }\n          }\n          curClippedDuration > duration && (duration = curClippedDuration);\n        }\n        curDuration > duration && (duration = curDuration);\n      }\n    }\n    duration > clippedDuration && (duration = clippedDuration);\n    return duration > maxDuration ? maxDuration : duration < minDuration ? minDuration : duration;\n  },\n  _initCore = () => {\n    gsap = _getGSAP();\n    if (gsap) {\n      _parseEase = gsap.parseEase;\n      _toArray = gsap.utils.toArray;\n      _getUnit = gsap.utils.getUnit;\n      _getCache = gsap.core.getCache;\n      _clamp = gsap.utils.clamp;\n      _power3 = _parseEase("power3");\n      _checkPointRatio = _power3(0.05);\n      PropTween = gsap.core.PropTween;\n      gsap.config({\n        resistance: 100,\n        unitFactors: {\n          time: 1000,\n          totalTime: 1000,\n          progress: 1000,\n          totalProgress: 1000\n        }\n      });\n      _config = gsap.config();\n      gsap.registerPlugin(_utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker);\n      _coreInitted = 1;\n    }\n  };\nconst InertiaPlugin = {\n  version: "3.6.1",\n  name: "inertia",\n  register(core) {\n    gsap = core;\n    _initCore();\n  },\n  init(target, vars, tween, index, targets) {\n    _coreInitted || _initCore();\n    let tracker = _getTracker(target);\n    if (vars === "auto") {\n      if (!tracker) {\n        console.warn("No inertia tracking on " + target + ". InertiaPlugin.track(target) first.");\n        return;\n      }\n      vars = tracker.getAll();\n    }\n    this.target = target;\n    this.tween = tween;\n    _processingVars = vars; // gets swapped inside _calculateTweenDuration() if there\'s a function-based value encountered (to avoid double-calling it)\n    let cache = target._gsap,\n      getVal = cache.get,\n      dur = vars.duration,\n      durIsObj = _isObject(dur),\n      preventOvershoot = vars.preventOvershoot || durIsObj && dur.overshoot === 0,\n      resistance = _getNumOrDefault(vars, "resistance", _config.resistance),\n      duration = _isNumber(dur) ? dur : _calculateTweenDuration(target, vars, durIsObj && dur.max || 10, durIsObj && dur.min || 0.2, durIsObj && "overshoot" in dur ? +dur.overshoot : preventOvershoot ? 0 : 1, true),\n      p,\n      curProp,\n      curVal,\n      unit,\n      velocity,\n      change1,\n      end,\n      change2,\n      linkedProps;\n    vars = _processingVars;\n    _processingVars = 0;\n    //when there are linkedProps (typically "x,y" where snapping has to factor in multiple properties, we must first populate an object with all of those end values, then feed it to the function that make any necessary alterations. So the point of this first loop is to simply build an object (like {x:100, y:204.5}) for feeding into that function which we\'ll do later in the "real" loop.\n    linkedProps = _processLinkedProps(target, vars, getVal, resistance);\n    for (p in vars) {\n      if (!_reservedProps[p]) {\n        curProp = vars[p];\n        _isFunction(curProp) && (curProp = curProp(index, target, targets));\n        if (_isNumber(curProp)) {\n          velocity = curProp;\n        } else if (_isObject(curProp) && !isNaN(curProp.velocity)) {\n          velocity = +curProp.velocity;\n        } else {\n          if (tracker && tracker.isTracking(p)) {\n            velocity = tracker.get(p);\n          } else {\n            console.warn("ERROR: No velocity was defined for " + target + " property: " + p);\n          }\n        }\n        change1 = _calculateChange(velocity, duration);\n        change2 = 0;\n        curVal = getVal(target, p);\n        unit = _getUnit(curVal);\n        curVal = parseFloat(curVal);\n        if (_isObject(curProp)) {\n          end = curVal + change1;\n          if ("end" in curProp) {\n            curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, vars.radius);\n          }\n          if ("max" in curProp && +curProp.max < end) {\n            if (preventOvershoot || curProp.preventOvershoot) {\n              change1 = curProp.max - curVal;\n            } else {\n              change2 = curProp.max - curVal - change1;\n            }\n          } else if ("min" in curProp && +curProp.min > end) {\n            if (preventOvershoot || curProp.preventOvershoot) {\n              change1 = curProp.min - curVal;\n            } else {\n              change2 = curProp.min - curVal - change1;\n            }\n          }\n        }\n        this._props.push(p);\n        this._pt = new PropTween(this._pt, target, p, curVal, 0, _emptyFunc, 0, cache.set(target, p, this));\n        this._pt.u = unit || 0;\n        this._pt.c1 = change1;\n        this._pt.c2 = change2;\n      }\n    }\n    tween.duration(duration);\n    return _bonusValidated;\n  },\n  render(ratio, data) {\n    let pt = data._pt;\n    ratio = _power3(data.tween._time / data.tween._dur);\n    while (pt) {\n      pt.set(pt.t, pt.p, _round(pt.s + pt.c1 * ratio + pt.c2 * ratio * ratio) + pt.u, pt.d, ratio);\n      pt = pt._next;\n    }\n  }\n};\n"track,untrack,isTracking,getVelocity,getByTarget".split(",").forEach(name => InertiaPlugin[name] = _utils_VelocityTracker_js__WEBPACK_IMPORTED_MODULE_0__.VelocityTracker[name]);\n_getGSAP() && gsap.registerPlugin(InertiaPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/InertiaPlugin.js?')},"./build/scripts/vendor/gsap/src/MorphSVGPlugin.js":
/*!*********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/MorphSVGPlugin.js ***!
  \*********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MorphSVGPlugin: () => (/* binding */ MorphSVGPlugin),\n/* harmony export */   "default": () => (/* binding */ MorphSVGPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ "./build/scripts/vendor/gsap/src/utils/paths.js");\n/*!\n * MorphSVGPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet gsap,\n  _toArray,\n  _lastLinkedAnchor,\n  _doc,\n  _coreInitted,\n  PluginClass,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isFunction = value => typeof value === "function",\n  _atan2 = Math.atan2,\n  _cos = Math.cos,\n  _sin = Math.sin,\n  _sqrt = Math.sqrt,\n  _PI = Math.PI,\n  _2PI = _PI * 2,\n  _angleMin = _PI * 0.3,\n  _angleMax = _PI * 0.7,\n  _bigNum = 1e20,\n  _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n  _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n  _commands = /[achlmqstvz]/i,\n  _log = message => console && console.warn(message),\n  _bonusValidated = 1,\n  //<name>MorphSVGPlugin</name>\n  _getAverageXY = segment => {\n    let l = segment.length,\n      x = 0,\n      y = 0,\n      i;\n    for (i = 0; i < l; i++) {\n      x += segment[i++];\n      y += segment[i];\n    }\n    return [x / (l / 2), y / (l / 2)];\n  },\n  _getSize = segment => {\n    //rough estimate of the bounding box (based solely on the anchors) of a single segment. sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)\n    let l = segment.length,\n      xMax = segment[0],\n      xMin = xMax,\n      yMax = segment[1],\n      yMin = yMax,\n      x,\n      y,\n      i;\n    for (i = 6; i < l; i += 6) {\n      x = segment[i];\n      y = segment[i + 1];\n      if (x > xMax) {\n        xMax = x;\n      } else if (x < xMin) {\n        xMin = x;\n      }\n      if (y > yMax) {\n        yMax = y;\n      } else if (y < yMin) {\n        yMin = y;\n      }\n    }\n    segment.centerX = (xMax + xMin) / 2;\n    segment.centerY = (yMax + yMin) / 2;\n    return segment.size = (xMax - xMin) * (yMax - yMin);\n  },\n  _getTotalSize = function (rawPath) {\n    let samplesPerBezier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    //rough estimate of the bounding box of the entire list of Bezier segments (based solely on the anchors). sets "size", "centerX", and "centerY" properties on the bezier array itself, and returns the size (width * height)\n    let j = rawPath.length,\n      xMax = rawPath[0][0],\n      xMin = xMax,\n      yMax = rawPath[0][1],\n      yMin = yMax,\n      inc = 1 / samplesPerBezier,\n      l,\n      x,\n      y,\n      i,\n      segment,\n      k,\n      t,\n      inv,\n      x1,\n      y1,\n      x2,\n      x3,\n      x4,\n      y2,\n      y3,\n      y4;\n    while (--j > -1) {\n      segment = rawPath[j];\n      l = segment.length;\n      for (i = 6; i < l; i += 6) {\n        x1 = segment[i];\n        y1 = segment[i + 1];\n        x2 = segment[i + 2] - x1;\n        y2 = segment[i + 3] - y1;\n        x3 = segment[i + 4] - x1;\n        y3 = segment[i + 5] - y1;\n        x4 = segment[i + 6] - x1;\n        y4 = segment[i + 7] - y1;\n        k = samplesPerBezier;\n        while (--k > -1) {\n          t = inc * k;\n          inv = 1 - t;\n          x = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t + x1;\n          y = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t + y1;\n          if (x > xMax) {\n            xMax = x;\n          } else if (x < xMin) {\n            xMin = x;\n          }\n          if (y > yMax) {\n            yMax = y;\n          } else if (y < yMin) {\n            yMin = y;\n          }\n        }\n      }\n    }\n    rawPath.centerX = (xMax + xMin) / 2;\n    rawPath.centerY = (yMax + yMin) / 2;\n    rawPath.left = xMin;\n    rawPath.width = xMax - xMin;\n    rawPath.top = yMin;\n    rawPath.height = yMax - yMin;\n    return rawPath.size = (xMax - xMin) * (yMax - yMin);\n  },\n  _sortByComplexity = (a, b) => b.length - a.length,\n  _sortBySize = (a, b) => {\n    let sizeA = a.size || _getSize(a),\n      sizeB = b.size || _getSize(b);\n    return Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20 ? b.centerX - a.centerX || b.centerY - a.centerY : sizeB - sizeA; //if the size is within 10% of each other, prioritize position from left to right, then top to bottom.\n  },\n  _offsetSegment = (segment, shapeIndex) => {\n    let a = segment.slice(0),\n      l = segment.length,\n      wrap = l - 2,\n      i,\n      index;\n    shapeIndex = shapeIndex | 0;\n    for (i = 0; i < l; i++) {\n      index = (i + shapeIndex) % wrap;\n      segment[i++] = a[index];\n      segment[i] = a[index + 1];\n    }\n  },\n  _getTotalMovement = (sb, eb, shapeIndex, offsetX, offsetY) => {\n    let l = sb.length,\n      d = 0,\n      wrap = l - 2,\n      index,\n      i,\n      x,\n      y;\n    shapeIndex *= 6;\n    for (i = 0; i < l; i += 6) {\n      index = (i + shapeIndex) % wrap;\n      y = sb[index] - (eb[i] - offsetX);\n      x = sb[index + 1] - (eb[i + 1] - offsetY);\n      d += _sqrt(x * x + y * y);\n    }\n    return d;\n  },\n  _getClosestShapeIndex = (sb, eb, checkReverse) => {\n    //finds the index in a closed cubic bezier array that\'s closest to the angle provided (angle measured from the center or average x/y).\n    let l = sb.length,\n      sCenter = _getAverageXY(sb),\n      //when comparing distances, adjust the coordinates as if the shapes are centered with each other.\n      eCenter = _getAverageXY(eb),\n      offsetX = eCenter[0] - sCenter[0],\n      offsetY = eCenter[1] - sCenter[1],\n      min = _getTotalMovement(sb, eb, 0, offsetX, offsetY),\n      minIndex = 0,\n      copy,\n      d,\n      i;\n    for (i = 6; i < l; i += 6) {\n      d = _getTotalMovement(sb, eb, i / 6, offsetX, offsetY);\n      if (d < min) {\n        min = d;\n        minIndex = i;\n      }\n    }\n    if (checkReverse) {\n      copy = sb.slice(0);\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.reverseSegment)(copy);\n      for (i = 6; i < l; i += 6) {\n        d = _getTotalMovement(copy, eb, i / 6, offsetX, offsetY);\n        if (d < min) {\n          min = d;\n          minIndex = -i;\n        }\n      }\n    }\n    return minIndex / 6;\n  },\n  _getClosestAnchor = (rawPath, x, y) => {\n    //finds the x/y of the anchor that\'s closest to the provided x/y coordinate (returns an array, like [x, y]). The bezier should be the top-level type that contains an array for each segment.\n    let j = rawPath.length,\n      closestDistance = _bigNum,\n      closestX = 0,\n      closestY = 0,\n      segment,\n      dx,\n      dy,\n      d,\n      i,\n      l;\n    while (--j > -1) {\n      segment = rawPath[j];\n      l = segment.length;\n      for (i = 0; i < l; i += 6) {\n        dx = segment[i] - x;\n        dy = segment[i + 1] - y;\n        d = _sqrt(dx * dx + dy * dy);\n        if (d < closestDistance) {\n          closestDistance = d;\n          closestX = segment[i];\n          closestY = segment[i + 1];\n        }\n      }\n    }\n    return [closestX, closestY];\n  },\n  _getClosestSegment = (bezier, pool, startIndex, sortRatio, offsetX, offsetY) => {\n    //matches the bezier to the closest one in a pool (array) of beziers, assuming they are in order of size and we shouldn\'t drop more than 20% of the size, otherwise prioritizing location (total distance to the center). Extracts the segment out of the pool array and returns it.\n    let l = pool.length,\n      index = 0,\n      minSize = Math.min(bezier.size || _getSize(bezier), pool[startIndex].size || _getSize(pool[startIndex])) * sortRatio,\n      //limit things based on a percentage of the size of either the bezier or the next element in the array, whichever is smaller.\n      min = _bigNum,\n      cx = bezier.centerX + offsetX,\n      cy = bezier.centerY + offsetY,\n      size,\n      i,\n      dx,\n      dy,\n      d;\n    for (i = startIndex; i < l; i++) {\n      size = pool[i].size || _getSize(pool[i]);\n      if (size < minSize) {\n        break;\n      }\n      dx = pool[i].centerX - cx;\n      dy = pool[i].centerY - cy;\n      d = _sqrt(dx * dx + dy * dy);\n      if (d < min) {\n        index = i;\n        min = d;\n      }\n    }\n    d = pool[index];\n    pool.splice(index, 1);\n    return d;\n  },\n  _subdivideSegmentQty = (segment, quantity) => {\n    let tally = 0,\n      max = 0.999999,\n      l = segment.length,\n      newPointsPerSegment = quantity / ((l - 2) / 6),\n      ax,\n      ay,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      bx,\n      by,\n      x1,\n      y1,\n      x2,\n      y2,\n      i,\n      t;\n    for (i = 2; i < l; i += 6) {\n      tally += newPointsPerSegment;\n      while (tally > max) {\n        //compare with 0.99999 instead of 1 in order to prevent rounding errors\n        ax = segment[i - 2];\n        ay = segment[i - 1];\n        cp1x = segment[i];\n        cp1y = segment[i + 1];\n        cp2x = segment[i + 2];\n        cp2y = segment[i + 3];\n        bx = segment[i + 4];\n        by = segment[i + 5];\n        t = 1 / ((Math.floor(tally) || 1) + 1); //progress along the bezier (value between 0 and 1)\n        x1 = ax + (cp1x - ax) * t;\n        x2 = cp1x + (cp2x - cp1x) * t;\n        x1 += (x2 - x1) * t;\n        x2 += (cp2x + (bx - cp2x) * t - x2) * t;\n        y1 = ay + (cp1y - ay) * t;\n        y2 = cp1y + (cp2y - cp1y) * t;\n        y1 += (y2 - y1) * t;\n        y2 += (cp2y + (by - cp2y) * t - y2) * t;\n        segment.splice(i, 4, ax + (cp1x - ax) * t,\n        //first control point\n        ay + (cp1y - ay) * t, x1,\n        //second control point\n        y1, x1 + (x2 - x1) * t,\n        //new fabricated anchor on line\n        y1 + (y2 - y1) * t, x2,\n        //third control point\n        y2, cp2x + (bx - cp2x) * t,\n        //fourth control point\n        cp2y + (by - cp2y) * t);\n        i += 6;\n        l += 6;\n        tally--;\n      }\n    }\n    return segment;\n  },\n  _equalizeSegmentQuantity = (start, end, shapeIndex, map, fillSafe) => {\n    //returns an array of shape indexes, 1 for each segment.\n    let dif = end.length - start.length,\n      longer = dif > 0 ? end : start,\n      shorter = dif > 0 ? start : end,\n      added = 0,\n      sortMethod = map === "complexity" ? _sortByComplexity : _sortBySize,\n      sortRatio = map === "position" ? 0 : typeof map === "number" ? map : 0.8,\n      i = shorter.length,\n      shapeIndices = typeof shapeIndex === "object" && shapeIndex.push ? shapeIndex.slice(0) : [shapeIndex],\n      reverse = shapeIndices[0] === "reverse" || shapeIndices[0] < 0,\n      log = shapeIndex === "log",\n      eb,\n      sb,\n      b,\n      x,\n      y,\n      offsetX,\n      offsetY;\n    if (!shorter[0]) {\n      return;\n    }\n    if (longer.length > 1) {\n      start.sort(sortMethod);\n      end.sort(sortMethod);\n      offsetX = longer.size || _getTotalSize(longer); //ensures centerX and centerY are defined (used below).\n      offsetX = shorter.size || _getTotalSize(shorter);\n      offsetX = longer.centerX - shorter.centerX;\n      offsetY = longer.centerY - shorter.centerY;\n      if (sortMethod === _sortBySize) {\n        for (i = 0; i < shorter.length; i++) {\n          longer.splice(i, 0, _getClosestSegment(shorter[i], longer, i, sortRatio, offsetX, offsetY));\n        }\n      }\n    }\n    if (dif) {\n      if (dif < 0) {\n        dif = -dif;\n      }\n      if (longer[0].length > shorter[0].length) {\n        //since we use shorter[0] as the one to map the origination point of any brand new fabricated segments, do any subdividing first so that there are more points to choose from (if necessary)\n        _subdivideSegmentQty(shorter[0], (longer[0].length - shorter[0].length) / 6 | 0);\n      }\n      i = shorter.length;\n      while (added < dif) {\n        x = longer[i].size || _getSize(longer[i]); //just to ensure centerX and centerY are calculated which we use on the next line.\n        b = _getClosestAnchor(shorter, longer[i].centerX, longer[i].centerY);\n        x = b[0];\n        y = b[1];\n        shorter[i++] = [x, y, x, y, x, y, x, y];\n        shorter.totalPoints += 8;\n        added++;\n      }\n    }\n    for (i = 0; i < start.length; i++) {\n      eb = end[i];\n      sb = start[i];\n      dif = eb.length - sb.length;\n      if (dif < 0) {\n        _subdivideSegmentQty(eb, -dif / 6 | 0);\n      } else if (dif > 0) {\n        _subdivideSegmentQty(sb, dif / 6 | 0);\n      }\n      if (reverse && fillSafe !== false && !sb.reversed) {\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.reverseSegment)(sb);\n      }\n      shapeIndex = shapeIndices[i] || shapeIndices[i] === 0 ? shapeIndices[i] : "auto";\n      if (shapeIndex) {\n        //if start shape is closed, find the closest point to the start/end, and re-organize the bezier points accordingly so that the shape morphs in a more intuitive way.\n        if (sb.closed || Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5) {\n          if (shapeIndex === "auto" || shapeIndex === "log") {\n            shapeIndices[i] = shapeIndex = _getClosestShapeIndex(sb, eb, !i || fillSafe === false);\n            if (shapeIndex < 0) {\n              reverse = true;\n              (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.reverseSegment)(sb);\n              shapeIndex = -shapeIndex;\n            }\n            _offsetSegment(sb, shapeIndex * 6);\n          } else if (shapeIndex !== "reverse") {\n            if (i && shapeIndex < 0) {\n              //only happens if an array is passed as shapeIndex and a negative value is defined for an index beyond 0. Very rare, but helpful sometimes.\n              (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.reverseSegment)(sb);\n            }\n            _offsetSegment(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);\n          }\n          //otherwise, if it\'s not a closed shape, consider reversing it if that would make the overall travel less\n        } else if (!reverse && (shapeIndex === "auto" && Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1]) || shapeIndex % 2)) {\n          (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.reverseSegment)(sb);\n          shapeIndices[i] = -1;\n          reverse = true;\n        } else if (shapeIndex === "auto") {\n          shapeIndices[i] = 0;\n        } else if (shapeIndex === "reverse") {\n          shapeIndices[i] = -1;\n        }\n        if (sb.closed !== eb.closed) {\n          //if one is closed and one isn\'t, don\'t close either one otherwise the tweening will look weird (but remember, the beginning and final states will honor the actual values, so this only affects the inbetween state)\n          sb.closed = eb.closed = false;\n        }\n      }\n    }\n    log && _log("shapeIndex:[" + shapeIndices.join(",") + "]");\n    start.shapeIndex = shapeIndices;\n    return shapeIndices;\n  },\n  _pathFilter = (a, shapeIndex, map, precompile, fillSafe) => {\n    let start = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(a[0]),\n      end = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(a[1]);\n    if (!_equalizeSegmentQuantity(start, end, shapeIndex || shapeIndex === 0 ? shapeIndex : "auto", map, fillSafe)) {\n      return; //malformed path data or null target\n    }\n    a[0] = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)(start);\n    a[1] = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)(end);\n    if (precompile === "log" || precompile === true) {\n      _log(\'precompile:["\' + a[0] + \'","\' + a[1] + \'"]\');\n    }\n  },\n  _offsetPoints = (text, offset) => {\n    if (!offset) {\n      return text;\n    }\n    let a = text.match(_numExp) || [],\n      l = a.length,\n      s = "",\n      inc,\n      i,\n      j;\n    if (offset === "reverse") {\n      i = l - 1;\n      inc = -2;\n    } else {\n      i = ((parseInt(offset, 10) || 0) * 2 + 1 + l * 100) % l;\n      inc = 2;\n    }\n    for (j = 0; j < l; j += 2) {\n      s += a[i - 1] + "," + a[i] + " ";\n      i = (i + inc) % l;\n    }\n    return s;\n  },\n  //adds a certain number of points while maintaining the polygon/polyline shape (so that the start/end values can have a matching quantity of points to animate). Returns the revised string.\n  _equalizePointQuantity = (a, quantity) => {\n    let tally = 0,\n      x = parseFloat(a[0]),\n      y = parseFloat(a[1]),\n      s = x + "," + y + " ",\n      max = 0.999999,\n      newPointsPerSegment,\n      i,\n      l,\n      j,\n      factor,\n      nextX,\n      nextY;\n    l = a.length;\n    newPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);\n    for (i = 0; i < l - 2; i += 2) {\n      tally += newPointsPerSegment;\n      nextX = parseFloat(a[i + 2]);\n      nextY = parseFloat(a[i + 3]);\n      if (tally > max) {\n        //compare with 0.99999 instead of 1 in order to prevent rounding errors\n        factor = 1 / (Math.floor(tally) + 1);\n        j = 1;\n        while (tally > max) {\n          s += (x + (nextX - x) * factor * j).toFixed(2) + "," + (y + (nextY - y) * factor * j).toFixed(2) + " ";\n          tally--;\n          j++;\n        }\n      }\n      s += nextX + "," + nextY + " ";\n      x = nextX;\n      y = nextY;\n    }\n    return s;\n  },\n  _pointsFilter = a => {\n    let startNums = a[0].match(_numExp) || [],\n      endNums = a[1].match(_numExp) || [],\n      dif = endNums.length - startNums.length;\n    if (dif > 0) {\n      a[0] = _equalizePointQuantity(startNums, dif);\n    } else {\n      a[1] = _equalizePointQuantity(endNums, -dif);\n    }\n  },\n  _buildPointsFilter = shapeIndex => !isNaN(shapeIndex) ? a => {\n    _pointsFilter(a);\n    a[1] = _offsetPoints(a[1], parseInt(shapeIndex, 10));\n  } : _pointsFilter,\n  _parseShape = (shape, forcePath, target) => {\n    let isString = typeof shape === "string",\n      e,\n      type;\n    if (!isString || _selectorExp.test(shape) || (shape.match(_numExp) || []).length < 3) {\n      e = _toArray(shape)[0];\n      if (e) {\n        type = (e.nodeName + "").toUpperCase();\n        if (forcePath && type !== "PATH") {\n          //if we were passed an element (or selector text for an element) that isn\'t a path, convert it.\n          e = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(e, false);\n          type = "PATH";\n        }\n        shape = e.getAttribute(type === "PATH" ? "d" : "points") || "";\n        if (e === target) {\n          //if the shape matches the target element, the user wants to revert to the original which should have been stored in the data-original attribute\n          shape = e.getAttributeNS(null, "data-original") || shape;\n        }\n      } else {\n        _log("WARNING: invalid morph to: " + shape);\n        shape = false;\n      }\n    }\n    return shape;\n  },\n  //adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it\'s smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\n  _populateSmoothData = (rawPath, tolerance) => {\n    let j = rawPath.length,\n      limit = 0.2 * (tolerance || 1),\n      smooth,\n      segment,\n      x,\n      y,\n      x2,\n      y2,\n      i,\n      l,\n      a,\n      a2,\n      isSmooth,\n      smoothData;\n    while (--j > -1) {\n      segment = rawPath[j];\n      isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n      smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n      isSmooth.length = 4;\n      l = segment.length - 2;\n      for (i = 6; i < l; i += 6) {\n        x = segment[i] - segment[i - 2];\n        y = segment[i + 1] - segment[i - 1];\n        x2 = segment[i + 2] - segment[i];\n        y2 = segment[i + 3] - segment[i + 1];\n        a = _atan2(y, x);\n        a2 = _atan2(y2, x2);\n        smooth = Math.abs(a - a2) < limit;\n        if (smooth) {\n          smoothData[i - 2] = a;\n          smoothData[i + 2] = a2;\n          smoothData[i - 1] = _sqrt(x * x + y * y);\n          smoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n        }\n        isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n      }\n      //if the first and last points are identical, check to see if there\'s a smooth transition. We must handle this a bit differently due to their positions in the array.\n      if (segment[l] === segment[0] && segment[l + 1] === segment[1]) {\n        x = segment[0] - segment[l - 2];\n        y = segment[1] - segment[l - 1];\n        x2 = segment[2] - segment[0];\n        y2 = segment[3] - segment[1];\n        a = _atan2(y, x);\n        a2 = _atan2(y2, x2);\n        if (Math.abs(a - a2) < limit) {\n          smoothData[l - 2] = a;\n          smoothData[2] = a2;\n          smoothData[l - 1] = _sqrt(x * x + y * y);\n          smoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n          isSmooth[l - 2] = isSmooth[l - 1] = true; //don\'t change indexes 2 and 3 because we\'ll trigger everything from the END, and this will optimize file size a bit.\n        }\n      }\n    }\n    return rawPath;\n  },\n  _parseOriginFactors = v => {\n    let a = v.trim().split(" "),\n      x = ~v.indexOf("left") ? 0 : ~v.indexOf("right") ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0]),\n      y = ~v.indexOf("top") ? 0 : ~v.indexOf("bottom") ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1]);\n    return {\n      x: x / 100,\n      y: y / 100\n    };\n  },\n  _shortAngle = dif => dif !== dif % _PI ? dif + (dif < 0 ? _2PI : -_2PI) : dif,\n  _morphMessage = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",\n  _tweenRotation = function (start, end, i, linkedPT) {\n    let so = this._origin,\n      //starting origin\n      eo = this._eOrigin,\n      //ending origin\n      dx = start[i] - so.x,\n      dy = start[i + 1] - so.y,\n      d = _sqrt(dx * dx + dy * dy),\n      //length from starting origin to starting point\n      sa = _atan2(dy, dx),\n      angleDif,\n      short;\n    dx = end[i] - eo.x;\n    dy = end[i + 1] - eo.y;\n    angleDif = _atan2(dy, dx) - sa;\n    short = _shortAngle(angleDif);\n    //in the case of control points, we ALWAYS link them to their anchor so that they don\'t get torn apart and rotate the opposite direction. If it\'s not a control point, we look at the most recently linked point as long as they\'re within a certain rotational range of each other.\n    if (!linkedPT && _lastLinkedAnchor && Math.abs(short + _lastLinkedAnchor.ca) < _angleMin) {\n      linkedPT = _lastLinkedAnchor;\n    }\n    return this._anchorPT = _lastLinkedAnchor = {\n      _next: this._anchorPT,\n      t: start,\n      sa: sa,\n      //starting angle\n      ca: linkedPT && short * linkedPT.ca < 0 && Math.abs(short) > _angleMax ? angleDif : short,\n      //change in angle\n      sl: d,\n      //starting length\n      cl: _sqrt(dx * dx + dy * dy) - d,\n      //change in length\n      i: i\n    };\n  },\n  _initCore = required => {\n    gsap = _getGSAP();\n    PluginClass = PluginClass || gsap && gsap.plugins.morphSVG;\n    if (gsap && PluginClass) {\n      _toArray = gsap.utils.toArray;\n      _doc = document;\n      PluginClass.prototype._tweenRotation = _tweenRotation;\n      _coreInitted = 1;\n    } else if (required) {\n      _log("Please gsap.registerPlugin(MorphSVGPlugin)");\n    }\n  };\nconst MorphSVGPlugin = {\n  version: "3.6.1",\n  name: "morphSVG",\n  rawVars: 1,\n  // otherwise "render" would be interpreted as a function-based value.\n  register(core, Plugin) {\n    gsap = core;\n    PluginClass = Plugin;\n    _initCore();\n  },\n  init(target, value, tween, index, targets) {\n    _coreInitted || _initCore(1);\n    if (!value) {\n      _log("invalid shape");\n      return false;\n    }\n    _isFunction(value) && (value = value.call(tween, index, target, targets));\n    let type, p, pt, shape, isPoly, shapeIndex, map, startSmooth, endSmooth, start, end, i, j, l, startSeg, endSeg, precompiled, sData, eData, originFactors, useRotation, offset;\n    if (typeof value === "string" || value.getBBox || value[0]) {\n      value = {\n        shape: value\n      };\n    } else if (typeof value === "object") {\n      // if there are any function-based values, parse them here (and make a copy of the object so we\'re not modifying the original)\n      type = {};\n      for (p in value) {\n        type[p] = _isFunction(value[p]) && p !== "render" ? value[p].call(tween, index, target, targets) : value[p];\n      }\n      value = type;\n    }\n    let cs = target.nodeType ? window.getComputedStyle(target) : {},\n      fill = cs.fill + "",\n      fillSafe = !(fill === "none" || (fill.match(_numExp) || [])[3] === "0" || cs.fillRule === "evenodd"),\n      origins = (value.origin || "50 50").split(",");\n    type = (target.nodeName + "").toUpperCase();\n    isPoly = type === "POLYLINE" || type === "POLYGON";\n    if (type !== "PATH" && !isPoly && !value.prop) {\n      _log("Cannot morph a <" + type + "> element. " + _morphMessage);\n      return false;\n    }\n    p = type === "PATH" ? "d" : "points";\n    if (!value.prop && !_isFunction(target.setAttribute)) {\n      return false;\n    }\n    shape = _parseShape(value.shape || value.d || value.points || "", p === "d", target);\n    if (isPoly && _commands.test(shape)) {\n      _log("A <" + type + "> cannot accept path data. " + _morphMessage);\n      return false;\n    }\n    shapeIndex = value.shapeIndex || value.shapeIndex === 0 ? value.shapeIndex : "auto";\n    map = value.map || MorphSVGPlugin.defaultMap;\n    this._prop = value.prop;\n    this._render = value.render || MorphSVGPlugin.defaultRender;\n    this._apply = "updateTarget" in value ? value.updateTarget : MorphSVGPlugin.defaultUpdateTarget;\n    this._rnd = Math.pow(10, isNaN(value.precision) ? 2 : +value.precision);\n    this._tween = tween;\n    if (shape) {\n      this._target = target;\n      precompiled = typeof value.precompile === "object";\n      start = this._prop ? target[this._prop] : target.getAttribute(p);\n      if (!this._prop && !target.getAttributeNS(null, "data-original")) {\n        target.setAttributeNS(null, "data-original", start); //record the original state in a data-original attribute so that we can revert to it later.\n      }\n      if (p === "d" || this._prop) {\n        start = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(precompiled ? value.precompile[0] : start);\n        end = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(precompiled ? value.precompile[1] : shape);\n        if (!precompiled && !_equalizeSegmentQuantity(start, end, shapeIndex, map, fillSafe)) {\n          return false; //malformed path data or null target\n        }\n        if (value.precompile === "log" || value.precompile === true) {\n          _log(\'precompile:["\' + (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)(start) + \'","\' + (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)(end) + \'"]\');\n        }\n        useRotation = (value.type || MorphSVGPlugin.defaultType) !== "linear";\n        if (useRotation) {\n          start = _populateSmoothData(start, value.smoothTolerance);\n          end = _populateSmoothData(end, value.smoothTolerance);\n          if (!start.size) {\n            _getTotalSize(start); //adds top/left/width/height values\n          }\n          if (!end.size) {\n            _getTotalSize(end);\n          }\n          originFactors = _parseOriginFactors(origins[0]);\n          this._origin = start.origin = {\n            x: start.left + originFactors.x * start.width,\n            y: start.top + originFactors.y * start.height\n          };\n          if (origins[1]) {\n            originFactors = _parseOriginFactors(origins[1]);\n          }\n          this._eOrigin = {\n            x: end.left + originFactors.x * end.width,\n            y: end.top + originFactors.y * end.height\n          };\n        }\n        this._rawPath = target._gsRawPath = start;\n        j = start.length;\n        while (--j > -1) {\n          startSeg = start[j];\n          endSeg = end[j];\n          startSmooth = startSeg.isSmooth || [];\n          endSmooth = endSeg.isSmooth || [];\n          l = startSeg.length;\n          _lastLinkedAnchor = 0; //reset; we use _lastLinkedAnchor in the _tweenRotation() method to help make sure that close points don\'t get ripped apart and rotate opposite directions. Typically we want to go the shortest direction, but if the previous anchor is going a different direction, we override this logic (within certain thresholds)\n          for (i = 0; i < l; i += 2) {\n            if (endSeg[i] !== startSeg[i] || endSeg[i + 1] !== startSeg[i + 1]) {\n              if (useRotation) {\n                if (startSmooth[i] && endSmooth[i]) {\n                  //if BOTH starting and ending values are smooth (meaning control points have basically the same slope), interpolate the rotation and length instead of the coordinates (this is what makes things smooth).\n                  sData = startSeg.smoothData;\n                  eData = endSeg.smoothData;\n                  offset = i + (i === l - 4 ? 7 - l : 5); //helps us accommodate wrapping (like if the end and start anchors are identical and the control points are smooth).\n                  this._controlPT = {\n                    _next: this._controlPT,\n                    i: i,\n                    j: j,\n                    l1s: sData[i + 1],\n                    l1c: eData[i + 1] - sData[i + 1],\n                    l2s: sData[offset],\n                    l2c: eData[offset] - sData[offset]\n                  };\n                  pt = this._tweenRotation(startSeg, endSeg, i + 2);\n                  this._tweenRotation(startSeg, endSeg, i, pt);\n                  this._tweenRotation(startSeg, endSeg, offset - 1, pt);\n                  i += 4;\n                } else {\n                  this._tweenRotation(startSeg, endSeg, i);\n                }\n              } else {\n                pt = this.add(startSeg, i, startSeg[i], endSeg[i]);\n                pt = this.add(startSeg, i + 1, startSeg[i + 1], endSeg[i + 1]) || pt;\n              }\n            }\n          }\n        }\n      } else {\n        pt = this.add(target, "setAttribute", target.getAttribute(p) + "", shape + "", index, targets, 0, _buildPointsFilter(shapeIndex), p);\n      }\n      if (useRotation) {\n        this.add(this._origin, "x", this._origin.x, this._eOrigin.x);\n        pt = this.add(this._origin, "y", this._origin.y, this._eOrigin.y);\n      }\n      if (pt) {\n        this._props.push("morphSVG");\n        pt.end = shape;\n        pt.endProp = p;\n      }\n    }\n    return _bonusValidated;\n  },\n  render(ratio, data) {\n    let rawPath = data._rawPath,\n      controlPT = data._controlPT,\n      anchorPT = data._anchorPT,\n      rnd = data._rnd,\n      target = data._target,\n      pt = data._pt,\n      s,\n      space,\n      easeInOut,\n      segment,\n      l,\n      angle,\n      i,\n      j,\n      x,\n      y,\n      sin,\n      cos,\n      offset;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n    if (ratio === 1 && data._apply) {\n      pt = data._pt;\n      while (pt) {\n        if (pt.end) {\n          if (data._prop) {\n            target[data._prop] = pt.end;\n          } else {\n            target.setAttribute(pt.endProp, pt.end); //make sure the end value is exactly as specified (in case we had to add fabricated points during the tween)\n          }\n        }\n        pt = pt._next;\n      }\n    } else if (rawPath) {\n      //rotationally position the anchors\n      while (anchorPT) {\n        angle = anchorPT.sa + ratio * anchorPT.ca;\n        l = anchorPT.sl + ratio * anchorPT.cl; //length\n        anchorPT.t[anchorPT.i] = data._origin.x + _cos(angle) * l;\n        anchorPT.t[anchorPT.i + 1] = data._origin.y + _sin(angle) * l;\n        anchorPT = anchorPT._next;\n      }\n\n      //smooth out the control points\n      easeInOut = ratio < 0.5 ? 2 * ratio * ratio : (4 - 2 * ratio) * ratio - 1;\n      while (controlPT) {\n        i = controlPT.i;\n        segment = rawPath[controlPT.j];\n        offset = i + (i === segment.length - 4 ? 7 - segment.length : 5); //accommodates wrapping around of smooth points, like if the start and end anchors are on top of each other and their handles are smooth.\n        angle = _atan2(segment[offset] - segment[i + 1], segment[offset - 1] - segment[i]); //average the angles\n        sin = _sin(angle);\n        cos = _cos(angle);\n        x = segment[i + 2];\n        y = segment[i + 3];\n        l = controlPT.l1s + easeInOut * controlPT.l1c; //length\n        segment[i] = x - cos * l;\n        segment[i + 1] = y - sin * l;\n        l = controlPT.l2s + easeInOut * controlPT.l2c;\n        segment[offset - 1] = x + cos * l;\n        segment[offset] = y + sin * l;\n        controlPT = controlPT._next;\n      }\n      target._gsRawPath = rawPath;\n      if (data._apply) {\n        s = "";\n        space = " ";\n        for (j = 0; j < rawPath.length; j++) {\n          segment = rawPath[j];\n          l = segment.length;\n          s += "M" + (segment[0] * rnd | 0) / rnd + space + (segment[1] * rnd | 0) / rnd + " C";\n          for (i = 2; i < l; i++) {\n            //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places\n            s += (segment[i] * rnd | 0) / rnd + space;\n          }\n        }\n        if (data._prop) {\n          target[data._prop] = s;\n        } else {\n          target.setAttribute("d", s);\n        }\n      }\n    }\n    data._render && rawPath && data._render.call(data._tween, rawPath, target);\n  },\n  kill(property) {\n    this._pt = this._rawPath = 0;\n  },\n  getRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath,\n  stringToRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath,\n  rawPathToString: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString,\n  normalizeStrings(shape1, shape2, _ref) {\n    let {\n      shapeIndex,\n      map\n    } = _ref;\n    let result = [shape1, shape2];\n    _pathFilter(result, shapeIndex, map);\n    return result;\n  },\n  pathFilter: _pathFilter,\n  pointsFilter: _pointsFilter,\n  getTotalSize: _getTotalSize,\n  equalizeSegmentQuantity: _equalizeSegmentQuantity,\n  convertToPath: (targets, swap) => _toArray(targets).map(target => (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(target, swap !== false)),\n  defaultType: "linear",\n  defaultUpdateTarget: true,\n  defaultMap: "size"\n};\n_getGSAP() && gsap.registerPlugin(MorphSVGPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/MorphSVGPlugin.js?')},"./build/scripts/vendor/gsap/src/MotionPathHelper.js":
/*!***********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/MotionPathHelper.js ***!
  \***********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MotionPathHelper: () => (/* binding */ MotionPathHelper),\n/* harmony export */   "default": () => (/* binding */ MotionPathHelper)\n/* harmony export */ });\n/* harmony import */ var _utils_PathEditor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/PathEditor.js */ "./build/scripts/vendor/gsap/src/utils/PathEditor.js");\n/*!\n * MotionPathHelper 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet gsap,\n  _win,\n  _doc,\n  _docEl,\n  _body,\n  MotionPathPlugin,\n  _arrayToRawPath,\n  _rawPathToString,\n  _bonusValidated = 1,\n  //<name>MotionPathHelper</name>\n  _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n  _isString = value => typeof value === "string",\n  _createElement = (type, ns) => {\n    let e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.\n    return e.style ? e : _doc.createElement(type); //some environments won\'t allow access to the element\'s style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won\'t allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n  },\n  _getPositionOnPage = target => {\n    let bounds = target.getBoundingClientRect(),\n      windowOffsetY = _docEl.clientTop - (_win.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n      windowOffsetX = _docEl.clientLeft - (_win.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0);\n    return {\n      left: bounds.left + windowOffsetX,\n      top: bounds.top + windowOffsetY,\n      right: bounds.right + windowOffsetX,\n      bottom: bounds.bottom + windowOffsetY\n    };\n  },\n  _getInitialPath = (x, y) => {\n    let coordinates = [0, 31, 8, 58, 24, 75, 40, 90, 69, 100, 100, 100],\n      i;\n    for (i = 0; i < coordinates.length; i += 2) {\n      coordinates[i] += x;\n      coordinates[i + 1] += y;\n    }\n    return "M" + x + "," + y + "C" + coordinates.join(",");\n  },\n  _getGlobalTime = animation => {\n    let time = animation.totalTime();\n    while (animation) {\n      time = animation.startTime() + time / (animation.timeScale() || 1);\n      animation = animation.parent;\n    }\n    return time;\n  },\n  _copyElement,\n  _initCopyToClipboard = () => {\n    _copyElement = _createElement("textarea");\n    _copyElement.style.display = "none";\n    _body.appendChild(_copyElement);\n  },\n  _parsePath = (path, target, vars) => _isString(path) && _selectorExp.test(path) ? _doc.querySelector(path) : Array.isArray(path) ? _rawPathToString(_arrayToRawPath([{\n    x: gsap.getProperty(target, "x"),\n    y: gsap.getProperty(target, "y")\n  }, ...path], vars)) : _isString(path) || path && (path.tagName + "").toLowerCase() === "path" ? path : 0,\n  _addCopyToClipboard = (target, getter, onComplete) => {\n    target.addEventListener(\'click\', e => {\n      if (e.target._gsHelper) {\n        let c = getter(e.target);\n        _copyElement.value = c;\n        if (c && _copyElement.select) {\n          console.log(c);\n          _copyElement.style.display = "block";\n          _copyElement.select();\n          try {\n            _doc.execCommand(\'copy\');\n            _copyElement.blur();\n            onComplete && onComplete(target);\n          } catch (err) {\n            console.warn("Copy didn\'t work; this browser doesn\'t permit that.");\n          }\n          _copyElement.style.display = "none";\n        }\n      }\n    });\n  },\n  _identityMatrixObject = {\n    matrix: {\n      a: 1,\n      b: 0,\n      c: 0,\n      d: 1,\n      e: 0,\n      f: 0\n    }\n  },\n  _getConsolidatedMatrix = target => (target.transform.baseVal.consolidate() || _identityMatrixObject).matrix,\n  _findMotionPathTween = target => {\n    let tweens = gsap.getTweensOf(target),\n      i = 0;\n    for (; i < tweens.length; i++) {\n      if (tweens[i].vars.motionPath) {\n        return tweens[i];\n      } else if (tweens[i].timeline) {\n        tweens.push(...tweens[i].timeline.getChildren());\n      }\n    }\n  },\n  _initCore = (core, required) => {\n    let message = "Please gsap.registerPlugin(MotionPathPlugin)";\n    _win = window;\n    gsap = gsap || core || _win.gsap || console.warn(message);\n    _doc = document;\n    _body = _doc.body;\n    _docEl = _doc.documentElement;\n    MotionPathPlugin = gsap && gsap.plugins.motionPath;\n    if (!MotionPathPlugin) {\n      required === true && console.warn(message);\n    } else {\n      _initCopyToClipboard();\n      _arrayToRawPath = MotionPathPlugin.arrayToRawPath;\n      _rawPathToString = MotionPathPlugin.rawPathToString;\n    }\n  };\nclass MotionPathHelper {\n  constructor(targetOrTween) {\n    let vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!MotionPathPlugin) {\n      _initCore(vars.gsap, 1);\n    }\n    let copyButton = _createElement("div"),\n      self = this,\n      offset = {\n        x: 0,\n        y: 0\n      },\n      target,\n      path,\n      isSVG,\n      startX,\n      startY,\n      position,\n      svg,\n      animation,\n      svgNamespace,\n      temp,\n      matrix,\n      refreshPath,\n      animationToScrub;\n    if (targetOrTween instanceof gsap.core.Tween) {\n      animation = targetOrTween;\n      target = animation.targets()[0];\n    } else {\n      target = gsap.utils.toArray(targetOrTween)[0];\n      animation = _findMotionPathTween(target);\n    }\n    path = _parsePath(vars.path, target, vars);\n    this.offset = offset;\n    position = _getPositionOnPage(target);\n    startX = parseFloat(gsap.getProperty(target, "x", "px"));\n    startY = parseFloat(gsap.getProperty(target, "y", "px"));\n    isSVG = target.getCTM && target.tagName.toLowerCase() !== "svg";\n    if (animation && !path) {\n      path = _parsePath(animation.vars.motionPath.path || animation.vars.motionPath, target, animation.vars.motionPath);\n    }\n    copyButton.setAttribute("class", "copy-motion-path");\n    copyButton.style.cssText = "border-radius:8px; background-color:rgba(85, 85, 85, 0.7); color:#fff; cursor:pointer; padding:6px 12px; font-family:Signika Negative, Arial, sans-serif; position:fixed; left:50%; transform:translate(-50%, 0); font-size:19px; bottom:10px";\n    copyButton.innerText = "COPY MOTION PATH";\n    copyButton._gsHelper = self;\n    (gsap.utils.toArray(vars.container)[0] || _body).appendChild(copyButton);\n    _addCopyToClipboard(copyButton, () => self.getString(), () => gsap.fromTo(copyButton, {\n      backgroundColor: "white"\n    }, {\n      duration: 0.5,\n      backgroundColor: "rgba(85, 85, 85, 0.6)"\n    }));\n    svg = path && path.ownerSVGElement;\n    if (!svg) {\n      svgNamespace = isSVG && target.ownerSVGElement && target.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg";\n      if (isSVG) {\n        svg = target.ownerSVGElement;\n        temp = target.getBBox();\n        matrix = _getConsolidatedMatrix(target);\n        startX = matrix.e;\n        startY = matrix.f;\n        offset.x = temp.x;\n        offset.y = temp.y;\n      } else {\n        svg = _createElement("svg", svgNamespace);\n        _body.appendChild(svg);\n        svg.setAttribute("viewBox", "0 0 100 100");\n        svg.style.cssText = "overflow:visible; background-color: transparent; position:absolute; width:100px; height:100px; top:" + position.top + "px; left:" + position.left + "px;";\n      }\n      temp = _isString(path) && !_selectorExp.test(path) ? path : _getInitialPath(startX, startY);\n      path = _createElement("path", svgNamespace);\n      path.setAttribute("d", temp);\n      path.setAttribute("vector-effect", "non-scaling-stroke");\n      path.style.cssText = "fill:transparent; stroke-width:" + (vars.pathWidth || 3) + "; stroke:" + (vars.pathColor || "#555") + "; opacity:" + (vars.pathOpacity || 0.6);\n      svg.appendChild(path);\n      if (offset.x || offset.y) {\n        gsap.set(path, {\n          x: offset.x,\n          y: offset.y\n        });\n      }\n    }\n    if (!("selected" in vars)) {\n      vars.selected = true;\n    }\n    if (!("anchorSnap" in vars)) {\n      vars.anchorSnap = p => {\n        if (p.x * p.x + p.y * p.y < 16) {\n          p.x = p.y = 0;\n        }\n      };\n    }\n    animationToScrub = animation && animation.parent.data === "nested" ? animation.parent.parent : animation;\n    vars.onPress = () => {\n      animationToScrub.pause(0);\n    };\n    refreshPath = () => {\n      //let m = _getConsolidatedMatrix(path);\n      //animation.vars.motionPath.offsetX = m.e - offset.x;\n      //animation.vars.motionPath.offsetY = m.f - offset.y;\n      animation.invalidate();\n      animationToScrub.restart();\n    };\n    vars.onRelease = vars.onDeleteAnchor = refreshPath;\n    this.editor = _utils_PathEditor_js__WEBPACK_IMPORTED_MODULE_0__["default"].create(path, vars);\n    if (vars.center) {\n      gsap.set(target, {\n        transformOrigin: "50% 50%",\n        xPercent: -50,\n        yPercent: -50\n      });\n    }\n    if (animation) {\n      if (animation.vars.motionPath.path) {\n        animation.vars.motionPath.path = path;\n      } else {\n        animation.vars.motionPath = {\n          path: path\n        };\n      }\n      if (animationToScrub.parent !== gsap.globalTimeline) {\n        gsap.globalTimeline.add(animationToScrub, _getGlobalTime(animationToScrub) - animationToScrub.delay());\n      }\n      animationToScrub.repeat(-1).repeatDelay(1);\n    } else {\n      animation = animationToScrub = gsap.to(target, {\n        motionPath: {\n          path: path,\n          start: vars.start || 0,\n          end: "end" in vars ? vars.end : 1,\n          autoRotate: "autoRotate" in vars ? vars.autoRotate : false,\n          align: path,\n          alignOrigin: vars.alignOrigin\n        },\n        duration: vars.duration || 5,\n        ease: vars.ease || "power1.inOut",\n        repeat: -1,\n        repeatDelay: 1,\n        paused: !vars.path\n      });\n    }\n    this.animation = animation;\n  }\n  getString() {\n    return this.editor.getString(true, -this.offset.x, -this.offset.y);\n  }\n}\nMotionPathHelper.register = _initCore;\nMotionPathHelper.create = (target, vars) => new MotionPathHelper(target, vars);\nMotionPathHelper.editPath = (path, vars) => _utils_PathEditor_js__WEBPACK_IMPORTED_MODULE_0__["default"].create(path, vars);\nMotionPathHelper.version = "3.6.1";\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/MotionPathHelper.js?')},"./build/scripts/vendor/gsap/src/MotionPathPlugin.js":
/*!***********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/MotionPathPlugin.js ***!
  \***********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MotionPathPlugin: () => (/* binding */ MotionPathPlugin),\n/* harmony export */   "default": () => (/* binding */ MotionPathPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ "./build/scripts/vendor/gsap/src/utils/paths.js");\n/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/matrix.js */ "./build/scripts/vendor/gsap/src/utils/matrix.js");\n/*!\n * MotionPathPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\n\nlet _xProps = "x,translateX,left,marginLeft,xPercent".split(","),\n  _yProps = "y,translateY,top,marginTop,yPercent".split(","),\n  _DEG2RAD = Math.PI / 180,\n  gsap,\n  PropTween,\n  _getUnit,\n  _toArray,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _populateSegmentFromArray = (segment, values, property, mode) => {\n    //mode: 0 = x but don\'t fill y yet, 1 = y, 2 = x and fill y with 0.\n    let l = values.length,\n      si = mode === 2 ? 0 : mode,\n      i = 0,\n      v;\n    for (; i < l; i++) {\n      segment[si] = v = parseFloat(values[i][property]);\n      mode === 2 && (segment[si + 1] = 0);\n      si += 2;\n    }\n    return segment;\n  },\n  _getPropNum = (target, prop, unit) => parseFloat(target._gsap.get(target, prop, unit || "px")) || 0,\n  _relativize = segment => {\n    let x = segment[0],\n      y = segment[1],\n      i;\n    for (i = 2; i < segment.length; i += 2) {\n      x = segment[i] += x;\n      y = segment[i + 1] += y;\n    }\n  },\n  _segmentToRawPath = (plugin, segment, target, x, y, slicer, vars, unitX, unitY) => {\n    if (vars.type === "cubic") {\n      segment = [segment];\n    } else {\n      segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n      vars.relative && _relativize(segment);\n      let pointFunc = y ? _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment : _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.flatPointsToSegment;\n      segment = [pointFunc(segment, vars.curviness)];\n    }\n    segment = slicer(_align(segment, target, vars));\n    _addDimensionalPropTween(plugin, target, x, segment, "x", unitX);\n    y && _addDimensionalPropTween(plugin, target, y, segment, "y", unitY);\n    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n  },\n  _emptyFunc = v => v,\n  _numExp = /[-+\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/g,\n  _originToPoint = (element, origin, parentMatrix) => {\n    // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be "auto" in which case it will be the top left unless it\'s a <path>, when it will start at the beginning of the path itself.\n    let m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(element),\n      svg,\n      x,\n      y;\n    if ((element.tagName + "").toLowerCase() === "svg") {\n      svg = element.viewBox.baseVal;\n      x = svg.x;\n      y = svg.y;\n      svg.width || (svg = {\n        width: +element.getAttribute("width"),\n        height: +element.getAttribute("height")\n      });\n    } else {\n      svg = origin && element.getBBox && element.getBBox();\n      x = y = 0;\n    }\n    if (origin && origin !== "auto") {\n      x += origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n      y += origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n    }\n    return parentMatrix.apply(x || y ? m.apply({\n      x: x,\n      y: y\n    }) : {\n      x: m.e,\n      y: m.f\n    });\n  },\n  _getAlignMatrix = (fromElement, toElement, fromOrigin, toOrigin) => {\n    let parentMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement.parentNode, true, true),\n      m = parentMatrix.clone().multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement)),\n      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n      {\n        x,\n        y\n      } = _originToPoint(toElement, toOrigin, parentMatrix),\n      p;\n    m.e = m.f = 0;\n    if (toOrigin === "auto" && toElement.getTotalLength && toElement.tagName.toLowerCase() === "path") {\n      p = toElement.getAttribute("d").match(_numExp) || [];\n      p = m.apply({\n        x: +p[0],\n        y: +p[1]\n      });\n      x += p.x;\n      y += p.y;\n    }\n    if (p || toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement) {\n      p = m.apply(toElement.getBBox());\n      x -= p.x;\n      y -= p.y;\n    }\n    m.e = x - fromPoint.x;\n    m.f = y - fromPoint.y;\n    return m;\n  },\n  _align = (rawPath, target, _ref) => {\n    let {\n      align,\n      matrix,\n      offsetX,\n      offsetY,\n      alignOrigin\n    } = _ref;\n    let x = rawPath[0][0],\n      y = rawPath[0][1],\n      curX = _getPropNum(target, "x"),\n      curY = _getPropNum(target, "y"),\n      alignTarget,\n      m,\n      p;\n    if (!rawPath || !rawPath.length) {\n      return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)("M0,0L0,0");\n    }\n    if (align) {\n      if (align === "self" || (alignTarget = _toArray(align)[0] || target) === target) {\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n      } else {\n        if (alignOrigin && alignOrigin[2] !== false) {\n          gsap.set(target, {\n            transformOrigin: alignOrigin[0] * 100 + "% " + alignOrigin[1] * 100 + "%"\n          });\n        } else {\n          alignOrigin = [_getPropNum(target, "xPercent") / -100, _getPropNum(target, "yPercent") / -100];\n        }\n        m = _getAlignMatrix(target, alignTarget, alignOrigin, "auto");\n        p = m.apply({\n          x: x,\n          y: y\n        });\n        (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n      }\n    }\n    if (matrix) {\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n    } else if (offsetX || offsetY) {\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n    }\n    return rawPath;\n  },\n  _addDimensionalPropTween = (plugin, target, property, rawPath, pathProperty, forceUnit) => {\n    let cache = target._gsap,\n      harness = cache.harness,\n      alias = harness && harness.aliases && harness.aliases[property],\n      prop = alias && alias.indexOf(",") < 0 ? alias : property,\n      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n    pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n    pt.path = rawPath;\n    pt.pp = pathProperty;\n    plugin._props.push(prop);\n  },\n  _sliceModifier = (start, end) => rawPath => start || end !== 1 ? (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath)(rawPath, start, end) : rawPath;\nconst MotionPathPlugin = {\n  version: "3.6.1",\n  name: "motionPath",\n  register(core, Plugin, propTween) {\n    gsap = core;\n    _getUnit = gsap.utils.getUnit;\n    _toArray = gsap.utils.toArray;\n    PropTween = propTween;\n  },\n  init(target, vars) {\n    if (!gsap) {\n      console.warn("Please gsap.registerPlugin(MotionPathPlugin)");\n      return false;\n    }\n    if (!(typeof vars === "object" && !vars.style) || !vars.path) {\n      vars = {\n        path: vars\n      };\n    }\n    let rawPaths = [],\n      {\n        path,\n        autoRotate,\n        unitX,\n        unitY,\n        x,\n        y\n      } = vars,\n      firstObj = path[0],\n      slicer = _sliceModifier(vars.start, "end" in vars ? vars.end : 1),\n      rawPath,\n      p;\n    this.rawPaths = rawPaths;\n    this.target = target;\n    if (this.rotate = autoRotate || autoRotate === 0) {\n      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n      this.rOffset = parseFloat(autoRotate) || 0;\n      this.radians = !!vars.useRadians;\n      this.rProp = vars.rotation || "rotation"; // rotation property\n      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n    }\n    if (Array.isArray(path) && !("closed" in path) && typeof firstObj !== "number") {\n      for (p in firstObj) {\n        if (!x && ~_xProps.indexOf(p)) {\n          x = p;\n        } else if (!y && ~_yProps.indexOf(p)) {\n          y = p;\n        }\n      }\n      if (x && y) {\n        //correlated values\n        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n      } else {\n        x = y = 0;\n      }\n      for (p in firstObj) {\n        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n      }\n    } else {\n      rawPath = slicer(_align((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(vars.path), target, vars));\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(rawPath, vars.resolution);\n      rawPaths.push(rawPath);\n      _addDimensionalPropTween(this, target, vars.x || "x", rawPath, "x", vars.unitX || "px");\n      _addDimensionalPropTween(this, target, vars.y || "y", rawPath, "y", vars.unitY || "px");\n    }\n  },\n  render(ratio, data) {\n    let rawPaths = data.rawPaths,\n      i = rawPaths.length,\n      pt = data._pt;\n    if (ratio > 1) {\n      ratio = 1;\n    } else if (ratio < 0) {\n      ratio = 0;\n    }\n    while (i--) {\n      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath)(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n    }\n    while (pt) {\n      pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n      pt = pt._next;\n    }\n    data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n  },\n  getLength(path) {\n    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(path)).totalLength;\n  },\n  sliceRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath,\n  getRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath,\n  pointsToSegment: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment,\n  stringToRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath,\n  rawPathToString: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString,\n  transformRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath,\n  getGlobalMatrix: _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix,\n  getPositionOnPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath,\n  cacheRawPathMeasurements: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements,\n  convertToPath: (targets, swap) => _toArray(targets).map(target => (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(target, swap !== false)),\n  convertCoordinates(fromElement, toElement, point) {\n    let m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement));\n    return point ? m.apply(point) : m;\n  },\n  getAlignMatrix: _getAlignMatrix,\n  getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n    let m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n    return {\n      x: m.e,\n      y: m.f\n    };\n  },\n  arrayToRawPath(value, vars) {\n    vars = vars || {};\n    let segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || "x", 0), value, vars.y || "y", 1);\n    vars.relative && _relativize(segment);\n    return [vars.type === "cubic" ? segment : (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment)(segment, vars.curviness)];\n  }\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/MotionPathPlugin.js?')},"./build/scripts/vendor/gsap/src/Physics2DPlugin.js":
/*!**********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/Physics2DPlugin.js ***!
  \**********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Physics2DPlugin: () => (/* binding */ Physics2DPlugin),\n/* harmony export */   "default": () => (/* binding */ Physics2DPlugin)\n/* harmony export */ });\n/*!\n * Physics2DPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _getUnit,\n  _DEG2RAD = Math.PI / 180,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _round = value => Math.round(value * 10000) / 10000,\n  _bonusValidated = 1,\n  //<name>Physics2DPlugin</name>\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (!_coreInitted) {\n      _getUnit = gsap.utils.getUnit;\n      _coreInitted = 1;\n    }\n  };\nclass PhysicsProp {\n  constructor(target, p, velocity, acceleration, stepsPerTimeUnit) {\n    let cache = target._gsap,\n      curVal = cache.get(target, p);\n    this.p = p;\n    this.set = cache.set(target, p); //setter\n    this.s = this.val = parseFloat(curVal);\n    this.u = _getUnit(curVal) || 0;\n    this.vel = velocity || 0;\n    this.v = this.vel / stepsPerTimeUnit;\n    if (acceleration || acceleration === 0) {\n      this.acc = acceleration;\n      this.a = this.acc / (stepsPerTimeUnit * stepsPerTimeUnit);\n    } else {\n      this.acc = this.a = 0;\n    }\n  }\n}\nconst Physics2DPlugin = {\n  version: "3.6.1",\n  name: "physics2D",\n  register: _initCore,\n  init(target, value, tween) {\n    _coreInitted || _initCore();\n    let data = this,\n      angle = +value.angle || 0,\n      velocity = +value.velocity || 0,\n      acceleration = +value.acceleration || 0,\n      xProp = value.xProp || "x",\n      yProp = value.yProp || "y",\n      aAngle = value.accelerationAngle || value.accelerationAngle === 0 ? +value.accelerationAngle : angle;\n    data.target = target;\n    data.tween = tween;\n    data.step = 0;\n    data.sps = 30; //steps per second\n    if (value.gravity) {\n      acceleration = +value.gravity;\n      aAngle = 90;\n    }\n    angle *= _DEG2RAD;\n    aAngle *= _DEG2RAD;\n    data.fr = 1 - (+value.friction || 0);\n    data._props.push(xProp, yProp);\n    data.xp = new PhysicsProp(target, xProp, Math.cos(angle) * velocity, Math.cos(aAngle) * acceleration, data.sps);\n    data.yp = new PhysicsProp(target, yProp, Math.sin(angle) * velocity, Math.sin(aAngle) * acceleration, data.sps);\n    data.skipX = data.skipY = 0;\n  },\n  render(ratio, data) {\n    let {\n        xp,\n        yp,\n        tween,\n        target,\n        step,\n        sps,\n        fr,\n        skipX,\n        skipY\n      } = data,\n      time = tween._from ? tween._dur - tween._time : tween._time,\n      x,\n      y,\n      tt,\n      steps,\n      remainder,\n      i;\n    if (fr === 1) {\n      tt = time * time * 0.5;\n      x = xp.s + xp.vel * time + xp.acc * tt;\n      y = yp.s + yp.vel * time + yp.acc * tt;\n    } else {\n      time *= sps;\n      steps = i = (time | 0) - step;\n      /*\n      Note: rounding errors build up if we walk the calculations backward which we used to do like this to maximize performance:\n      \ti = -i;\n      \twhile (i--) {\n      \t\txp.val -= xp.v;\n      \t\typ.val -= yp.v;\n      \t\txp.v /= fr;\n      \t\typ.v /= fr;\n      \t\txp.v -= xp.a;\n      \t\typ.v -= yp.a;\n      \t}\n      but now for the sake of accuracy (to ensure rewinding always goes back to EXACTLY the same spot), we force the calculations to go forward every time. So if the tween is going backward, we just start from the beginning and iterate. This is only necessary with friction.\n       */\n      if (i < 0) {\n        xp.v = xp.vel / sps;\n        yp.v = yp.vel / sps;\n        xp.val = xp.s;\n        yp.val = yp.s;\n        data.step = 0;\n        steps = i = time | 0;\n      }\n      remainder = time % 1 * fr;\n      while (i--) {\n        xp.v += xp.a;\n        yp.v += yp.a;\n        xp.v *= fr;\n        yp.v *= fr;\n        xp.val += xp.v;\n        yp.val += yp.v;\n      }\n      x = xp.val + xp.v * remainder;\n      y = yp.val + yp.v * remainder;\n      data.step += steps;\n    }\n    skipX || xp.set(target, xp.p, _round(x) + xp.u);\n    skipY || yp.set(target, yp.p, _round(y) + yp.u);\n  },\n  kill(property) {\n    if (this.xp.p === property) {\n      this.skipX = 1;\n    }\n    if (this.yp.p === property) {\n      this.skipY = 1;\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(Physics2DPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/Physics2DPlugin.js?')},"./build/scripts/vendor/gsap/src/PhysicsPropsPlugin.js":
/*!*************************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/PhysicsPropsPlugin.js ***!
  \*************************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsPropsPlugin: () => (/* binding */ PhysicsPropsPlugin),\n/* harmony export */   "default": () => (/* binding */ PhysicsPropsPlugin)\n/* harmony export */ });\n/*!\n * PhysicsPropsPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _getUnit,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _round = value => Math.round(value * 10000) / 10000,\n  _bonusValidated = 1,\n  //<name>PhysicsPropsPlugin</name>\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (!_coreInitted) {\n      _getUnit = gsap.utils.getUnit;\n      _coreInitted = 1;\n    }\n  };\nclass PhysicsProp {\n  constructor(target, p, velocity, acceleration, friction, stepsPerTimeUnit) {\n    let cache = target._gsap,\n      curVal = cache.get(target, p);\n    this.p = p;\n    this.set = cache.set(target, p); //setter\n    this.s = this.val = parseFloat(curVal);\n    this.u = _getUnit(curVal) || 0;\n    this.vel = velocity || 0;\n    this.v = this.vel / stepsPerTimeUnit;\n    if (acceleration || acceleration === 0) {\n      this.acc = acceleration;\n      this.a = this.acc / (stepsPerTimeUnit * stepsPerTimeUnit);\n    } else {\n      this.acc = this.a = 0;\n    }\n    this.fr = 1 - (friction || 0);\n  }\n}\nconst PhysicsPropsPlugin = {\n  version: "3.6.1",\n  name: "physicsProps",\n  register: _initCore,\n  init(target, value, tween) {\n    _coreInitted || _initCore();\n    let data = this,\n      p;\n    data.target = target;\n    data.tween = tween;\n    data.step = 0;\n    data.sps = 30; //steps per second\n    data.vProps = [];\n    for (p in value) {\n      let {\n        velocity,\n        acceleration,\n        friction\n      } = value[p];\n      if (velocity || acceleration) {\n        data.vProps.push(new PhysicsProp(target, p, velocity, acceleration, friction, data.sps));\n        data._props.push(p);\n        friction && (data.hasFr = 1);\n      }\n    }\n  },\n  render(ratio, data) {\n    let {\n        vProps,\n        tween,\n        target,\n        step,\n        hasFr,\n        sps\n      } = data,\n      i = vProps.length,\n      time = tween._from ? tween._dur - tween._time : tween._time,\n      curProp,\n      steps,\n      remainder,\n      j,\n      tt;\n    if (hasFr) {\n      time *= sps;\n      steps = (time | 0) - step;\n      /*\n      Note: rounding errors build up if we walk the calculations backward which we used to do like this to maximize performance:\n      while (i--) {\n      \tcurProp = vProps[i];\n      \tj = -steps;\n      \twhile (j--) {\n      \t\tcurProp.val -= curProp.v;\n      \t\tcurProp.v /= curProp.fr;\n      \t\tcurProp.v -= curProp.a;\n      \t}\n      \tcurProp.set(target, curProp.p, _round(curProp.val + (curProp.v * remainder * curProp.fr)) + curProp.u);\n      }\n      but now for the sake of accuracy (to ensure rewinding always goes back to EXACTLY the same spot), we force the calculations to go forward every time. So if the tween is going backward, we just start from the beginning and iterate. This is only necessary with friction.\n       */\n      if (steps < 0) {\n        while (i--) {\n          curProp = vProps[i];\n          curProp.v = curProp.vel / sps;\n          curProp.val = curProp.s;\n        }\n        i = vProps.length;\n        data.step = step = 0;\n        steps = time | 0;\n      }\n      remainder = time % 1;\n      while (i--) {\n        curProp = vProps[i];\n        j = steps;\n        while (j--) {\n          curProp.v += curProp.a;\n          curProp.v *= curProp.fr;\n          curProp.val += curProp.v;\n        }\n        curProp.set(target, curProp.p, _round(curProp.val + curProp.v * remainder * curProp.fr) + curProp.u);\n      }\n      data.step += steps;\n    } else {\n      tt = time * time * 0.5;\n      while (i--) {\n        curProp = vProps[i];\n        curProp.set(target, curProp.p, _round(curProp.s + curProp.vel * time + curProp.acc * tt) + curProp.u);\n      }\n    }\n  },\n  kill(property) {\n    let vProps = this.vProps,\n      i = vProps.length;\n    while (i--) {\n      vProps[i].p === property && vProps.splice(i, 1);\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(PhysicsPropsPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/PhysicsPropsPlugin.js?')},"./build/scripts/vendor/gsap/src/PixiPlugin.js":
/*!*****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/PixiPlugin.js ***!
  \*****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PixiPlugin: () => (/* binding */ PixiPlugin),\n/* harmony export */   "default": () => (/* binding */ PixiPlugin)\n/* harmony export */ });\n/*!\n * PixiPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _win,\n  _splitColor,\n  _coreInitted,\n  _PIXI,\n  PropTween,\n  _getSetter,\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isFunction = value => typeof value === "function",\n  _warn = message => console.warn(message),\n  _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\n  _lumR = 0.212671,\n  _lumG = 0.715160,\n  _lumB = 0.072169,\n  _applyMatrix = (m, m2) => {\n    let temp = [],\n      i = 0,\n      z = 0,\n      y,\n      x;\n    for (y = 0; y < 4; y++) {\n      for (x = 0; x < 5; x++) {\n        z = x === 4 ? m[i + 4] : 0;\n        temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;\n      }\n      i += 5;\n    }\n    return temp;\n  },\n  _setSaturation = (m, n) => {\n    let inv = 1 - n,\n      r = inv * _lumR,\n      g = inv * _lumG,\n      b = inv * _lumB;\n    return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);\n  },\n  _colorize = (m, color, amount) => {\n    let c = _splitColor(color),\n      r = c[0] / 255,\n      g = c[1] / 255,\n      b = c[2] / 255,\n      inv = 1 - amount;\n    return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);\n  },\n  _setHue = (m, n) => {\n    n *= Math.PI / 180;\n    let c = Math.cos(n),\n      s = Math.sin(n);\n    return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);\n  },\n  _setContrast = (m, n) => _applyMatrix([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m),\n  _getFilter = (target, type) => {\n    let filterClass = _PIXI.filters[type],\n      filters = target.filters || [],\n      i = filters.length,\n      filter;\n    if (!filterClass) {\n      _warn(type + " not found. PixiPlugin.registerPIXI(PIXI)");\n    }\n    while (--i > -1) {\n      if (filters[i] instanceof filterClass) {\n        return filters[i];\n      }\n    }\n    filter = new filterClass();\n    if (type === "BlurFilter") {\n      filter.blur = 0;\n    }\n    filters.push(filter);\n    target.filters = filters;\n    return filter;\n  },\n  _addColorMatrixFilterCacheTween = (p, plugin, cache, vars) => {\n    //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it\'s easy to grab the current value at any time.\n    plugin.add(cache, p, cache[p], vars[p]);\n    plugin._props.push(p);\n  },\n  _applyBrightnessToMatrix = (brightness, matrix) => {\n    let temp = new _PIXI.filters.ColorMatrixFilter();\n    temp.matrix = matrix;\n    temp.brightness(brightness, true);\n    return temp.matrix;\n  },\n  _copy = obj => {\n    let copy = {},\n      p;\n    for (p in obj) {\n      copy[p] = obj[p];\n    }\n    return copy;\n  },\n  _CMFdefaults = {\n    contrast: 1,\n    saturation: 1,\n    colorizeAmount: 0,\n    colorize: "rgb(255,255,255)",\n    hue: 0,\n    brightness: 1\n  },\n  _parseColorMatrixFilter = (target, v, pg) => {\n    let filter = _getFilter(target, "ColorMatrixFilter"),\n      cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults),\n      combine = v.combineCMF && !("colorMatrixFilter" in v && !v.colorMatrixFilter),\n      i,\n      matrix,\n      startMatrix;\n    startMatrix = filter.matrix;\n    if (v.resolution) {\n      filter.resolution = v.resolution;\n    }\n    if (v.matrix && v.matrix.length === startMatrix.length) {\n      matrix = v.matrix;\n      if (cache.contrast !== 1) {\n        _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);\n      }\n      if (cache.hue) {\n        _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);\n      }\n      if (cache.brightness !== 1) {\n        _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);\n      }\n      if (cache.colorizeAmount) {\n        _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);\n        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);\n      }\n      if (cache.saturation !== 1) {\n        _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);\n      }\n    } else {\n      matrix = _idMatrix.slice();\n      if (v.contrast != null) {\n        matrix = _setContrast(matrix, +v.contrast);\n        _addColorMatrixFilterCacheTween("contrast", pg, cache, v);\n      } else if (cache.contrast !== 1) {\n        if (combine) {\n          matrix = _setContrast(matrix, cache.contrast);\n        } else {\n          _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);\n        }\n      }\n      if (v.hue != null) {\n        matrix = _setHue(matrix, +v.hue);\n        _addColorMatrixFilterCacheTween("hue", pg, cache, v);\n      } else if (cache.hue) {\n        if (combine) {\n          matrix = _setHue(matrix, cache.hue);\n        } else {\n          _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);\n        }\n      }\n      if (v.brightness != null) {\n        matrix = _applyBrightnessToMatrix(+v.brightness, matrix);\n        _addColorMatrixFilterCacheTween("brightness", pg, cache, v);\n      } else if (cache.brightness !== 1) {\n        if (combine) {\n          matrix = _applyBrightnessToMatrix(cache.brightness, matrix);\n        } else {\n          _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);\n        }\n      }\n      if (v.colorize != null) {\n        v.colorizeAmount = "colorizeAmount" in v ? +v.colorizeAmount : 1;\n        matrix = _colorize(matrix, v.colorize, v.colorizeAmount);\n        _addColorMatrixFilterCacheTween("colorize", pg, cache, v);\n        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v);\n      } else if (cache.colorizeAmount) {\n        if (combine) {\n          matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);\n        } else {\n          _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);\n          _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);\n        }\n      }\n      if (v.saturation != null) {\n        matrix = _setSaturation(matrix, +v.saturation);\n        _addColorMatrixFilterCacheTween("saturation", pg, cache, v);\n      } else if (cache.saturation !== 1) {\n        if (combine) {\n          matrix = _setSaturation(matrix, cache.saturation);\n        } else {\n          _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);\n        }\n      }\n    }\n    i = matrix.length;\n    while (--i > -1) {\n      if (matrix[i] !== startMatrix[i]) {\n        pg.add(startMatrix, i, startMatrix[i], matrix[i], "colorMatrixFilter");\n      }\n    }\n    pg._props.push("colorMatrixFilter");\n  },\n  _renderColor = (ratio, _ref) => {\n    let {\n      t,\n      p,\n      color,\n      set\n    } = _ref;\n    set(t, p, color[0] << 16 | color[1] << 8 | color[2]);\n  },\n  _renderDirtyCache = (ratio, _ref2) => {\n    let {\n      g\n    } = _ref2;\n    if (g) {\n      //in order for PixiJS to actually redraw GraphicsData, we\'ve gotta increment the "dirty" and "clearDirty" values. If we don\'t do this, the values will be tween properly, but not rendered.\n      g.dirty++;\n      g.clearDirty++;\n    }\n  },\n  _renderAutoAlpha = (ratio, data) => {\n    data.t.visible = !!data.t.alpha;\n  },\n  _addColorTween = (target, p, value, plugin) => {\n    let currentValue = target[p],\n      startColor = _splitColor(_isFunction(currentValue) ? target[p.indexOf("set") || !_isFunction(target["get" + p.substr(3)]) ? p : "get" + p.substr(3)]() : currentValue),\n      endColor = _splitColor(value);\n    plugin._pt = new PropTween(plugin._pt, target, p, 0, 0, _renderColor, {\n      t: target,\n      p: p,\n      color: startColor,\n      set: _getSetter(target, p)\n    });\n    plugin.add(startColor, 0, startColor[0], endColor[0]);\n    plugin.add(startColor, 1, startColor[1], endColor[1]);\n    plugin.add(startColor, 2, startColor[2], endColor[2]);\n  },\n  _colorProps = {\n    tint: 1,\n    lineColor: 1,\n    fillColor: 1\n  },\n  _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),\n  _contexts = {\n    x: "position",\n    y: "position",\n    tileX: "tilePosition",\n    tileY: "tilePosition"\n  },\n  _colorMatrixFilterProps = {\n    colorMatrixFilter: 1,\n    saturation: 1,\n    contrast: 1,\n    hue: 1,\n    colorize: 1,\n    colorizeAmount: 1,\n    brightness: 1,\n    combineCMF: 1\n  },\n  _DEG2RAD = Math.PI / 180,\n  _isString = value => typeof value === "string",\n  _degreesToRadians = value => _isString(value) && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD,\n  _renderPropWithEnd = (ratio, data) => data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 100000) / 100000, data),\n  _addRotationalPropTween = (plugin, target, property, startNum, endValue, radians) => {\n    let cap = 360 * (radians ? _DEG2RAD : 1),\n      isString = _isString(endValue),\n      relative = isString && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0,\n      endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD : 1),\n      change = relative ? endNum * relative : endNum - startNum,\n      finalValue = startNum + change,\n      direction,\n      pt;\n    if (isString) {\n      direction = endValue.split("_")[1];\n      if (direction === "short") {\n        change %= cap;\n        if (change !== change % (cap / 2)) {\n          change += change < 0 ? cap : -cap;\n        }\n      }\n      if (direction === "cw" && change < 0) {\n        change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;\n      } else if (direction === "ccw" && change > 0) {\n        change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;\n      }\n    }\n    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n    pt.e = finalValue;\n    return pt;\n  },\n  _initCore = () => {\n    if (_windowExists()) {\n      _win = window;\n      gsap = _coreInitted = _getGSAP();\n      _PIXI = _PIXI || _win.PIXI;\n      _splitColor = color => gsap.utils.splitColor((color + "").substr(0, 2) === "0x" ? "#" + color.substr(2) : color); // some colors in PIXI are reported as "0xFF4421" instead of "#FF4421".\n    }\n  },\n  i,\n  p;\n\n//context setup...\nfor (i = 0; i < _xyContexts.length; i++) {\n  p = _xyContexts[i];\n  _contexts[p + "X"] = p;\n  _contexts[p + "Y"] = p;\n}\nconst PixiPlugin = {\n  version: "3.6.1",\n  name: "pixi",\n  register(core, Plugin, propTween) {\n    gsap = core;\n    PropTween = propTween;\n    _getSetter = Plugin.getSetter;\n    _initCore();\n  },\n  registerPIXI(pixi) {\n    _PIXI = pixi;\n  },\n  init(target, values, tween, index, targets) {\n    if (!_PIXI) {\n      _initCore();\n    }\n    if (!target instanceof _PIXI.DisplayObject) {\n      return false;\n    }\n    let isV4 = _PIXI.VERSION.charAt(0) === "4",\n      context,\n      axis,\n      value,\n      colorMatrix,\n      filter,\n      p,\n      padding,\n      i,\n      data;\n    for (p in values) {\n      context = _contexts[p];\n      value = values[p];\n      if (context) {\n        axis = ~p.charAt(p.length - 1).toLowerCase().indexOf("x") ? "x" : "y";\n        this.add(target[context], axis, target[context][axis], context === "skew" ? _degreesToRadians(value) : value);\n      } else if (p === "scale" || p === "anchor" || p === "pivot" || p === "tileScale") {\n        this.add(target[p], "x", target[p].x, value);\n        this.add(target[p], "y", target[p].y, value);\n      } else if (p === "rotation" || p === "angle") {\n        //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.\n        _addRotationalPropTween(this, target, p, target[p], value, p === "rotation");\n      } else if (_colorMatrixFilterProps[p]) {\n        if (!colorMatrix) {\n          _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);\n          colorMatrix = true;\n        }\n      } else if (p === "blur" || p === "blurX" || p === "blurY" || p === "blurPadding") {\n        filter = _getFilter(target, "BlurFilter");\n        this.add(filter, p, filter[p], value);\n        if (values.blurPadding !== 0) {\n          padding = values.blurPadding || Math.max(filter[p], value) * 2;\n          i = target.filters.length;\n          while (--i > -1) {\n            target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don\'t expand the padding on all the filters, it can look clipped.\n          }\n        }\n      } else if (_colorProps[p]) {\n        if ((p === "lineColor" || p === "fillColor") && target instanceof _PIXI.Graphics) {\n          data = (target.geometry || target).graphicsData; //"geometry" was introduced in PIXI version 5\n          this._pt = new PropTween(this._pt, target, p, 0, 0, _renderDirtyCache, {\n            g: target.geometry || target\n          });\n          i = data.length;\n          while (--i > -1) {\n            _addColorTween(isV4 ? data[i] : data[i][p.substr(0, 4) + "Style"], isV4 ? p : "color", value, this);\n          }\n        } else {\n          _addColorTween(target, p, value, this);\n        }\n      } else if (p === "autoAlpha") {\n        this._pt = new PropTween(this._pt, target, "visible", 0, 0, _renderAutoAlpha);\n        this.add(target, "alpha", target.alpha, value);\n        this._props.push("alpha", "visible");\n      } else if (p !== "resolution") {\n        this.add(target, p, "get", value);\n      }\n      this._props.push(p);\n    }\n  }\n};\n_getGSAP() && gsap.registerPlugin(PixiPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/PixiPlugin.js?')},"./build/scripts/vendor/gsap/src/ScrambleTextPlugin.js":
/*!*************************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/ScrambleTextPlugin.js ***!
  \*************************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrambleTextPlugin: () => (/* binding */ ScrambleTextPlugin),\n/* harmony export */   "default": () => (/* binding */ ScrambleTextPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ "./build/scripts/vendor/gsap/src/utils/strings.js");\n/*!\n * ScrambleTextPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nclass CharSet {\n  constructor(chars) {\n    this.chars = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(chars);\n    this.sets = [];\n    this.length = 50;\n    for (let i = 0; i < 20; i++) {\n      this.sets[i] = _scrambleText(80, this.chars); //we create 20 strings that are 80 characters long, randomly chosen and pack them into an array. We then randomly choose the scrambled text from this array in order to greatly improve efficiency compared to creating new randomized text from scratch each and every time it\'s needed. This is a simple lookup whereas the other technique requires looping through as many times as there are characters needed, and calling Math.random() each time through the loop, building the string, etc.\n    }\n  }\n  grow(newLength) {\n    //if we encounter a tween that has more than 80 characters, we\'ll need to add to the character sets accordingly. Once it\'s cached, it\'ll only need to grow again if we exceed that new length. Again, this is an efficiency tactic.\n    for (let i = 0; i < 20; i++) {\n      this.sets[i] += _scrambleText(newLength - this.length, this.chars);\n    }\n    this.length = newLength;\n  }\n}\nlet gsap,\n  _coreInitted,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _bonusValidated = 1,\n  //<name>ScrambleTextPlugin</name>\n  _spacesExp = /\\s+/g,\n  _scrambleText = (length, chars) => {\n    let l = chars.length,\n      s = "";\n    while (--length > -1) {\n      s += chars[~~(Math.random() * l)];\n    }\n    return s;\n  },\n  _upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",\n  _lower = _upper.toLowerCase(),\n  _charsLookup = {\n    upperCase: new CharSet(_upper),\n    lowerCase: new CharSet(_lower),\n    upperAndLowerCase: new CharSet(_upper + _lower)\n  },\n  _initCore = () => {\n    _coreInitted = gsap = _getGSAP();\n  };\nconst ScrambleTextPlugin = {\n  version: "3.6.1",\n  name: "scrambleText",\n  register(core, Plugin, propTween) {\n    gsap = core;\n    _initCore();\n  },\n  init(target, value, tween, index, targets) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n    this.prop = "innerHTML" in target ? "innerHTML" : "textContent" in target ? "textContent" : 0; // SVG text in IE doesn\'t have innerHTML, but it does have textContent.\n    if (!this.prop) {\n      return;\n    }\n    this.target = target;\n    if (typeof value !== "object") {\n      value = {\n        text: value\n      };\n    }\n    let text = value.text || value.value,\n      trim = value.trim !== false,\n      data = this,\n      delim,\n      maxLength,\n      charset,\n      splitByChars;\n    data.delimiter = delim = value.delimiter || "";\n    data.original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)((0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText)(target).replace(_spacesExp, " ").split("&nbsp;").join(""), delim, trim);\n    if (text === "{original}" || text === true || text == null) {\n      text = data.original.join(delim);\n    }\n    data.text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)((text || "").replace(_spacesExp, " "), delim, trim);\n    data.hasClass = !!(value.newClass || value.oldClass);\n    data.newClass = value.newClass;\n    data.oldClass = value.oldClass;\n    splitByChars = delim === "";\n    data.textHasEmoji = splitByChars && !!data.text.emoji;\n    data.charsHaveEmoji = !!value.chars && !!(0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(value.chars).emoji;\n    data.length = splitByChars ? data.original.length : data.original.join(delim).length;\n    data.lengthDif = (splitByChars ? data.text.length : data.text.join(delim).length) - data.length;\n    data.fillChar = value.fillChar || value.chars && ~value.chars.indexOf(" ") ? "&nbsp;" : "";\n    data.charSet = charset = _charsLookup[value.chars || "upperCase"] || new CharSet(value.chars);\n    data.speed = 0.05 / (value.speed || 1);\n    data.prevScrambleTime = 0;\n    data.setIndex = Math.random() * 20 | 0;\n    maxLength = data.length + Math.max(data.lengthDif, 0);\n    if (maxLength > charset.length) {\n      charset.grow(maxLength);\n    }\n    data.chars = charset.sets[data.setIndex];\n    data.revealDelay = value.revealDelay || 0;\n    data.tweenLength = value.tweenLength !== false;\n    data.tween = tween;\n    data.rightToLeft = !!value.rightToLeft;\n    data._props.push("scrambleText", "text");\n    return _bonusValidated;\n  },\n  render(ratio, data) {\n    let {\n        target,\n        prop,\n        text,\n        delimiter,\n        tween,\n        prevScrambleTime,\n        revealDelay,\n        setIndex,\n        chars,\n        charSet,\n        length,\n        textHasEmoji,\n        charsHaveEmoji,\n        lengthDif,\n        tweenLength,\n        oldClass,\n        newClass,\n        rightToLeft,\n        fillChar,\n        speed,\n        original,\n        hasClass\n      } = data,\n      l = text.length,\n      time = tween._time,\n      timeDif = time - prevScrambleTime,\n      i,\n      i2,\n      startText,\n      endText,\n      applyNew,\n      applyOld,\n      str,\n      startClass,\n      endClass;\n    if (revealDelay) {\n      if (tween._from) {\n        time = tween._dur - time; //invert the time for from() tweens\n      }\n      ratio = time === 0 ? 0 : time < revealDelay ? 0.000001 : time === tween._dur ? 1 : tween._ease((time - revealDelay) / (tween._dur - revealDelay));\n    }\n    if (ratio < 0) {\n      ratio = 0;\n    } else if (ratio > 1) {\n      ratio = 1;\n    }\n    if (rightToLeft) {\n      ratio = 1 - ratio;\n    }\n    i = ~~(ratio * l + 0.5);\n    if (ratio) {\n      if (timeDif > speed || timeDif < -speed) {\n        data.setIndex = setIndex = (setIndex + (Math.random() * 19 | 0)) % 20;\n        data.chars = charSet.sets[setIndex];\n        data.prevScrambleTime += timeDif;\n      }\n      endText = chars;\n    } else {\n      endText = original.join(delimiter);\n    }\n    if (rightToLeft) {\n      if (ratio === 1 && (tween._from || tween.data === "isFromStart")) {\n        //special case for from() tweens\n        startText = "";\n        endText = original.join(delimiter);\n      } else {\n        str = text.slice(i).join(delimiter);\n        if (charsHaveEmoji) {\n          startText = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(endText).slice(0, length + (tweenLength ? 1 - ratio * ratio * ratio : 1) * lengthDif - (textHasEmoji ? (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(str) : str).length + 0.5 | 0).join("");\n        } else {\n          startText = endText.substr(0, length + (tweenLength ? 1 - ratio * ratio * ratio : 1) * lengthDif - (textHasEmoji ? (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(str) : str).length + 0.5 | 0);\n        }\n        endText = str;\n      }\n    } else {\n      startText = text.slice(0, i).join(delimiter);\n      i2 = (textHasEmoji ? (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(startText) : startText).length;\n      if (charsHaveEmoji) {\n        endText = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(endText).slice(i2, length + (tweenLength ? 1 - (ratio = 1 - ratio) * ratio * ratio * ratio : 1) * lengthDif + 0.5 | 0).join("");\n      } else {\n        endText = endText.substr(i2, length + (tweenLength ? 1 - (ratio = 1 - ratio) * ratio * ratio * ratio : 1) * lengthDif - i2 + 0.5 | 0);\n      }\n    }\n    if (hasClass) {\n      startClass = rightToLeft ? oldClass : newClass;\n      endClass = rightToLeft ? newClass : oldClass;\n      applyNew = startClass && i !== 0;\n      applyOld = endClass && i !== l;\n      str = (applyNew ? "<span class=\'" + startClass + "\'>" : "") + startText + (applyNew ? "</span>" : "") + (applyOld ? "<span class=\'" + endClass + "\'>" : "") + delimiter + endText + (applyOld ? "</span>" : "");\n    } else {\n      str = startText + delimiter + endText;\n    }\n    target[prop] = fillChar === "&nbsp;" && ~str.indexOf("  ") ? str.split("  ").join("&nbsp;&nbsp;") : str;\n  }\n};\nScrambleTextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;\nScrambleTextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;\n_getGSAP() && gsap.registerPlugin(ScrambleTextPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/ScrambleTextPlugin.js?')},"./build/scripts/vendor/gsap/src/ScrollToPlugin.js":
/*!*********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/ScrollToPlugin.js ***!
  \*********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollToPlugin: () => (/* binding */ ScrollToPlugin),\n/* harmony export */   "default": () => (/* binding */ ScrollToPlugin)\n/* harmony export */ });\n/*!\n * ScrollToPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _window,\n  _docEl,\n  _body,\n  _toArray,\n  _config,\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isString = value => typeof value === "string",\n  _isFunction = value => typeof value === "function",\n  _max = (element, axis) => {\n    let dim = axis === "x" ? "Width" : "Height",\n      scroll = "scroll" + dim,\n      client = "client" + dim;\n    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];\n  },\n  _buildGetter = (e, axis) => {\n    //pass in an element and an axis ("x" or "y") and it\'ll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it\'ll use the pageXOffset/pageYOffset or the documentElement\'s scrollTop/scrollLeft or document.body\'s. Basically this streamlines things and makes a very fast getter across browsers.\n    let p = "scroll" + (axis === "x" ? "Left" : "Top");\n    if (e === _window) {\n      if (e.pageXOffset != null) {\n        p = "page" + axis.toUpperCase() + "Offset";\n      } else {\n        e = _docEl[p] != null ? _docEl : _body;\n      }\n    }\n    return () => e[p];\n  },\n  _clean = (value, index, target, targets) => {\n    _isFunction(value) && (value = value(index, target, targets));\n    if (typeof value !== "object") {\n      return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {\n        x: value,\n        y: value\n      } : {\n        y: value\n      }; //if we don\'t receive an object as the parameter, assume the user intends "y".\n    } else if (value.nodeType) {\n      return {\n        y: value,\n        x: value\n      };\n    } else {\n      let result = {},\n        p;\n      for (p in value) {\n        result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n      }\n      return result;\n    }\n  },\n  _getOffset = (element, container) => {\n    element = _toArray(element)[0];\n    if (!element || !element.getBoundingClientRect) {\n      return console.warn("scrollTo target doesn\'t exist. Using 0") || {\n        x: 0,\n        y: 0\n      };\n    }\n    let rect = element.getBoundingClientRect(),\n      isRoot = !container || container === _window || container === _body,\n      cRect = isRoot ? {\n        top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n        left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n      } : container.getBoundingClientRect(),\n      offsets = {\n        x: rect.left - cRect.left,\n        y: rect.top - cRect.top\n      };\n    if (!isRoot && container) {\n      //only add the current scroll position if it\'s not the window/body.\n      offsets.x += _buildGetter(container, "x")();\n      offsets.y += _buildGetter(container, "y")();\n    }\n    return offsets;\n  },\n  _parseVal = (value, target, axis, currentVal, offset) => !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset),\n  _initCore = () => {\n    gsap = _getGSAP();\n    if (_windowExists() && gsap && document.body) {\n      _window = window;\n      _body = document.body;\n      _docEl = document.documentElement;\n      _toArray = gsap.utils.toArray;\n      gsap.config({\n        autoKillThreshold: 7\n      });\n      _config = gsap.config();\n      _coreInitted = 1;\n    }\n  };\nconst ScrollToPlugin = {\n  version: "3.6.1",\n  name: "scrollTo",\n  rawVars: 1,\n  register(core) {\n    gsap = core;\n    _initCore();\n  },\n  init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    let data = this;\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!value.autoKill;\n    data.getX = _buildGetter(target, "x");\n    data.getY = _buildGetter(target, "y");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n    if (value.x != null) {\n      data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);\n      data._props.push("scrollTo_x");\n    } else {\n      data.skipX = 1;\n    }\n    if (value.y != null) {\n      data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);\n      data._props.push("scrollTo_y");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render(ratio, data) {\n    let pt = data._pt,\n      {\n        target,\n        tween,\n        autoKill,\n        xPrev,\n        yPrev,\n        isWin\n      } = data,\n      x,\n      y,\n      yDif,\n      xDif,\n      threshold;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n    if (data.x < 0) {\n      //can\'t scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      data.x = 0;\n    }\n    if (data.y < 0) {\n      data.y = 0;\n    }\n    if (autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it\'s within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {\n        data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n      }\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {\n        data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n      }\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n  },\n  kill(property) {\n    let both = property === "scrollTo";\n    if (both || property === "scrollTo_x") {\n      this.skipX = 1;\n    }\n    if (both || property === "scrollTo_y") {\n      this.skipY = 1;\n    }\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/ScrollToPlugin.js?')},"./build/scripts/vendor/gsap/src/ScrollTrigger.js":
/*!********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/ScrollTrigger.js ***!
  \********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollTrigger: () => (/* binding */ ScrollTrigger),\n/* harmony export */   "default": () => (/* binding */ ScrollTrigger)\n/* harmony export */ });\n/*!\n * ScrollTrigger 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _win,\n  _doc,\n  _docEl,\n  _body,\n  _root,\n  _resizeDelay,\n  _raf,\n  _request,\n  _toArray,\n  _clamp,\n  _time2,\n  _syncInterval,\n  _refreshing,\n  _pointerIsDown,\n  _transformProp,\n  _i,\n  _prevWidth,\n  _prevHeight,\n  _autoRefresh,\n  _sort,\n  _suppressOverwrites,\n  _ignoreResize,\n  _limitCallbacks,\n  // if true, we\'ll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.\n  _startup = 1,\n  _proxies = [],\n  _scrollers = [],\n  _getTime = Date.now,\n  _time1 = _getTime(),\n  _lastScrollTime = 0,\n  _enabled = 1,\n  _passThrough = v => v,\n  _round = value => Math.round(value * 100000) / 100000 || 0,\n  _windowExists = () => typeof window !== "undefined",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isViewport = e => !!~_root.indexOf(e),\n  _getProxyProp = (element, property) => ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property],\n  _getScrollFunc = (element, _ref) => {\n    let {\n      s,\n      sc\n    } = _ref;\n    let i = _scrollers.indexOf(element),\n      offset = sc === _vertical.sc ? 1 : 2;\n    !~i && (i = _scrollers.push(element) - 1);\n    return _scrollers[i + offset] || (_scrollers[i + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc : function (value) {\n      return arguments.length ? element[s] = value : element[s];\n    }));\n  },\n  _getBoundsFunc = element => _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? () => {\n    _winOffsets.width = _win.innerWidth;\n    _winOffsets.height = _win.innerHeight;\n    return _winOffsets;\n  } : () => _getBounds(element)),\n  _getSizeFunc = (scroller, isViewport, _ref2) => {\n    let {\n      d,\n      d2,\n      a\n    } = _ref2;\n    return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? () => a()[d] : () => (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;\n  },\n  _getOffsetsFunc = (element, isViewport) => !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : () => _winOffsets,\n  _maxScroll = (element, _ref3) => {\n    let {\n      s,\n      d2,\n      d,\n      a\n    } = _ref3;\n    return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? Math.max(_docEl[s], _body[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];\n  },\n  _iterateAutoRefresh = (func, events) => {\n    for (let i = 0; i < _autoRefresh.length; i += 3) {\n      (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);\n    }\n  },\n  _isString = value => typeof value === "string",\n  _isFunction = value => typeof value === "function",\n  _isNumber = value => typeof value === "number",\n  _isObject = value => typeof value === "object",\n  _callIfFunc = value => _isFunction(value) && value(),\n  _combineFunc = (f1, f2) => () => {\n    let result1 = _callIfFunc(f1),\n      result2 = _callIfFunc(f2);\n    return () => {\n      _callIfFunc(result1);\n      _callIfFunc(result2);\n    };\n  },\n  _abs = Math.abs,\n  _scrollLeft = "scrollLeft",\n  _scrollTop = "scrollTop",\n  _left = "left",\n  _top = "top",\n  _right = "right",\n  _bottom = "bottom",\n  _width = "width",\n  _height = "height",\n  _Right = "Right",\n  _Left = "Left",\n  _Top = "Top",\n  _Bottom = "Bottom",\n  _padding = "padding",\n  _margin = "margin",\n  _Width = "Width",\n  _Height = "Height",\n  _px = "px",\n  _horizontal = {\n    s: _scrollLeft,\n    p: _left,\n    p2: _Left,\n    os: _right,\n    os2: _Right,\n    d: _width,\n    d2: _Width,\n    a: "x",\n    sc: function (value) {\n      return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n    }\n  },\n  _vertical = {\n    s: _scrollTop,\n    p: _top,\n    p2: _Top,\n    os: _bottom,\n    os2: _Bottom,\n    d: _height,\n    d2: _Height,\n    a: "y",\n    op: _horizontal,\n    sc: function (value) {\n      return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n    }\n  },\n  _getComputedStyle = element => _win.getComputedStyle(element),\n  _makePositionable = element => element.style.position = _getComputedStyle(element).position === "absolute" ? "absolute" : "relative",\n  // if the element already has position: absolute, leave that, otherwise make it position: relative\n  _setDefaults = (obj, defaults) => {\n    for (let p in defaults) {\n      p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n  },\n  //_isInViewport = element => (element = _getBounds(element)) && !(element.top > (_win.innerHeight || _docEl.clientHeight) || element.bottom < 0 || element.left > (_win.innerWidth || _docEl.clientWidth) || element.right < 0) && element,\n  _getBounds = (element, withoutTransforms) => {\n    let tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {\n        x: 0,\n        y: 0,\n        xPercent: 0,\n        yPercent: 0,\n        rotation: 0,\n        rotationX: 0,\n        rotationY: 0,\n        scale: 1,\n        skewX: 0,\n        skewY: 0\n      }).progress(1),\n      bounds = element.getBoundingClientRect();\n    tween && tween.progress(0).kill();\n    return bounds;\n  },\n  _getSize = (element, _ref4) => {\n    let {\n      d2\n    } = _ref4;\n    return element["offset" + d2] || element["client" + d2] || 0;\n  },\n  _getLabelRatioArray = timeline => {\n    let a = [],\n      labels = timeline.labels,\n      duration = timeline.duration(),\n      p;\n    for (p in labels) {\n      a.push(labels[p] / duration);\n    }\n    return a;\n  },\n  _getClosestLabel = animation => value => gsap.utils.snap(_getLabelRatioArray(animation), value),\n  _getLabelAtDirection = timeline => {\n    return (value, st) => {\n      let a = _getLabelRatioArray(timeline),\n        i;\n      a.sort((a, b) => a - b);\n      if (st.direction > 0) {\n        value -= 1e-4; // to avoid rounding errors. If we\'re too strict, it might snap forward, then immediately again, and again.\n        for (i = 0; i < a.length; i++) {\n          if (a[i] >= value) {\n            return a[i];\n          }\n        }\n        return a.pop();\n      } else {\n        i = a.length;\n        value += 1e-4;\n        while (i--) {\n          if (a[i] <= value) {\n            return a[i];\n          }\n        }\n      }\n      return a[0];\n    };\n  },\n  _multiListener = (func, element, types, callback) => types.split(",").forEach(type => func(element, type, callback)),\n  _addListener = (element, type, func) => element.addEventListener(type, func, {\n    passive: true\n  }),\n  _removeListener = (element, type, func) => element.removeEventListener(type, func),\n  _markerDefaults = {\n    startColor: "green",\n    endColor: "red",\n    indent: 0,\n    fontSize: "16px",\n    fontWeight: "normal"\n  },\n  _defaults = {\n    toggleActions: "play",\n    anticipatePin: 0\n  },\n  _keywords = {\n    top: 0,\n    left: 0,\n    center: 0.5,\n    bottom: 1,\n    right: 1\n  },\n  _offsetToPx = (value, size) => {\n    if (_isString(value)) {\n      let eqIndex = value.indexOf("="),\n        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;\n      if (~eqIndex) {\n        value.indexOf("%") > eqIndex && (relative *= size / 100);\n        value = value.substr(0, eqIndex - 1);\n      }\n      value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);\n    }\n    return value;\n  },\n  _createMarker = (type, name, container, direction, _ref5, offset, matchWidthEl) => {\n    let {\n      startColor,\n      endColor,\n      fontSize,\n      indent,\n      fontWeight\n    } = _ref5;\n    let e = _doc.createElement("div"),\n      useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",\n      isScroller = type.indexOf("scroller") !== -1,\n      parent = useFixedPosition ? _body : container,\n      isStart = type.indexOf("start") !== -1,\n      color = isStart ? startColor : endColor,\n      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";\n    css += "position:" + (isScroller && useFixedPosition ? "fixed;" : "absolute;");\n    (isScroller || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");\n    matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");\n    e._isStart = isStart;\n    e.setAttribute("class", "gsap-marker-" + type);\n    e.style.cssText = css;\n    e.innerText = name || name === 0 ? type + "-" + name : type;\n    parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);\n    e._offset = e["offset" + direction.op.d2];\n    _positionMarker(e, 0, direction, isStart);\n    return e;\n  },\n  _positionMarker = (marker, start, direction, flipped) => {\n    let vars = {\n        display: "block"\n      },\n      side = direction[flipped ? "os2" : "p2"],\n      oppositeSide = direction[flipped ? "p2" : "os2"];\n    marker._isFlipped = flipped;\n    vars[direction.a + "Percent"] = flipped ? -100 : 0;\n    vars[direction.a] = flipped ? "1px" : 0;\n    vars["border" + side + _Width] = 1;\n    vars["border" + oppositeSide + _Width] = 0;\n    vars[direction.p] = start + "px";\n    gsap.set(marker, vars);\n  },\n  _triggers = [],\n  _ids = {},\n  _sync = () => _request || (_request = _raf(_updateAll)),\n  _onScroll = () => {\n    if (!_request) {\n      _request = _raf(_updateAll);\n      _lastScrollTime || _dispatch("scrollStart");\n      _lastScrollTime = _getTime();\n    }\n  },\n  _onResize = () => !_refreshing && !_ignoreResize && !_doc.fullscreenElement && _resizeDelay.restart(true),\n  // ignore resizes triggered by refresh()\n  _listeners = {},\n  _emptyArray = [],\n  _media = [],\n  _creatingMedia,\n  // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that\'s created during that call. Then we can revert just those when necessary. In the ScrollTrigger\'s init() call, the _creatingMedia is recorded as a "media" property on the instance.\n  _lastMediaTick,\n  _onMediaChange = e => {\n    let tick = gsap.ticker.frame,\n      matches = [],\n      i = 0,\n      index;\n    if (_lastMediaTick !== tick || _startup) {\n      _revertAll();\n      for (; i < _media.length; i += 4) {\n        index = _win.matchMedia(_media[i]).matches;\n        if (index !== _media[i + 3]) {\n          // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn\'t call the function multiple times. Check to see if it\'s already matched.\n          _media[i + 3] = index;\n          index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn\'t update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it\'s accurate.\n        }\n      }\n      _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.\n      for (i = 0; i < matches.length; i++) {\n        index = matches[i];\n        _creatingMedia = _media[index];\n        _media[index + 2] = _media[index + 1](e);\n      }\n      _creatingMedia = 0;\n      _coreInitted && _refreshAll(0, 1);\n      _lastMediaTick = tick;\n      _dispatch("matchMedia");\n    }\n  },\n  _softRefresh = () => _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true),\n  _dispatch = type => _listeners[type] && _listeners[type].map(f => f()) || _emptyArray,\n  _savedStyles = [],\n  // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.\n  _revertRecorded = media => {\n    for (let i = 0; i < _savedStyles.length; i += 4) {\n      if (!media || _savedStyles[i + 3] === media) {\n        _savedStyles[i].style.cssText = _savedStyles[i + 1];\n        _savedStyles[i + 2].uncache = 1;\n      }\n    }\n  },\n  _revertAll = (kill, media) => {\n    let trigger;\n    for (_i = 0; _i < _triggers.length; _i++) {\n      trigger = _triggers[_i];\n      if (!media || trigger.media === media) {\n        if (kill) {\n          trigger.kill(1);\n        } else {\n          trigger.scroll.rec || (trigger.scroll.rec = trigger.scroll()); // record the scroll positions so that in each refresh() we can ensure that it doesn\'t shift. Remember, pinning can make things change around, especially if the same element is pinned multiple times. If one was already recorded, don\'t re-record because unpinning may have occurred and made it shorter.\n          trigger.revert();\n        }\n      }\n    }\n    _revertRecorded(media);\n    media || _dispatch("revert");\n  },\n  _refreshAll = (force, skipRevert) => {\n    if (_lastScrollTime && !force) {\n      _addListener(ScrollTrigger, "scrollEnd", _softRefresh);\n      return;\n    }\n    let refreshInits = _dispatch("refreshInit");\n    _sort && ScrollTrigger.sort();\n    skipRevert || _revertAll();\n    for (_i = 0; _i < _triggers.length; _i++) {\n      _triggers[_i].refresh();\n    }\n    refreshInits.forEach(result => result && result.render && result.render(-1)); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.\n    _i = _triggers.length;\n    while (_i--) {\n      _triggers[_i].scroll.rec = 0;\n    }\n    _resizeDelay.pause();\n    _dispatch("refresh");\n  },\n  _lastScroll = 0,\n  _direction = 1,\n  _updateAll = () => {\n    let l = _triggers.length,\n      time = _getTime(),\n      recordVelocity = time - _time1 >= 50,\n      scroll = l && _triggers[0].scroll();\n    _direction = _lastScroll > scroll ? -1 : 1;\n    _lastScroll = scroll;\n    if (recordVelocity) {\n      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {\n        _lastScrollTime = 0;\n        _dispatch("scrollEnd");\n      }\n      _time2 = _time1;\n      _time1 = time;\n    }\n    if (_direction < 0) {\n      _i = l;\n      while (_i-- > 0) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n      _direction = 1;\n    } else {\n      for (_i = 0; _i < l; _i++) {\n        _triggers[_i] && _triggers[_i].update(0, recordVelocity);\n      }\n    }\n    _request = 0;\n  },\n  _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex"],\n  _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),\n  _swapPinOut = (pin, spacer, state) => {\n    _setState(state);\n    if (pin.parentNode === spacer) {\n      let parent = spacer.parentNode;\n      if (parent) {\n        parent.insertBefore(pin, spacer);\n        parent.removeChild(spacer);\n      }\n    }\n  },\n  _swapPinIn = (pin, spacer, cs, spacerState) => {\n    if (pin.parentNode !== spacer) {\n      let i = _propNamesToCopy.length,\n        spacerStyle = spacer.style,\n        pinStyle = pin.style,\n        p;\n      while (i--) {\n        p = _propNamesToCopy[i];\n        spacerStyle[p] = cs[p];\n      }\n      spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";\n      cs.display === "inline" && (spacerStyle.display = "inline-block");\n      pinStyle[_bottom] = pinStyle[_right] = "auto";\n      spacerStyle.overflow = "visible";\n      spacerStyle.boxSizing = "border-box";\n      spacerStyle[_width] = _getSize(pin, _horizontal) + _px;\n      spacerStyle[_height] = _getSize(pin, _vertical) + _px;\n      spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";\n      _setState(spacerState);\n      pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];\n      pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];\n      pinStyle[_padding] = cs[_padding];\n      pin.parentNode.insertBefore(spacer, pin);\n      spacer.appendChild(pin);\n    }\n  },\n  _capsExp = /([A-Z])/g,\n  _setState = state => {\n    if (state) {\n      let style = state.t.style,\n        l = state.length,\n        i = 0,\n        p,\n        value;\n      (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off\n      for (; i < l; i += 2) {\n        value = state[i + 1];\n        p = state[i];\n        if (value) {\n          style[p] = value;\n        } else if (style[p]) {\n          style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());\n        }\n      }\n    }\n  },\n  _getState = element => {\n    // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.\n    let l = _stateProps.length,\n      style = element.style,\n      state = [],\n      i = 0;\n    for (; i < l; i++) {\n      state.push(_stateProps[i], style[_stateProps[i]]);\n    }\n    state.t = element;\n    return state;\n  },\n  _copyState = (state, override, omitOffsets) => {\n    let result = [],\n      l = state.length,\n      i = omitOffsets ? 8 : 0,\n      // skip top, left, right, bottom if omitOffsets is true\n      p;\n    for (; i < l; i += 2) {\n      p = state[i];\n      result.push(p, p in override ? override[p] : state[i + 1]);\n    }\n    result.t = state.t;\n    return result;\n  },\n  _winOffsets = {\n    left: 0,\n    top: 0\n  },\n  _parsePosition = (value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax) => {\n    _isFunction(value) && (value = value(self));\n    if (_isString(value) && value.substr(0, 3) === "max") {\n      value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);\n    }\n    if (!_isNumber(value)) {\n      _isFunction(trigger) && (trigger = trigger(self));\n      let element = _toArray(trigger)[0] || _body,\n        bounds = _getBounds(element) || {},\n        offsets = value.split(" "),\n        localOffset,\n        globalOffset,\n        display;\n      if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {\n        // if display is "none", it won\'t report getBoundingClientRect() properly\n        display = element.style.display;\n        element.style.display = "block";\n        bounds = _getBounds(element);\n        display ? element.style.display = display : element.style.removeProperty("display");\n      }\n      localOffset = _offsetToPx(offsets[0], bounds[direction.d]);\n      globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);\n      value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;\n      markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);\n      scrollerSize -= scrollerSize - globalOffset; // adjust for the marker\n    } else if (markerScroller) {\n      _positionMarker(markerScroller, scrollerSize, direction, true);\n    }\n    if (marker) {\n      let position = value + scrollerSize,\n        isStart = marker._isStart;\n      scrollerMax = "scroll" + direction.d2;\n      _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[scrollerMax], _docEl[scrollerMax]) : marker.parentNode[scrollerMax]) <= position + 1);\n      if (useFixedPosition) {\n        scrollerBounds = _getBounds(markerScroller);\n        useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);\n      }\n    }\n    return Math.round(value);\n  },\n  _prefixExp = /(?:webkit|moz|length|cssText|inset)/i,\n  _reparent = (element, parent, top, left) => {\n    if (element.parentNode !== parent) {\n      let style = element.style,\n        p,\n        cs;\n      if (parent === _body) {\n        element._stOrig = style.cssText; // record original inline styles so we can revert them later\n        cs = _getComputedStyle(element);\n        for (p in cs) {\n          // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.\n          if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {\n            style[p] = cs[p];\n          }\n        }\n        style.top = top;\n        style.left = left;\n      } else {\n        style.cssText = element._stOrig;\n      }\n      gsap.core.getCache(element).uncache = 1;\n      parent.appendChild(element);\n    }\n  },\n  // returns a function that can be used to tween the scroll position in the direction provided, and when doing so it\'ll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there\'s a scroll tween running (which would affect if/how things get updated)\n  _getTweenCreator = (scroller, direction) => {\n    let getScroll = _getScrollFunc(scroller, direction),\n      prop = "_scroll" + direction.p2,\n      // add a tweenable property to the scroller that\'s a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it\'ll kill the scroll tween.\n      lastScroll1,\n      lastScroll2,\n      getTween = (scrollTo, vars, initialValue, change1, change2) => {\n        let tween = getTween.tween,\n          onComplete = vars.onComplete,\n          modifiers = {};\n        tween && tween.kill();\n        lastScroll1 = Math.round(initialValue);\n        vars[prop] = scrollTo;\n        vars.modifiers = modifiers;\n        modifiers[prop] = value => {\n          value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.\n          if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2) {\n            // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it\'ll actually report it as 124.\n            tween.kill();\n            getTween.tween = 0;\n          } else {\n            value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;\n          }\n          lastScroll2 = lastScroll1;\n          return lastScroll1 = _round(value);\n        };\n        vars.onComplete = () => {\n          getTween.tween = 0;\n          onComplete && onComplete.call(tween);\n        };\n        tween = getTween.tween = gsap.to(scroller, vars);\n        return tween;\n      };\n    scroller[prop] = getScroll;\n    scroller.addEventListener("wheel", () => getTween.tween && getTween.tween.kill() && (getTween.tween = 0)); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn\'t as sensitive. It\'s much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there\'s a wheel event.\n    return getTween;\n  };\n_horizontal.op = _vertical;\nclass ScrollTrigger {\n  constructor(vars, animation) {\n    _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");\n    this.init(vars, animation);\n  }\n  init(vars, animation) {\n    this.progress = this.start = 0;\n    this.vars && this.kill(1); // in case it\'s being initted again\n    if (!_enabled) {\n      this.update = this.refresh = this.kill = _passThrough;\n      return;\n    }\n    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {\n      trigger: vars\n    } : vars, _defaults);\n    let direction = vars.horizontal ? _horizontal : _vertical,\n      {\n        onUpdate,\n        toggleClass,\n        id,\n        onToggle,\n        onRefresh,\n        scrub,\n        trigger,\n        pin,\n        pinSpacing,\n        invalidateOnRefresh,\n        anticipatePin,\n        onScrubComplete,\n        onSnapComplete,\n        once,\n        snap,\n        pinReparent\n      } = vars,\n      isToggle = !scrub && scrub !== 0,\n      scroller = _toArray(vars.scroller || _win)[0],\n      scrollerCache = gsap.core.getCache(scroller),\n      isViewport = _isViewport(scroller),\n      useFixedPosition = "pinType" in vars ? vars.pinType === "fixed" : isViewport || _getProxyProp(scroller, "pinType") === "fixed",\n      callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],\n      toggleActions = isToggle && vars.toggleActions.split(" "),\n      markers = "markers" in vars ? vars.markers : _defaults.markers,\n      borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,\n      self = this,\n      onRefreshInit = vars.onRefreshInit && (() => vars.onRefreshInit(self)),\n      getScrollerSize = _getSizeFunc(scroller, isViewport, direction),\n      getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),\n      tweenTo,\n      pinCache,\n      snapFunc,\n      isReverted,\n      scroll1,\n      scroll2,\n      start,\n      end,\n      markerStart,\n      markerEnd,\n      markerStartTrigger,\n      markerEndTrigger,\n      markerVars,\n      change,\n      pinOriginalState,\n      pinActiveState,\n      pinState,\n      spacer,\n      offset,\n      pinGetter,\n      pinSetter,\n      pinStart,\n      pinChange,\n      spacingStart,\n      spacerState,\n      markerStartSetter,\n      markerEndSetter,\n      cs,\n      snap1,\n      snap2,\n      scrubTween,\n      scrubSmooth,\n      snapDurClamp,\n      snapDelayedCall,\n      prevProgress,\n      prevScroll,\n      prevAnimProgress;\n    self.media = _creatingMedia;\n    anticipatePin *= 45;\n    _triggers.push(self);\n    self.scroller = scroller;\n    self.scroll = _getScrollFunc(scroller, direction);\n    scroll1 = self.scroll();\n    self.vars = vars;\n    animation = animation || vars.animation;\n    "refreshPriority" in vars && (_sort = 1);\n    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {\n      top: _getTweenCreator(scroller, _vertical),\n      left: _getTweenCreator(scroller, _horizontal)\n    };\n    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];\n    if (animation) {\n      animation.vars.lazy = false;\n      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);\n      self.animation = animation.pause();\n      animation.scrollTrigger = self;\n      scrubSmooth = _isNumber(scrub) && scrub;\n      scrubSmooth && (scrubTween = gsap.to(animation, {\n        ease: "power3",\n        duration: scrubSmooth,\n        onComplete: () => onScrubComplete && onScrubComplete(self)\n      }));\n      snap1 = 0;\n      id || (id = animation.vars.id);\n    }\n    if (snap) {\n      _isObject(snap) || (snap = {\n        snapTo: snap\n      });\n      "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {\n        scrollBehavior: "auto"\n      }); // smooth scrolling doesn\'t work with snap.\n      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : gsap.utils.snap(snap.snapTo);\n      snapDurClamp = snap.duration || {\n        min: 0.1,\n        max: 2\n      };\n      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);\n      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, () => {\n        if (Math.abs(self.getVelocity()) < 10 && !_pointerIsDown) {\n          let totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,\n            velocity = (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,\n            change1 = _abs(velocity / 2) * velocity / 0.185,\n            naturalEnd = totalProgress + (snap.inertia === false ? 0 : change1),\n            endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),\n            scroll = self.scroll(),\n            endScroll = Math.round(start + endValue * change),\n            {\n              onStart,\n              onInterrupt,\n              onComplete\n            } = snap,\n            tween = tweenTo.tween;\n          if (scroll <= end && scroll >= start && endScroll !== scroll) {\n            if (tween && !tween._initted && tween.data <= Math.abs(endScroll - scroll)) {\n              // there\'s an overlapping snap! So we must figure out which one is closer and let that tween live.\n              return;\n            }\n            tweenTo(endScroll, {\n              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),\n              ease: snap.ease || "power3",\n              data: Math.abs(endScroll - scroll),\n              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.\n              onInterrupt: () => snapDelayedCall.restart(true) && onInterrupt && onInterrupt(self),\n              onComplete: () => {\n                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;\n                onSnapComplete && onSnapComplete(self);\n                onComplete && onComplete(self);\n              }\n            }, scroll, change1 * change, endScroll - scroll - change1 * change);\n            onStart && onStart(self, tweenTo.tween);\n          }\n        } else if (self.isActive) {\n          snapDelayedCall.restart(true);\n        }\n      }).pause();\n    }\n    id && (_ids[id] = self);\n    trigger = self.trigger = _toArray(trigger || pin)[0];\n    pin = pin === true ? trigger : _toArray(pin)[0];\n    _isString(toggleClass) && (toggleClass = {\n      targets: trigger,\n      className: toggleClass\n    });\n    if (pin) {\n      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don\'t apply pinSpacing by default.\n      self.pin = pin;\n      vars.force3D !== false && gsap.set(pin, {\n        force3D: true\n      });\n      pinCache = gsap.core.getCache(pin);\n      if (!pinCache.spacer) {\n        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don\'t want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.\n        pinCache.spacer = spacer = _doc.createElement("div");\n        spacer.setAttribute("class", "pin-spacer" + (id ? " pin-spacer-" + id : ""));\n        pinCache.pinState = pinOriginalState = _getState(pin);\n      } else {\n        pinOriginalState = pinCache.pinState;\n      }\n      self.spacer = spacer = pinCache.spacer;\n      cs = _getComputedStyle(pin);\n      spacingStart = cs[pinSpacing + direction.os2];\n      pinGetter = gsap.getProperty(pin);\n      pinSetter = gsap.quickSetter(pin, direction.a, _px);\n      // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).\n      _swapPinIn(pin, spacer, cs);\n      pinState = _getState(pin);\n    }\n    if (markers) {\n      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;\n      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);\n      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);\n      offset = markerStartTrigger["offset" + direction.op.d2];\n      markerStart = _createMarker("start", id, scroller, direction, markerVars, offset);\n      markerEnd = _createMarker("end", id, scroller, direction, markerVars, offset);\n      if (!useFixedPosition) {\n        _makePositionable(isViewport ? _body : scroller);\n        gsap.set([markerStartTrigger, markerEndTrigger], {\n          force3D: true\n        });\n        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);\n        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);\n      }\n    }\n    self.revert = revert => {\n      let r = revert !== false || !self.enabled,\n        prevRefreshing = _refreshing;\n      if (r !== isReverted) {\n        if (r) {\n          prevScroll = Math.max(self.scroll(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.\n          prevProgress = self.progress;\n          prevAnimProgress = animation && animation.progress();\n        }\n        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.style.display = r ? "none" : "block");\n        r && (_refreshing = 1);\n        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.\n        _refreshing = prevRefreshing;\n        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));\n        isReverted = r;\n      }\n    };\n    self.refresh = (soft, force) => {\n      if ((_refreshing || !self.enabled) && !force) {\n        return;\n      }\n      if (pin && soft && _lastScrollTime) {\n        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);\n        return;\n      }\n      _refreshing = 1;\n      scrubTween && scrubTween.pause();\n      invalidateOnRefresh && animation && animation.progress(0).invalidate();\n      isReverted || self.revert();\n      let size = getScrollerSize(),\n        scrollerBounds = getScrollerOffsets(),\n        max = _maxScroll(scroller, direction),\n        offset = 0,\n        otherPinOffset = 0,\n        parsedEnd = vars.end,\n        parsedEndTrigger = vars.endTrigger || trigger,\n        parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),\n        triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,\n        i = triggerIndex,\n        cs,\n        bounds,\n        scroll,\n        isVertical,\n        override,\n        curTrigger,\n        curPin,\n        oppositeScroll,\n        initted;\n      while (i--) {\n        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they\'re pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.\n        curTrigger = _triggers[i];\n        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it\'s a timeline-based trigger that hasn\'t been fully initialized yet because it\'s waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that\'s supposed to affect other ScrollTriggers further down the page, they won\'t be adjusted properly.\n        curPin = curTrigger.pin;\n        curPin && (curPin === trigger || curPin === pin) && curTrigger.revert();\n      }\n      start = _parsePosition(parsedStart, trigger, size, direction, self.scroll(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max) || (pin ? -0.001 : 0);\n      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));\n      if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {\n        if (~parsedEnd.indexOf(" ")) {\n          parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;\n        } else {\n          offset = _offsetToPx(parsedEnd.substr(2), size);\n          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won\'t factor in the offset if the start is a number, so do it here.\n          parsedEndTrigger = trigger;\n        }\n      }\n      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, self.scroll() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max)) || -0.001;\n      change = end - start || (start -= 0.01) && 0.001;\n      offset = 0;\n      i = triggerIndex;\n      while (i--) {\n        curTrigger = _triggers[i];\n        curPin = curTrigger.pin;\n        if (curPin && curTrigger.start - curTrigger._pinPush < start) {\n          cs = curTrigger.end - curTrigger.start;\n          curPin === trigger && (offset += cs);\n          curPin === pin && (otherPinOffset += cs);\n        }\n      }\n      start += offset;\n      end += offset;\n      self._pinPush = otherPinOffset;\n      if (markerStart && offset) {\n        // offset the markers if necessary\n        cs = {};\n        cs[direction.a] = "+=" + offset;\n        gsap.set([markerStart, markerEnd], cs);\n      }\n      if (pin) {\n        cs = _getComputedStyle(pin);\n        isVertical = direction === _vertical;\n        scroll = self.scroll(); // recalculate because the triggers can affect the scroll\n        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;\n        !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/\n        _swapPinIn(pin, spacer, cs);\n        pinState = _getState(pin);\n        // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.\n        bounds = _getBounds(pin, true);\n        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();\n        if (pinSpacing) {\n          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];\n          spacerState.t = spacer;\n          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;\n          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).\n          _setState(spacerState);\n          useFixedPosition && self.scroll(prevScroll);\n        }\n        if (useFixedPosition) {\n          override = {\n            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,\n            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,\n            boxSizing: "border-box",\n            position: "fixed"\n          };\n          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;\n          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;\n          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";\n          override[_padding] = cs[_padding];\n          override[_padding + _Top] = cs[_padding + _Top];\n          override[_padding + _Right] = cs[_padding + _Right];\n          override[_padding + _Bottom] = cs[_padding + _Bottom];\n          override[_padding + _Left] = cs[_padding + _Left];\n          pinActiveState = _copyState(pinOriginalState, override, pinReparent);\n        }\n        if (animation) {\n          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn\'t include whatever the animation did.\n          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.\n          _suppressOverwrites(1);\n          animation.progress(1, true);\n          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;\n          change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.\n          animation.progress(0, true);\n          initted || animation.invalidate();\n          _suppressOverwrites(0);\n        } else {\n          pinChange = change;\n        }\n      } else if (trigger && self.scroll()) {\n        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that\'s already scrolled would throw off the measurements in getBoundingClientRect()\n        bounds = trigger.parentNode;\n        while (bounds && bounds !== _body) {\n          if (bounds._pinOffset) {\n            start -= bounds._pinOffset;\n            end -= bounds._pinOffset;\n          }\n          bounds = bounds.parentNode;\n        }\n      }\n      for (i = 0; i < triggerIndex; i++) {\n        // make sure we revert from first to last to make sure things reach their end state properly\n        curTrigger = _triggers[i].pin;\n        curTrigger && (curTrigger === trigger || curTrigger === pin) && _triggers[i].revert(false);\n      }\n      self.start = start;\n      self.end = end;\n      scroll1 = scroll2 = self.scroll(); // reset velocity\n      scroll1 < prevScroll && self.scroll(prevScroll);\n      self.revert(false);\n      _refreshing = 0;\n      animation && isToggle && animation._initted && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().\n      if (prevProgress !== self.progress) {\n        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.\n        scrubTween && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren\'t triggered.\n        self.progress = prevProgress;\n        self.update();\n      }\n      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));\n      onRefresh && onRefresh(self);\n    };\n    self.getVelocity = () => (self.scroll() - scroll2) / (_getTime() - _time2) * 1000 || 0;\n    self.update = (reset, recordVelocity) => {\n      let scroll = self.scroll(),\n        p = reset ? 0 : (scroll - start) / change,\n        clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,\n        prevProgress = self.progress,\n        isActive,\n        wasActive,\n        toggleState,\n        action,\n        stateChanged,\n        toggled;\n      if (recordVelocity) {\n        scroll2 = scroll1;\n        scroll1 = scroll;\n        if (snap) {\n          snap2 = snap1;\n          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;\n        }\n      }\n      // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).\n      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);\n      if (clipped !== prevProgress && self.enabled) {\n        isActive = self.isActive = !!clipped && clipped < 1;\n        wasActive = !!prevProgress && prevProgress < 1;\n        toggled = isActive !== wasActive;\n        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn\'t toggle but it did change state in a sense (may need to fire a callback)\n        self.direction = clipped > prevProgress ? 1 : -1;\n        self.progress = clipped;\n        if (!isToggle) {\n          if (scrubTween && !_refreshing && !_startup) {\n            scrubTween.vars.totalProgress = clipped;\n            scrubTween.invalidate().restart();\n          } else if (animation) {\n            animation.totalProgress(clipped, !!_refreshing);\n          }\n        }\n        if (pin) {\n          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);\n          if (!useFixedPosition) {\n            pinSetter(pinStart + pinChange * clipped);\n          } else if (stateChanged) {\n            action = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it\'s at the VERY end of the page, don\'t switch away from position: fixed because it\'s pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)\n            if (pinReparent) {\n              if (!reset && (isActive || action)) {\n                let bounds = _getBounds(pin, true),\n                  offset = scroll - start;\n                _reparent(pin, _body, bounds.top + (direction === _vertical ? offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : offset) + _px);\n              } else {\n                _reparent(pin, spacer);\n              }\n            }\n            _setState(isActive || action ? pinActiveState : pinState);\n            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !action ? pinChange : 0));\n          }\n        }\n        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);\n        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(el => el.classList[isActive || once ? "add" : "remove"](toggleClass.className)); // classes could affect positioning, so do it even if reset or refreshing is true.\n        onUpdate && !isToggle && !reset && onUpdate(self);\n        if (stateChanged && !_refreshing) {\n          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it\'d prioritize onEnter.\n          if (isToggle) {\n            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn\'t toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)\n            if (animation && (action === "complete" || action === "reset" || action in animation)) {\n              if (action === "complete") {\n                animation.pause().totalProgress(1);\n              } else if (action === "reset") {\n                animation.restart(true).pause();\n              } else {\n                animation[action]();\n              }\n            }\n            onUpdate && onUpdate(self);\n          }\n          if (toggled || !_limitCallbacks) {\n            // on startup, the page could be scrolled and we don\'t want to fire callbacks that didn\'t toggle. For example onEnter shouldn\'t fire if the ScrollTrigger isn\'t actually entered.\n            onToggle && toggled && onToggle(self);\n            callbacks[toggleState] && callbacks[toggleState](self);\n            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn\'t be called again if once is true.\n            if (!toggled) {\n              // it\'s possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order\n              toggleState = clipped === 1 ? 1 : 3;\n              callbacks[toggleState] && callbacks[toggleState](self);\n            }\n          }\n        } else if (isToggle && onUpdate && !_refreshing) {\n          onUpdate(self);\n        }\n      }\n      // update absolutely-positioned markers (only if the scroller isn\'t the viewport)\n      if (markerEndSetter) {\n        markerStartSetter(scroll + (markerStartTrigger._isFlipped ? 1 : 0));\n        markerEndSetter(scroll);\n      }\n    };\n    self.enable = () => {\n      if (!self.enabled) {\n        self.enabled = true;\n        _addListener(scroller, "resize", _onResize);\n        _addListener(scroller, "scroll", _onScroll);\n        onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);\n        !animation || !animation.add ? self.refresh() : gsap.delayedCall(0.01, () => start || end || self.refresh()) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn\'t render at the proper place on the first refresh(), thus we should schedule one for the next tick.\n      }\n    };\n    self.disable = (reset, allowAnimation) => {\n      if (self.enabled) {\n        reset !== false && self.revert();\n        self.enabled = self.isActive = false;\n        allowAnimation || scrubTween && scrubTween.pause();\n        prevScroll = 0;\n        pinCache && (pinCache.uncache = 1);\n        onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);\n        if (snapDelayedCall) {\n          snapDelayedCall.pause();\n          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);\n        }\n        if (!isViewport) {\n          let i = _triggers.length;\n          while (i--) {\n            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {\n              return; //don\'t remove the listeners if there are still other triggers referencing it.\n            }\n          }\n          _removeListener(scroller, "resize", _onResize);\n          _removeListener(scroller, "scroll", _onScroll);\n        }\n      }\n    };\n    self.kill = (revert, allowAnimation) => {\n      self.disable(revert, allowAnimation);\n      id && delete _ids[id];\n      let i = _triggers.indexOf(self);\n      _triggers.splice(i, 1);\n      i === _i && _direction > 0 && _i--; // if we\'re in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...\n      if (animation) {\n        animation.scrollTrigger = null;\n        revert && animation.render(-1);\n        allowAnimation || animation.kill();\n      }\n      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(m => m.parentNode.removeChild(m));\n      if (pin) {\n        pinCache && (pinCache.uncache = 1);\n        i = 0;\n        _triggers.forEach(t => t.pin === pin && i++);\n        i || (pinCache.spacer = 0); // if there aren\'t any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.\n      }\n    };\n    self.enable();\n  }\n  static register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n      if (_windowExists() && window.document) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n      }\n      if (gsap) {\n        _toArray = gsap.utils.toArray;\n        _clamp = gsap.utils.clamp;\n        _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;\n        gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don\'t have a "name" property.\n        if (_body) {\n          _raf = _win.requestAnimationFrame || (f => setTimeout(f, 16));\n          _addListener(_win, "wheel", _onScroll);\n          _root = [_win, _doc, _docEl, _body];\n          _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it\'s consistent on the document!\n          let bodyStyle = _body.style,\n            border = bodyStyle.borderTop,\n            bounds;\n          bodyStyle.borderTop = "1px solid #000"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there\'s a margin when there actually isn\'t. The border ensures that the bounds are accurate.\n          bounds = _getBounds(_body);\n          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding\n          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;\n          border ? bodyStyle.borderTop = border : bodyStyle.removeProperty("border-top");\n          _syncInterval = setInterval(_sync, 200);\n          gsap.delayedCall(0.5, () => _startup = 0);\n          _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don\'t listen for "touchcancel" on the document.\n          _addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n          _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", () => _pointerIsDown = 1);\n          _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", () => _pointerIsDown = 0);\n          _transformProp = gsap.utils.checkPrefix("transform");\n          _stateProps.push(_transformProp);\n          _coreInitted = _getTime();\n          _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();\n          _autoRefresh = [_doc, "visibilitychange", () => {\n            let w = _win.innerWidth,\n              h = _win.innerHeight;\n            if (_doc.hidden) {\n              _prevWidth = w;\n              _prevHeight = h;\n            } else if (_prevWidth !== w || _prevHeight !== h) {\n              _onResize();\n            }\n          }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", () => _lastScrollTime || _refreshAll(), _win, "resize", _onResize];\n          _iterateAutoRefresh(_addListener);\n        }\n      }\n    }\n    return _coreInitted;\n  }\n  static defaults(config) {\n    for (let p in config) {\n      _defaults[p] = config[p];\n    }\n  }\n  static kill() {\n    _enabled = 0;\n    _triggers.slice(0).forEach(trigger => trigger.kill(1));\n  }\n  static config(vars) {\n    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);\n    let ms = vars.syncInterval;\n    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);\n    if ("autoRefreshEvents" in vars) {\n      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");\n      _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;\n    }\n  }\n  static scrollerProxy(target, vars) {\n    let t = _toArray(target)[0],\n      i = _scrollers.indexOf(t),\n      isViewport = _isViewport(t);\n    if (~i) {\n      _scrollers.splice(i, isViewport ? 6 : 2);\n    }\n    isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);\n  }\n  static matchMedia(vars) {\n    // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8\n    let mq, p, i, func, result;\n    for (p in vars) {\n      i = _media.indexOf(p);\n      func = vars[p];\n      _creatingMedia = p;\n      if (p === "all") {\n        func();\n      } else {\n        mq = _win.matchMedia(p);\n        if (mq) {\n          mq.matches && (result = func());\n          if (~i) {\n            _media[i + 1] = _combineFunc(_media[i + 1], func);\n            _media[i + 2] = _combineFunc(_media[i + 2], result);\n          } else {\n            i = _media.length;\n            _media.push(p, func, result);\n            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);\n          }\n          _media[i + 3] = mq.matches;\n        }\n      }\n      _creatingMedia = 0;\n    }\n    return _media;\n  }\n  static clearMatchMedia(query) {\n    query || (_media.length = 0);\n    query = _media.indexOf(query);\n    query >= 0 && _media.splice(query, 4);\n  }\n}\nScrollTrigger.version = "3.6.1";\nScrollTrigger.saveStyles = targets => targets ? _toArray(targets).forEach(target => {\n  if (target && target.style) {\n    let i = _savedStyles.indexOf(target);\n    i >= 0 && _savedStyles.splice(i, 4);\n    _savedStyles.push(target, target.style.cssText, gsap.core.getCache(target), _creatingMedia);\n  }\n}) : _savedStyles;\nScrollTrigger.revert = (soft, media) => _revertAll(!soft, media);\nScrollTrigger.create = (vars, animation) => new ScrollTrigger(vars, animation);\nScrollTrigger.refresh = safe => safe ? _onResize() : _refreshAll(true);\nScrollTrigger.update = _updateAll;\nScrollTrigger.maxScroll = (element, horizontal) => _maxScroll(element, horizontal ? _horizontal : _vertical);\nScrollTrigger.getScrollFunc = (element, horizontal) => _getScrollFunc(_toArray(element)[0], horizontal ? _horizontal : _vertical);\nScrollTrigger.getById = id => _ids[id];\nScrollTrigger.getAll = () => _triggers.slice(0);\nScrollTrigger.isScrolling = () => !!_lastScrollTime;\nScrollTrigger.addEventListener = (type, callback) => {\n  let a = _listeners[type] || (_listeners[type] = []);\n  ~a.indexOf(callback) || a.push(callback);\n};\nScrollTrigger.removeEventListener = (type, callback) => {\n  let a = _listeners[type],\n    i = a && a.indexOf(callback);\n  i >= 0 && a.splice(i, 1);\n};\nScrollTrigger.batch = (targets, vars) => {\n  let result = [],\n    varsCopy = {},\n    interval = vars.interval || 0.016,\n    batchMax = vars.batchMax || 1e9,\n    proxyCallback = (type, callback) => {\n      let elements = [],\n        triggers = [],\n        delay = gsap.delayedCall(interval, () => {\n          callback(elements, triggers);\n          elements = [];\n          triggers = [];\n        }).pause();\n      return self => {\n        elements.length || delay.restart(true);\n        elements.push(self.trigger);\n        triggers.push(self);\n        batchMax <= elements.length && delay.progress(1);\n      };\n    },\n    p;\n  for (p in vars) {\n    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];\n  }\n  if (_isFunction(batchMax)) {\n    batchMax = batchMax();\n    _addListener(ScrollTrigger, "refresh", () => batchMax = vars.batchMax());\n  }\n  _toArray(targets).forEach(target => {\n    let config = {};\n    for (p in varsCopy) {\n      config[p] = varsCopy[p];\n    }\n    config.trigger = target;\n    result.push(ScrollTrigger.create(config));\n  });\n  return result;\n};\nScrollTrigger.sort = func => _triggers.sort(func || ((a, b) => (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6)));\n_getGSAP() && gsap.registerPlugin(ScrollTrigger);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/ScrollTrigger.js?')},"./build/scripts/vendor/gsap/src/SplitText.js":
/*!****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/SplitText.js ***!
  \****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SplitText: () => (/* binding */ SplitText),\n/* harmony export */   "default": () => (/* binding */ SplitText)\n/* harmony export */ });\n/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ "./build/scripts/vendor/gsap/src/utils/strings.js");\n/*!\n * SplitText: 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet _doc,\n  _win,\n  _coreInitted,\n  _stripExp = /(?:\\r|\\n|\\t\\t)/g,\n  //find carriage returns, new line feeds and double-tabs.\n  _multipleSpacesExp = /(?:\\s\\s+)/g,\n  _initCore = () => {\n    _doc = document;\n    _win = window;\n    _coreInitted = 1;\n  },\n  _bonusValidated = 1,\n  //<name>SplitText</name>\n  _getComputedStyle = element => _win.getComputedStyle(element),\n  _isArray = Array.isArray,\n  _slice = [].slice,\n  _toArray = (value, leaveStrings) => {\n    //takes any value and returns an array. If it\'s a string (and leaveStrings isn\'t true), it\'ll use document.querySelectorAll() and convert that to an array. It\'ll also accept iterables like jQuery objects.\n    let type;\n    return _isArray(value) ? value : (type = typeof value) === "string" && !leaveStrings && value ? _slice.call(_doc.querySelectorAll(value), 0) : value && type === "object" && "length" in value ? _slice.call(value, 0) : value ? [value] : [];\n  },\n  _isAbsolute = vars => vars.position === "absolute" || vars.absolute === true,\n  //some characters are combining marks (think diacritics/accents in European languages) which involve 2 or 4 characters that combine in the browser to form a single character. Pass in the remaining text and an array of the special characters to search for and if the text starts with one of those special characters, it\'ll spit back the number of characters to retain (often 2 or 4). Used in the specialChars features that was introduced in 0.6.0.\n  _findSpecialChars = (text, chars) => {\n    let i = chars.length,\n      s;\n    while (--i > -1) {\n      s = chars[i];\n      if (text.substr(0, s.length) === s) {\n        return s.length;\n      }\n    }\n  },\n  _divStart = " style=\'position:relative;display:inline-block;\'",\n  _cssClassFunc = function () {\n    let cssClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";\n    let tag = arguments.length > 1 ? arguments[1] : undefined;\n    let iterate = ~cssClass.indexOf("++"),\n      num = 1;\n    if (iterate) {\n      cssClass = cssClass.split("++").join("");\n    }\n    return () => "<" + tag + _divStart + (cssClass ? " class=\'" + cssClass + (iterate ? num++ : "") + "\'>" : ">");\n  },\n  _swapText = (element, oldText, newText) => {\n    let type = element.nodeType;\n    if (type === 1 || type === 9 || type === 11) {\n      for (element = element.firstChild; element; element = element.nextSibling) {\n        _swapText(element, oldText, newText);\n      }\n    } else if (type === 3 || type === 4) {\n      element.nodeValue = element.nodeValue.split(oldText).join(newText);\n    }\n  },\n  _pushReversed = (a, merge) => {\n    let i = merge.length;\n    while (--i > -1) {\n      a.push(merge[i]);\n    }\n  },\n  _isBeforeWordDelimiter = (e, root, wordDelimiter) => {\n    let next;\n    while (e && e !== root) {\n      next = e._next || e.nextSibling;\n      if (next) {\n        return next.textContent.charAt(0) === wordDelimiter;\n      }\n      e = e.parentNode || e._parent;\n    }\n  },\n  _deWordify = e => {\n    let children = _toArray(e.childNodes),\n      l = children.length,\n      i,\n      child;\n    for (i = 0; i < l; i++) {\n      child = children[i];\n      if (child._isSplit) {\n        _deWordify(child);\n      } else {\n        if (i && child.previousSibling && child.previousSibling.nodeType === 3) {\n          child.previousSibling.nodeValue += child.nodeType === 3 ? child.nodeValue : child.firstChild.nodeValue;\n          e.removeChild(child);\n        } else if (child.nodeType !== 3) {\n          e.insertBefore(child.firstChild, child);\n          e.removeChild(child);\n        }\n      }\n    }\n  },\n  _getStyleAsNumber = (name, computedStyle) => parseFloat(computedStyle[name]) || 0,\n  _setPositionsAfterSplit = (element, vars, allChars, allWords, allLines, origWidth, origHeight) => {\n    let cs = _getComputedStyle(element),\n      paddingLeft = _getStyleAsNumber("paddingLeft", cs),\n      lineOffsetY = -999,\n      borderTopAndBottom = _getStyleAsNumber("borderBottomWidth", cs) + _getStyleAsNumber("borderTopWidth", cs),\n      borderLeftAndRight = _getStyleAsNumber("borderLeftWidth", cs) + _getStyleAsNumber("borderRightWidth", cs),\n      padTopAndBottom = _getStyleAsNumber("paddingTop", cs) + _getStyleAsNumber("paddingBottom", cs),\n      padLeftAndRight = _getStyleAsNumber("paddingLeft", cs) + _getStyleAsNumber("paddingRight", cs),\n      lineThreshold = _getStyleAsNumber("fontSize", cs) * (vars.lineThreshold || 0.2),\n      textAlign = cs.textAlign,\n      charArray = [],\n      wordArray = [],\n      lineArray = [],\n      wordDelimiter = vars.wordDelimiter || " ",\n      tag = vars.tag ? vars.tag : vars.span ? "span" : "div",\n      types = vars.type || vars.split || "chars,words,lines",\n      lines = allLines && ~types.indexOf("lines") ? [] : null,\n      words = ~types.indexOf("words"),\n      chars = ~types.indexOf("chars"),\n      absolute = _isAbsolute(vars),\n      linesClass = vars.linesClass,\n      iterateLine = ~(linesClass || "").indexOf("++"),\n      spaceNodesToRemove = [],\n      isFlex = cs.display === "flex",\n      prevInlineDisplay = element.style.display,\n      i,\n      j,\n      l,\n      node,\n      nodes,\n      isChild,\n      curLine,\n      addWordSpaces,\n      style,\n      lineNode,\n      lineWidth,\n      offset;\n    iterateLine && (linesClass = linesClass.split("++").join(""));\n    isFlex && (element.style.display = "block");\n\n    //copy all the descendant nodes into an array (we can\'t use a regular nodeList because it\'s live and we may need to renest things)\n    j = element.getElementsByTagName("*");\n    l = j.length;\n    nodes = [];\n    for (i = 0; i < l; i++) {\n      nodes[i] = j[i];\n    }\n\n    //for absolute positioning, we need to record the x/y offsets and width/height for every <div>. And even if we\'re not positioning things absolutely, in order to accommodate lines, we must figure out where the y offset changes so that we can sense where the lines break, and we populate the lines array.\n    if (lines || absolute) {\n      for (i = 0; i < l; i++) {\n        node = nodes[i];\n        isChild = node.parentNode === element;\n        if (isChild || absolute || chars && !words) {\n          offset = node.offsetTop;\n          if (lines && isChild && Math.abs(offset - lineOffsetY) > lineThreshold && (node.nodeName !== "BR" || i === 0)) {\n            //we found some rare occasions where a certain character like &#8209; could cause the offsetTop to be off by 1 pixel, so we build in a threshold.\n            curLine = [];\n            lines.push(curLine);\n            lineOffsetY = offset;\n          }\n          if (absolute) {\n            //record offset x and y, as well as width and height so that we can access them later for positioning. Grabbing them at once ensures we don\'t trigger a browser paint & we maximize performance.\n            node._x = node.offsetLeft;\n            node._y = offset;\n            node._w = node.offsetWidth;\n            node._h = node.offsetHeight;\n          }\n          if (lines) {\n            if (node._isSplit && isChild || !chars && isChild || words && isChild || !words && node.parentNode.parentNode === element && !node.parentNode._isSplit) {\n              curLine.push(node);\n              node._x -= paddingLeft;\n              if (_isBeforeWordDelimiter(node, element, wordDelimiter)) {\n                node._wordEnd = true;\n              }\n            }\n            if (node.nodeName === "BR" && (node.nextSibling && node.nextSibling.nodeName === "BR" || i === 0)) {\n              //two consecutive <br> tags signify a new [empty] line. Also, if the entire block of content STARTS with a <br>, add a line.\n              lines.push([]);\n            }\n          }\n        }\n      }\n    }\n    for (i = 0; i < l; i++) {\n      node = nodes[i];\n      isChild = node.parentNode === element;\n      if (node.nodeName === "BR") {\n        if (lines || absolute) {\n          node.parentNode && node.parentNode.removeChild(node);\n          nodes.splice(i--, 1);\n          l--;\n        } else if (!words) {\n          element.appendChild(node);\n        }\n        continue;\n      }\n      if (absolute) {\n        style = node.style;\n        if (!words && !isChild) {\n          node._x += node.parentNode._x;\n          node._y += node.parentNode._y;\n        }\n        style.left = node._x + "px";\n        style.top = node._y + "px";\n        style.position = "absolute";\n        style.display = "block";\n        //if we don\'t set the width/height, things collapse in older versions of IE and the origin for transforms is thrown off in all browsers.\n        style.width = node._w + 1 + "px"; //IE is 1px short sometimes. Avoid wrapping\n        style.height = node._h + "px";\n      }\n      if (!words && chars) {\n        //we always start out wrapping words in their own <div> so that line breaks happen correctly, but here we\'ll remove those <div> tags if necessary and re-nest the characters directly into the element rather than inside the word <div>\n        if (node._isSplit) {\n          node._next = j = node.nextSibling;\n          node.parentNode.appendChild(node); //put it at the end to keep the order correct.\n          while (j && j.nodeType === 3 && j.textContent === " ") {\n            // if there are nodes that are just a space right afterward, go ahead and append them to the end so they\'re not out of order.\n            node._next = j.nextSibling;\n            node.parentNode.appendChild(j);\n            j = j.nextSibling;\n          }\n        } else if (node.parentNode._isSplit) {\n          node._parent = node.parentNode;\n          if (!node.previousSibling && node.firstChild) {\n            node.firstChild._isFirst = true;\n          }\n          if (node.nextSibling && node.nextSibling.textContent === " " && !node.nextSibling.nextSibling) {\n            //if the last node inside a nested element is just a space (like T<span>nested </span>), remove it otherwise it\'ll get placed in the wrong order. Don\'t remove it right away, though, because we need to sense when words/characters are before a space like _isBeforeWordDelimiter(). Removing it now would make that a false negative.\n            spaceNodesToRemove.push(node.nextSibling);\n          }\n          node._next = node.nextSibling && node.nextSibling._isFirst ? null : node.nextSibling;\n          node.parentNode.removeChild(node);\n          nodes.splice(i--, 1);\n          l--;\n        } else if (!isChild) {\n          offset = !node.nextSibling && _isBeforeWordDelimiter(node.parentNode, element, wordDelimiter); //if this is the last letter in the word (and we\'re not breaking by lines and not positioning things absolutely), we need to add a space afterwards so that the characters don\'t just mash together\n          node.parentNode._parent && node.parentNode._parent.appendChild(node);\n          offset && node.parentNode.appendChild(_doc.createTextNode(" "));\n          if (tag === "span") {\n            node.style.display = "inline"; //so that word breaks are honored properly.\n          }\n          charArray.push(node);\n        }\n      } else if (node.parentNode._isSplit && !node._isSplit && node.innerHTML !== "") {\n        wordArray.push(node);\n      } else if (chars && !node._isSplit) {\n        if (tag === "span") {\n          node.style.display = "inline";\n        }\n        charArray.push(node);\n      }\n    }\n    i = spaceNodesToRemove.length;\n    while (--i > -1) {\n      spaceNodesToRemove[i].parentNode.removeChild(spaceNodesToRemove[i]);\n    }\n    if (lines) {\n      //the next 7 lines just give us the line width in the most reliable way and figure out the left offset (if position isn\'t relative or absolute). We must set the width along with text-align to ensure everything works properly for various alignments.\n      if (absolute) {\n        lineNode = _doc.createElement(tag);\n        element.appendChild(lineNode);\n        lineWidth = lineNode.offsetWidth + "px";\n        offset = lineNode.offsetParent === element ? 0 : element.offsetLeft;\n        element.removeChild(lineNode);\n      }\n      style = element.style.cssText;\n      element.style.cssText = "display:none;"; //to improve performance, set display:none on the element so that the browser doesn\'t have to worry about reflowing or rendering while we\'re renesting things. We\'ll revert the cssText later.\n      //we can\'t use element.innerHTML = "" because that causes IE to literally delete all the nodes and their content even though we\'ve stored them in an array! So we must loop through the children and remove them.\n      while (element.firstChild) {\n        element.removeChild(element.firstChild);\n      }\n      addWordSpaces = wordDelimiter === " " && (!absolute || !words && !chars);\n      for (i = 0; i < lines.length; i++) {\n        curLine = lines[i];\n        lineNode = _doc.createElement(tag);\n        lineNode.style.cssText = "display:block;text-align:" + textAlign + ";position:" + (absolute ? "absolute;" : "relative;");\n        if (linesClass) {\n          lineNode.className = linesClass + (iterateLine ? i + 1 : "");\n        }\n        lineArray.push(lineNode);\n        l = curLine.length;\n        for (j = 0; j < l; j++) {\n          if (curLine[j].nodeName !== "BR") {\n            node = curLine[j];\n            lineNode.appendChild(node);\n            addWordSpaces && node._wordEnd && lineNode.appendChild(_doc.createTextNode(" "));\n            if (absolute) {\n              if (j === 0) {\n                lineNode.style.top = node._y + "px";\n                lineNode.style.left = paddingLeft + offset + "px";\n              }\n              node.style.top = "0px";\n              if (offset) {\n                node.style.left = node._x - offset + "px";\n              }\n            }\n          }\n        }\n        if (l === 0) {\n          //if there are no nodes in the line (typically meaning there were two consecutive <br> tags, just add a non-breaking space so that things display properly.\n          lineNode.innerHTML = "&nbsp;";\n        } else if (!words && !chars) {\n          _deWordify(lineNode);\n          _swapText(lineNode, String.fromCharCode(160), " ");\n        }\n        if (absolute) {\n          lineNode.style.width = lineWidth;\n          lineNode.style.height = node._h + "px";\n        }\n        element.appendChild(lineNode);\n      }\n      element.style.cssText = style;\n    }\n\n    //if everything shifts to being position:absolute, the container can collapse in terms of height or width, so fix that here.\n    if (absolute) {\n      if (origHeight > element.clientHeight) {\n        element.style.height = origHeight - padTopAndBottom + "px";\n        if (element.clientHeight < origHeight) {\n          //IE8 and earlier use a different box model - we must include padding and borders\n          element.style.height = origHeight + borderTopAndBottom + "px";\n        }\n      }\n      if (origWidth > element.clientWidth) {\n        element.style.width = origWidth - padLeftAndRight + "px";\n        if (element.clientWidth < origWidth) {\n          //IE8 and earlier use a different box model - we must include padding and borders\n          element.style.width = origWidth + borderLeftAndRight + "px";\n        }\n      }\n    }\n    isFlex && (prevInlineDisplay ? element.style.display = prevInlineDisplay : element.style.removeProperty("display"));\n    _pushReversed(allChars, charArray);\n    words && _pushReversed(allWords, wordArray);\n    _pushReversed(allLines, lineArray);\n  },\n  _splitRawText = (element, vars, wordStart, charStart) => {\n    let tag = vars.tag ? vars.tag : vars.span ? "span" : "div",\n      types = vars.type || vars.split || "chars,words,lines",\n      //words = (types.indexOf("words") !== -1),\n      chars = ~types.indexOf("chars"),\n      absolute = _isAbsolute(vars),\n      wordDelimiter = vars.wordDelimiter || " ",\n      space = wordDelimiter !== " " ? "" : absolute ? "&#173; " : " ",\n      wordEnd = "</" + tag + ">",\n      wordIsOpen = 1,\n      specialChars = vars.specialChars ? typeof vars.specialChars === "function" ? vars.specialChars : _findSpecialChars : null,\n      //specialChars can be an array or a function. For performance reasons, we always set this local "specialChars" to a function to which we pass the remaining text and whatever the original vars.specialChars was so that if it\'s an array, it works with the _findSpecialChars() function.\n      text,\n      splitText,\n      i,\n      j,\n      l,\n      character,\n      hasTagStart,\n      testResult,\n      container = _doc.createElement("div"),\n      parent = element.parentNode;\n    parent.insertBefore(container, element);\n    container.textContent = element.nodeValue;\n    parent.removeChild(element);\n    element = container;\n    text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText)(element);\n    hasTagStart = text.indexOf("<") !== -1;\n    if (vars.reduceWhiteSpace !== false) {\n      text = text.replace(_multipleSpacesExp, " ").replace(_stripExp, "");\n    }\n    if (hasTagStart) {\n      text = text.split("<").join("{{LT}}"); //we can\'t leave "<" in the string, or when we set the innerHTML, it can be interpreted as a node\n    }\n    l = text.length;\n    splitText = (text.charAt(0) === " " ? space : "") + wordStart();\n    for (i = 0; i < l; i++) {\n      character = text.charAt(i);\n      if (specialChars && (testResult = specialChars(text.substr(i), vars.specialChars))) {\n        // look for any specialChars that were declared. Remember, they can be passed in like {specialChars:["à¤®à¥€", "à¤ªà¤¾", "à¤¹à¥ˆ"]} or a function could be defined instead. Either way, the function should return the number of characters that should be grouped together for this "character".\n        character = text.substr(i, testResult || 1);\n        splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;\n        i += testResult - 1;\n      } else if (character === wordDelimiter && text.charAt(i - 1) !== wordDelimiter && i) {\n        splitText += wordIsOpen ? wordEnd : "";\n        wordIsOpen = 0;\n        while (text.charAt(i + 1) === wordDelimiter) {\n          //skip over empty spaces (to avoid making them words)\n          splitText += space;\n          i++;\n        }\n        if (i === l - 1) {\n          splitText += space;\n        } else if (text.charAt(i + 1) !== ")") {\n          splitText += space + wordStart();\n          wordIsOpen = 1;\n        }\n      } else if (character === "{" && text.substr(i, 6) === "{{LT}}") {\n        splitText += chars ? charStart() + "{{LT}}" + "</" + tag + ">" : "{{LT}}";\n        i += 5;\n      } else if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n        //special emoji characters use 2 or 4 unicode characters that we must keep together.\n        j = ((text.substr(i, 12).split(_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiExp) || [])[1] || "").length || 2;\n        splitText += chars && character !== " " ? charStart() + text.substr(i, j) + "</" + tag + ">" : text.substr(i, j);\n        i += j - 1;\n      } else {\n        splitText += chars && character !== " " ? charStart() + character + "</" + tag + ">" : character;\n      }\n    }\n    element.outerHTML = splitText + (wordIsOpen ? wordEnd : "");\n    hasTagStart && _swapText(parent, "{{LT}}", "<"); //note: don\'t perform this on "element" because that gets replaced with all new elements when we set element.outerHTML.\n  },\n  _split = (element, vars, wordStart, charStart) => {\n    let children = _toArray(element.childNodes),\n      l = children.length,\n      absolute = _isAbsolute(vars),\n      i,\n      child;\n    if (element.nodeType !== 3 || l > 1) {\n      vars.absolute = false;\n      for (i = 0; i < l; i++) {\n        child = children[i];\n        child._next = child._isFirst = child._parent = child._wordEnd = null;\n        if (child.nodeType !== 3 || /\\S+/.test(child.nodeValue)) {\n          if (absolute && child.nodeType !== 3 && _getComputedStyle(child).display === "inline") {\n            //if there\'s a child node that\'s display:inline, switch it to inline-block so that absolute positioning works properly (most browsers don\'t report offsetTop/offsetLeft properly inside a <span> for example)\n            child.style.display = "inline-block";\n            child.style.position = "relative";\n          }\n          child._isSplit = true;\n          _split(child, vars, wordStart, charStart); //don\'t split lines on child elements\n        }\n      }\n      vars.absolute = absolute;\n      element._isSplit = true;\n      return;\n    }\n    _splitRawText(element, vars, wordStart, charStart);\n  };\nclass SplitText {\n  constructor(element, vars) {\n    _coreInitted || _initCore();\n    this.elements = _toArray(element);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this._originals = [];\n    this.vars = vars || {};\n    _bonusValidated && this.split(vars);\n  }\n  split(vars) {\n    this.isSplit && this.revert();\n    this.vars = vars = vars || this.vars;\n    this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;\n    let i = this.elements.length,\n      tag = vars.tag ? vars.tag : vars.span ? "span" : "div",\n      wordStart = _cssClassFunc(vars.wordsClass, tag),\n      charStart = _cssClassFunc(vars.charsClass, tag),\n      origHeight,\n      origWidth,\n      e;\n    //we split in reversed order so that if/when we position:absolute elements, they don\'t affect the position of the ones after them in the document flow (shifting them up as they\'re taken out of the document flow).\n    while (--i > -1) {\n      e = this.elements[i];\n      this._originals[i] = e.innerHTML;\n      origHeight = e.clientHeight;\n      origWidth = e.clientWidth;\n      _split(e, vars, wordStart, charStart);\n      _setPositionsAfterSplit(e, vars, this.chars, this.words, this.lines, origWidth, origHeight);\n    }\n    this.chars.reverse();\n    this.words.reverse();\n    this.lines.reverse();\n    this.isSplit = true;\n    return this;\n  }\n  revert() {\n    let originals = this._originals;\n    if (!originals) {\n      throw "revert() call wasn\'t scoped properly.";\n    }\n    this.elements.forEach((e, i) => e.innerHTML = originals[i]);\n    this.chars = [];\n    this.words = [];\n    this.lines = [];\n    this.isSplit = false;\n    return this;\n  }\n  static create(element, vars) {\n    return new SplitText(element, vars);\n  }\n}\nSplitText.version = "3.6.1";\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/SplitText.js?')},"./build/scripts/vendor/gsap/src/TextPlugin.js":
/*!*****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/TextPlugin.js ***!
  \*****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextPlugin: () => (/* binding */ TextPlugin),\n/* harmony export */   "default": () => (/* binding */ TextPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ "./build/scripts/vendor/gsap/src/utils/strings.js");\n/*!\n * TextPlugin 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet gsap,\n  _tempDiv,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\nconst TextPlugin = {\n  version: "3.6.1",\n  name: "text",\n  init(target, value, tween) {\n    let i = target.nodeName.toUpperCase(),\n      data = this,\n      short,\n      text,\n      original,\n      j,\n      condensedText,\n      condensedOriginal,\n      aggregate,\n      s;\n    data.svg = target.getBBox && (i === "TEXT" || i === "TSPAN");\n    if (!("innerHTML" in target) && !data.svg) {\n      return false;\n    }\n    data.target = target;\n    if (typeof value !== "object") {\n      value = {\n        value: value\n      };\n    }\n    if (!("value" in value)) {\n      data.text = data.original = [""];\n      return;\n    }\n    data.delimiter = value.delimiter || "";\n    original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(target, data.delimiter);\n    if (!_tempDiv) {\n      _tempDiv = document.createElement("div");\n    }\n    _tempDiv.innerHTML = value.value;\n    text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(_tempDiv, data.delimiter);\n    data.from = tween._from;\n    if (data.from) {\n      i = original;\n      original = text;\n      text = i;\n    }\n    data.hasClass = !!(value.newClass || value.oldClass);\n    data.newClass = value.newClass;\n    data.oldClass = value.oldClass;\n    i = original.length - text.length;\n    short = i < 0 ? original : text;\n    data.fillChar = value.fillChar || (value.padSpace ? "&nbsp;" : "");\n    if (i < 0) {\n      i = -i;\n    }\n    while (--i > -1) {\n      short.push(data.fillChar);\n    }\n    if (value.type === "diff") {\n      j = 0;\n      condensedText = [];\n      condensedOriginal = [];\n      aggregate = "";\n      for (i = 0; i < text.length; i++) {\n        s = text[i];\n        if (s === original[i]) {\n          aggregate += s;\n        } else {\n          condensedText[j] = aggregate + s;\n          condensedOriginal[j++] = aggregate + original[i];\n          aggregate = "";\n        }\n      }\n      text = condensedText;\n      original = condensedOriginal;\n      if (aggregate) {\n        text.push(aggregate);\n        original.push(aggregate);\n      }\n    }\n    if (value.speed) {\n      tween.duration(Math.min(0.05 / value.speed * short.length, value.maxDuration || 9999));\n    }\n    this.original = original;\n    this.text = text;\n    this._props.push("text");\n  },\n  render(ratio, data) {\n    if (ratio > 1) {\n      ratio = 1;\n    } else if (ratio < 0) {\n      ratio = 0;\n    }\n    if (data.from) {\n      ratio = 1 - ratio;\n    }\n    let {\n        text,\n        hasClass,\n        newClass,\n        oldClass,\n        delimiter,\n        target,\n        fillChar,\n        original\n      } = data,\n      l = text.length,\n      i = ratio * l + 0.5 | 0,\n      applyNew,\n      applyOld,\n      str;\n    if (hasClass) {\n      applyNew = newClass && i;\n      applyOld = oldClass && i !== l;\n      str = (applyNew ? "<span class=\'" + newClass + "\'>" : "") + text.slice(0, i).join(delimiter) + (applyNew ? "</span>" : "") + (applyOld ? "<span class=\'" + oldClass + "\'>" : "") + delimiter + original.slice(i).join(delimiter) + (applyOld ? "</span>" : "");\n    } else {\n      str = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);\n    }\n    if (data.svg) {\n      //SVG text elements don\'t have an "innerHTML" in Microsoft browsers.\n      target.textContent = str;\n    } else {\n      target.innerHTML = fillChar === "&nbsp;" && ~str.indexOf("  ") ? str.split("  ").join("&nbsp;&nbsp;") : str;\n    }\n  }\n};\nTextPlugin.splitInnerHTML = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML;\nTextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;\nTextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;\n_getGSAP() && gsap.registerPlugin(TextPlugin);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/TextPlugin.js?')},"./build/scripts/vendor/gsap/src/all.js":
/*!**********************************************!*\
  !*** ./build/scripts/vendor/gsap/src/all.js ***!
  \**********************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Back: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),\n/* harmony export */   Bounce: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),\n/* harmony export */   CSSPlugin: () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]),\n/* harmony export */   CSSRulePlugin: () => (/* reexport safe */ _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_3__.CSSRulePlugin),\n/* harmony export */   Circ: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),\n/* harmony export */   Cubic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),\n/* harmony export */   CustomBounce: () => (/* reexport safe */ _CustomBounce_js__WEBPACK_IMPORTED_MODULE_16__.CustomBounce),\n/* harmony export */   CustomEase: () => (/* reexport safe */ _CustomEase_js__WEBPACK_IMPORTED_MODULE_11__.CustomEase),\n/* harmony export */   CustomWiggle: () => (/* reexport safe */ _CustomWiggle_js__WEBPACK_IMPORTED_MODULE_17__.CustomWiggle),\n/* harmony export */   Draggable: () => (/* reexport safe */ _Draggable_js__WEBPACK_IMPORTED_MODULE_2__.Draggable),\n/* harmony export */   DrawSVGPlugin: () => (/* reexport safe */ _DrawSVGPlugin_js__WEBPACK_IMPORTED_MODULE_12__.DrawSVGPlugin),\n/* harmony export */   EasePack: () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_5__.EasePack),\n/* harmony export */   EaselPlugin: () => (/* reexport safe */ _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_4__.EaselPlugin),\n/* harmony export */   Elastic: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),\n/* harmony export */   Expo: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),\n/* harmony export */   ExpoScaleEase: () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_5__.ExpoScaleEase),\n/* harmony export */   Flip: () => (/* reexport safe */ _Flip_js__WEBPACK_IMPORTED_MODULE_18__.Flip),\n/* harmony export */   GSDevTools: () => (/* reexport safe */ _GSDevTools_js__WEBPACK_IMPORTED_MODULE_19__.GSDevTools),\n/* harmony export */   InertiaPlugin: () => (/* reexport safe */ _InertiaPlugin_js__WEBPACK_IMPORTED_MODULE_20__.InertiaPlugin),\n/* harmony export */   Linear: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),\n/* harmony export */   MorphSVGPlugin: () => (/* reexport safe */ _MorphSVGPlugin_js__WEBPACK_IMPORTED_MODULE_21__.MorphSVGPlugin),\n/* harmony export */   MotionPathHelper: () => (/* reexport safe */ _MotionPathHelper_js__WEBPACK_IMPORTED_MODULE_22__.MotionPathHelper),\n/* harmony export */   MotionPathPlugin: () => (/* reexport safe */ _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_6__.MotionPathPlugin),\n/* harmony export */   Physics2DPlugin: () => (/* reexport safe */ _Physics2DPlugin_js__WEBPACK_IMPORTED_MODULE_13__.Physics2DPlugin),\n/* harmony export */   PhysicsPropsPlugin: () => (/* reexport safe */ _PhysicsPropsPlugin_js__WEBPACK_IMPORTED_MODULE_14__.PhysicsPropsPlugin),\n/* harmony export */   PixiPlugin: () => (/* reexport safe */ _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_7__.PixiPlugin),\n/* harmony export */   Power0: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),\n/* harmony export */   Power1: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),\n/* harmony export */   Power2: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),\n/* harmony export */   Power3: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),\n/* harmony export */   Power4: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),\n/* harmony export */   Quad: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),\n/* harmony export */   Quart: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),\n/* harmony export */   Quint: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),\n/* harmony export */   RoughEase: () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_5__.RoughEase),\n/* harmony export */   ScrambleTextPlugin: () => (/* reexport safe */ _ScrambleTextPlugin_js__WEBPACK_IMPORTED_MODULE_15__.ScrambleTextPlugin),\n/* harmony export */   ScrollToPlugin: () => (/* reexport safe */ _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_8__.ScrollToPlugin),\n/* harmony export */   ScrollTrigger: () => (/* reexport safe */ _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_9__.ScrollTrigger),\n/* harmony export */   Sine: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),\n/* harmony export */   SlowMo: () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_5__.SlowMo),\n/* harmony export */   SplitText: () => (/* reexport safe */ _SplitText_js__WEBPACK_IMPORTED_MODULE_23__.SplitText),\n/* harmony export */   SteppedEase: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),\n/* harmony export */   Strong: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),\n/* harmony export */   TextPlugin: () => (/* reexport safe */ _TextPlugin_js__WEBPACK_IMPORTED_MODULE_10__.TextPlugin),\n/* harmony export */   TimelineLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),\n/* harmony export */   TimelineMax: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),\n/* harmony export */   TweenLite: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),\n/* harmony export */   TweenMax: () => (/* binding */ TweenMaxWithCSS),\n/* harmony export */   VelocityTracker: () => (/* reexport safe */ _InertiaPlugin_js__WEBPACK_IMPORTED_MODULE_20__.VelocityTracker),\n/* harmony export */   clamp: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.clamp),\n/* harmony export */   "default": () => (/* binding */ gsapWithCSS),\n/* harmony export */   distribute: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.distribute),\n/* harmony export */   getUnit: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit),\n/* harmony export */   gsap: () => (/* binding */ gsapWithCSS),\n/* harmony export */   interpolate: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.interpolate),\n/* harmony export */   mapRange: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.mapRange),\n/* harmony export */   normalize: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.normalize),\n/* harmony export */   pipe: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.pipe),\n/* harmony export */   random: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.random),\n/* harmony export */   shuffle: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.shuffle),\n/* harmony export */   snap: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.snap),\n/* harmony export */   splitColor: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.splitColor),\n/* harmony export */   toArray: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.toArray),\n/* harmony export */   unitize: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.unitize),\n/* harmony export */   wrap: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrap),\n/* harmony export */   wrapYoyo: () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrapYoyo)\n/* harmony export */ });\n/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./build/scripts/vendor/gsap/src/gsap-core.js");\n/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./build/scripts/vendor/gsap/src/CSSPlugin.js");\n/* harmony import */ var _Draggable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Draggable.js */ "./build/scripts/vendor/gsap/src/Draggable.js");\n/* harmony import */ var _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CSSRulePlugin.js */ "./build/scripts/vendor/gsap/src/CSSRulePlugin.js");\n/* harmony import */ var _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EaselPlugin.js */ "./build/scripts/vendor/gsap/src/EaselPlugin.js");\n/* harmony import */ var _EasePack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EasePack.js */ "./build/scripts/vendor/gsap/src/EasePack.js");\n/* harmony import */ var _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MotionPathPlugin.js */ "./build/scripts/vendor/gsap/src/MotionPathPlugin.js");\n/* harmony import */ var _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PixiPlugin.js */ "./build/scripts/vendor/gsap/src/PixiPlugin.js");\n/* harmony import */ var _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ScrollToPlugin.js */ "./build/scripts/vendor/gsap/src/ScrollToPlugin.js");\n/* harmony import */ var _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ScrollTrigger.js */ "./build/scripts/vendor/gsap/src/ScrollTrigger.js");\n/* harmony import */ var _TextPlugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextPlugin.js */ "./build/scripts/vendor/gsap/src/TextPlugin.js");\n/* harmony import */ var _CustomEase_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./CustomEase.js */ "./build/scripts/vendor/gsap/src/CustomEase.js");\n/* harmony import */ var _DrawSVGPlugin_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DrawSVGPlugin.js */ "./build/scripts/vendor/gsap/src/DrawSVGPlugin.js");\n/* harmony import */ var _Physics2DPlugin_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Physics2DPlugin.js */ "./build/scripts/vendor/gsap/src/Physics2DPlugin.js");\n/* harmony import */ var _PhysicsPropsPlugin_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./PhysicsPropsPlugin.js */ "./build/scripts/vendor/gsap/src/PhysicsPropsPlugin.js");\n/* harmony import */ var _ScrambleTextPlugin_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ScrambleTextPlugin.js */ "./build/scripts/vendor/gsap/src/ScrambleTextPlugin.js");\n/* harmony import */ var _CustomBounce_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./CustomBounce.js */ "./build/scripts/vendor/gsap/src/CustomBounce.js");\n/* harmony import */ var _CustomWiggle_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./CustomWiggle.js */ "./build/scripts/vendor/gsap/src/CustomWiggle.js");\n/* harmony import */ var _Flip_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Flip.js */ "./build/scripts/vendor/gsap/src/Flip.js");\n/* harmony import */ var _GSDevTools_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./GSDevTools.js */ "./build/scripts/vendor/gsap/src/GSDevTools.js");\n/* harmony import */ var _InertiaPlugin_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./InertiaPlugin.js */ "./build/scripts/vendor/gsap/src/InertiaPlugin.js");\n/* harmony import */ var _MorphSVGPlugin_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./MorphSVGPlugin.js */ "./build/scripts/vendor/gsap/src/MorphSVGPlugin.js");\n/* harmony import */ var _MotionPathHelper_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./MotionPathHelper.js */ "./build/scripts/vendor/gsap/src/MotionPathHelper.js");\n/* harmony import */ var _SplitText_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./SplitText.js */ "./build/scripts/vendor/gsap/src/SplitText.js");\n\n\nconst gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["default"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["default"],\n  // to protect from tree shaking\n  TweenMaxWithCSS = gsapWithCSS.core.Tween;\n\n\n\n\n\n\n\n\n\n\n\n\n//BONUS EXPORTS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/all.js?')},"./build/scripts/vendor/gsap/src/gsap-core.js":
/*!****************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/gsap-core.js ***!
  \****************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   Back: () => (/* binding */ Back),\n/* harmony export */   Bounce: () => (/* binding */ Bounce),\n/* harmony export */   Circ: () => (/* binding */ Circ),\n/* harmony export */   Cubic: () => (/* binding */ Cubic),\n/* harmony export */   Elastic: () => (/* binding */ Elastic),\n/* harmony export */   Expo: () => (/* binding */ Expo),\n/* harmony export */   GSCache: () => (/* binding */ GSCache),\n/* harmony export */   Linear: () => (/* binding */ Linear),\n/* harmony export */   Power0: () => (/* binding */ Power0),\n/* harmony export */   Power1: () => (/* binding */ Power1),\n/* harmony export */   Power2: () => (/* binding */ Power2),\n/* harmony export */   Power3: () => (/* binding */ Power3),\n/* harmony export */   Power4: () => (/* binding */ Power4),\n/* harmony export */   PropTween: () => (/* binding */ PropTween),\n/* harmony export */   Quad: () => (/* binding */ Quad),\n/* harmony export */   Quart: () => (/* binding */ Quart),\n/* harmony export */   Quint: () => (/* binding */ Quint),\n/* harmony export */   Sine: () => (/* binding */ Sine),\n/* harmony export */   SteppedEase: () => (/* binding */ SteppedEase),\n/* harmony export */   Strong: () => (/* binding */ Strong),\n/* harmony export */   Timeline: () => (/* binding */ Timeline),\n/* harmony export */   TimelineLite: () => (/* binding */ Timeline),\n/* harmony export */   TimelineMax: () => (/* binding */ Timeline),\n/* harmony export */   Tween: () => (/* binding */ Tween),\n/* harmony export */   TweenLite: () => (/* binding */ Tween),\n/* harmony export */   TweenMax: () => (/* binding */ Tween),\n/* harmony export */   _checkPlugin: () => (/* binding */ _checkPlugin),\n/* harmony export */   _colorExp: () => (/* binding */ _colorExp),\n/* harmony export */   _colorStringFilter: () => (/* binding */ _colorStringFilter),\n/* harmony export */   _config: () => (/* binding */ _config),\n/* harmony export */   _forEachName: () => (/* binding */ _forEachName),\n/* harmony export */   _getCache: () => (/* binding */ _getCache),\n/* harmony export */   _getProperty: () => (/* binding */ _getProperty),\n/* harmony export */   _getSetter: () => (/* binding */ _getSetter),\n/* harmony export */   _isString: () => (/* binding */ _isString),\n/* harmony export */   _isUndefined: () => (/* binding */ _isUndefined),\n/* harmony export */   _missingPlugin: () => (/* binding */ _missingPlugin),\n/* harmony export */   _numExp: () => (/* binding */ _numExp),\n/* harmony export */   _numWithUnitExp: () => (/* binding */ _numWithUnitExp),\n/* harmony export */   _plugins: () => (/* binding */ _plugins),\n/* harmony export */   _relExp: () => (/* binding */ _relExp),\n/* harmony export */   _removeLinkedListItem: () => (/* binding */ _removeLinkedListItem),\n/* harmony export */   _renderComplexString: () => (/* binding */ _renderComplexString),\n/* harmony export */   _replaceRandom: () => (/* binding */ _replaceRandom),\n/* harmony export */   _round: () => (/* binding */ _round),\n/* harmony export */   _roundModifier: () => (/* binding */ _roundModifier),\n/* harmony export */   _setDefaults: () => (/* binding */ _setDefaults),\n/* harmony export */   _sortPropTweensByPriority: () => (/* binding */ _sortPropTweensByPriority),\n/* harmony export */   _ticker: () => (/* binding */ _ticker),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   "default": () => (/* binding */ gsap),\n/* harmony export */   distribute: () => (/* binding */ distribute),\n/* harmony export */   getUnit: () => (/* binding */ getUnit),\n/* harmony export */   gsap: () => (/* binding */ gsap),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   mapRange: () => (/* binding */ mapRange),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   snap: () => (/* binding */ snap),\n/* harmony export */   splitColor: () => (/* binding */ splitColor),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   unitize: () => (/* binding */ unitize),\n/* harmony export */   wrap: () => (/* binding */ wrap),\n/* harmony export */   wrapYoyo: () => (/* binding */ wrapYoyo)\n/* harmony export */ });\n/*!\n * GSAP 3.6.1\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet _config = {\n    autoSleep: 120,\n    force3D: "auto",\n    nullTargetWarn: 1,\n    units: {\n      lineHeight: ""\n    }\n  },\n  _defaults = {\n    duration: .5,\n    overwrite: false,\n    delay: 0\n  },\n  _suppressOverwrites,\n  _bigNum = 1e8,\n  _tinyNum = 1 / _bigNum,\n  _2PI = Math.PI * 2,\n  _HALF_PI = _2PI / 4,\n  _gsID = 0,\n  _sqrt = Math.sqrt,\n  _cos = Math.cos,\n  _sin = Math.sin,\n  _isString = value => typeof value === "string",\n  _isFunction = value => typeof value === "function",\n  _isNumber = value => typeof value === "number",\n  _isUndefined = value => typeof value === "undefined",\n  _isObject = value => typeof value === "object",\n  _isNotFalse = value => value !== false,\n  _windowExists = () => typeof window !== "undefined",\n  _isFuncOrString = value => _isFunction(value) || _isString(value),\n  _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},\n  // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n  _isArray = Array.isArray,\n  _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi,\n  //only numbers (including negatives and decimals) but NOT relative values.\n  _numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g,\n  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n  _numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g,\n  _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi,\n  //duplicate so that while we\'re looping through matches from exec(), it doesn\'t contaminate the lastIndex of _numExp which we use to search for colors too.\n  _relExp = /[+-]=-?[.\\d]+/,\n  _delimitedValueExp = /[#\\-+.]*\\b[a-z\\d-=+%.]+/gi,\n  _unitExp = /[\\d.+\\-=]+(?:e[-+]\\d*)*/i,\n  _globalTimeline,\n  _win,\n  _coreInitted,\n  _doc,\n  _globals = {},\n  _installScope = {},\n  _coreReady,\n  _install = scope => (_installScope = _merge(scope, _globals)) && gsap,\n  _missingPlugin = (property, value) => console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()"),\n  _warn = (message, suppress) => !suppress && console.warn(message),\n  _addGlobal = (name, obj) => name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals,\n  _emptyFunc = () => 0,\n  _reservedProps = {},\n  _lazyTweens = [],\n  _lazyLookup = {},\n  _lastRenderedFrame,\n  _plugins = {},\n  _effects = {},\n  _nextGCFrame = 30,\n  _harnessPlugins = [],\n  _callbackNames = "",\n  _harness = targets => {\n    let target = targets[0],\n      harnessPlugin,\n      i;\n    _isObject(target) || _isFunction(target) || (targets = [targets]);\n    if (!(harnessPlugin = (target._gsap || {}).harness)) {\n      // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n      i = _harnessPlugins.length;\n      while (i-- && !_harnessPlugins[i].targetTest(target)) {}\n      harnessPlugin = _harnessPlugins[i];\n    }\n    i = targets.length;\n    while (i--) {\n      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n    }\n    return targets;\n  },\n  _getCache = target => target._gsap || _harness(toArray(target))[0]._gsap,\n  _getProperty = (target, property, v) => (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v,\n  _forEachName = (names, func) => (names = names.split(",")).forEach(func) || names,\n  //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n  _round = value => Math.round(value * 100000) / 100000 || 0,\n  _arrayContainsAny = (toSearch, toFind) => {\n    //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it\'s simply a boolean search.\n    let l = toFind.length,\n      i = 0;\n    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}\n    return i < l;\n  },\n  _parseVars = (params, type, parent) => {\n    //reads the arguments passed to one of the key methods and figures out if the user is defining things with the OLD/legacy syntax where the duration is the 2nd parameter, and then it adjusts things accordingly and spits back the corrected vars object (with the duration added if necessary, as well as runBackwards or startAt or immediateRender). type 0 = to()/staggerTo(), 1 = from()/staggerFrom(), 2 = fromTo()/staggerFromTo()\n    let isLegacy = _isNumber(params[1]),\n      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),\n      vars = params[varsIndex],\n      irVars;\n    isLegacy && (vars.duration = params[1]);\n    vars.parent = parent;\n    if (type) {\n      irVars = vars;\n      while (parent && !("immediateRender" in irVars)) {\n        // inheritance hasn\'t happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that\'d exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We\'re paying a small kb price here to gain speed.\n        irVars = parent.vars.defaults || {};\n        parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n      }\n      vars.immediateRender = _isNotFalse(irVars.immediateRender);\n      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars\n    }\n    return vars;\n  },\n  _lazyRender = () => {\n    let l = _lazyTweens.length,\n      a = _lazyTweens.slice(0),\n      i,\n      tween;\n    _lazyLookup = {};\n    _lazyTweens.length = 0;\n    for (i = 0; i < l; i++) {\n      tween = a[i];\n      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n    }\n  },\n  _lazySafeRender = (animation, time, suppressEvents, force) => {\n    _lazyTweens.length && _lazyRender();\n    animation.render(time, suppressEvents, force);\n    _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n  },\n  _numericIfPossible = value => {\n    let n = parseFloat(value);\n    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n  },\n  _passThrough = p => p,\n  _setDefaults = (obj, defaults) => {\n    for (let p in defaults) {\n      p in obj || (obj[p] = defaults[p]);\n    }\n    return obj;\n  },\n  _setKeyframeDefaults = (obj, defaults) => {\n    for (let p in defaults) {\n      p in obj || p === "duration" || p === "ease" || (obj[p] = defaults[p]);\n    }\n  },\n  _merge = (base, toMerge) => {\n    for (let p in toMerge) {\n      base[p] = toMerge[p];\n    }\n    return base;\n  },\n  _mergeDeep = (base, toMerge) => {\n    for (let p in toMerge) {\n      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n    }\n    return base;\n  },\n  _copyExcluding = (obj, excluding) => {\n    let copy = {},\n      p;\n    for (p in obj) {\n      p in excluding || (copy[p] = obj[p]);\n    }\n    return copy;\n  },\n  _inheritDefaults = vars => {\n    let parent = vars.parent || _globalTimeline,\n      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;\n    if (_isNotFalse(vars.inherit)) {\n      while (parent) {\n        func(vars, parent.vars.defaults);\n        parent = parent.parent || parent._dp;\n      }\n    }\n    return vars;\n  },\n  _arraysMatch = (a1, a2) => {\n    let i = a1.length,\n      match = i === a2.length;\n    while (match && i-- && a1[i] === a2[i]) {}\n    return i < 0;\n  },\n  _addLinkedListItem = function (parent, child) {\n    let firstProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "_first";\n    let lastProp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "_last";\n    let sortBy = arguments.length > 4 ? arguments[4] : undefined;\n    let prev = parent[lastProp],\n      t;\n    if (sortBy) {\n      t = child[sortBy];\n      while (prev && prev[sortBy] > t) {\n        prev = prev._prev;\n      }\n    }\n    if (prev) {\n      child._next = prev._next;\n      prev._next = child;\n    } else {\n      child._next = parent[firstProp];\n      parent[firstProp] = child;\n    }\n    if (child._next) {\n      child._next._prev = child;\n    } else {\n      parent[lastProp] = child;\n    }\n    child._prev = prev;\n    child.parent = child._dp = parent;\n    return child;\n  },\n  _removeLinkedListItem = function (parent, child) {\n    let firstProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "_first";\n    let lastProp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "_last";\n    let prev = child._prev,\n      next = child._next;\n    if (prev) {\n      prev._next = next;\n    } else if (parent[firstProp] === child) {\n      parent[firstProp] = next;\n    }\n    if (next) {\n      next._prev = prev;\n    } else if (parent[lastProp] === child) {\n      parent[lastProp] = prev;\n    }\n    child._next = child._prev = child.parent = null; // don\'t delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn\'t in a linked list.\n  },\n  _removeFromParent = (child, onlyIfParentHasAutoRemove) => {\n    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);\n    child._act = 0;\n  },\n  _uncache = (animation, child) => {\n    if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n      // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n      let a = animation;\n      while (a) {\n        a._dirty = 1;\n        a = a.parent;\n      }\n    }\n    return animation;\n  },\n  _recacheAncestors = animation => {\n    let parent = animation.parent;\n    while (parent && parent.parent) {\n      //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween\'s timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween\'s render (startTime). Doesn\'t matter for the root timeline though.\n      parent._dirty = 1;\n      parent.totalDuration();\n      parent = parent.parent;\n    }\n    return animation;\n  },\n  _hasNoPausedAncestors = animation => !animation || animation._ts && _hasNoPausedAncestors(animation.parent),\n  _elapsedCycleDuration = animation => animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0,\n  // feed in the totalTime and cycleDuration and it\'ll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n  _animationCycle = (tTime, cycleDuration) => {\n    let whole = Math.floor(tTime /= cycleDuration);\n    return tTime && whole === tTime ? whole - 1 : whole;\n  },\n  _parentToChildTotalTime = (parentTime, child) => (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur),\n  _setEnd = animation => animation._end = _round(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0)),\n  _alignPlayhead = (animation, totalTime) => {\n    // adjusts the animation\'s _start and _end according to the provided totalTime (only if the parent\'s smoothChildTiming is true and the animation isn\'t paused). It doesn\'t do any rendering or forcing things back into parent timelines, etc. - that\'s what totalTime() is for.\n    let parent = animation._dp;\n    if (parent && parent.smoothChildTiming && animation._ts) {\n      animation._start = _round(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n      _setEnd(animation);\n      parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent\'s cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n    }\n    return animation;\n  },\n  /*\n  _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n  \tlet cycleDuration = duration + repeatDelay,\n  \t\ttime = _round(clampedTotalTime % cycleDuration);\n  \tif (time > duration) {\n  \t\ttime = duration;\n  \t}\n  \treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n  },\n  */\n  _postAddChecks = (timeline, child) => {\n    let t;\n    if (child._time || child._initted && !child._dur) {\n      //in case, for example, the _start is moved on a tween that has already rendered. Imagine it\'s at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.\n      t = _parentToChildTotalTime(timeline.rawTime(), child);\n      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n        child.render(t, true);\n      }\n    }\n    //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline\'s when appropriate.\n    if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n      //in case any of the ancestors had completed but should now be enabled...\n      if (timeline._dur < timeline.duration()) {\n        t = timeline;\n        while (t._dp) {\n          t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it\'s currently zero, though, it may not be scheduled to render until later so there\'s no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n          t = t._dp;\n        }\n      }\n      timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn\'t changed (we\'re adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn\'t want things to get triggered in the wrong order.\n    }\n  },\n  _addToTimeline = (timeline, child, position, skipChecks) => {\n    child.parent && _removeFromParent(child);\n    child._start = _round(position + child._delay);\n    child._end = _round(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n    _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);\n    timeline._recent = child;\n    skipChecks || _postAddChecks(timeline, child);\n    return timeline;\n  },\n  _scrollTrigger = (animation, trigger) => (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation),\n  _attemptInitTween = (tween, totalTime, force, suppressEvents) => {\n    _initTween(tween, totalTime);\n    if (!tween._initted) {\n      return 1;\n    }\n    if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n      _lazyTweens.push(tween);\n      tween._lazy = [totalTime, suppressEvents];\n      return 1;\n    }\n  },\n  _parentPlayheadIsBeforeStart = _ref => {\n    let {\n      parent\n    } = _ref;\n    return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n  },\n  // check parent\'s _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn\'t force the ratio back to 0\n  _renderZeroDurationTween = (tween, totalTime, suppressEvents, force) => {\n    let prevRatio = tween.ratio,\n      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) || (tween._ts < 0 || tween._dp._ts < 0) && tween.data !== "isFromStart" && tween.data !== "isStart") ? 0 : 1,\n      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0.\n      repeatDelay = tween._rDelay,\n      tTime = 0,\n      pt,\n      iteration,\n      prevIteration;\n    if (repeatDelay && tween._repeat) {\n      // in case there\'s a zero-duration tween that has a repeat with a repeatDelay\n      tTime = _clamp(0, tween._tDur, totalTime);\n      iteration = _animationCycle(tTime, repeatDelay);\n      prevIteration = _animationCycle(tween._tTime, repeatDelay);\n      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n      if (iteration !== prevIteration) {\n        prevRatio = 1 - ratio;\n        tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n      }\n    }\n    if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {\n        // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn\'t need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n        return;\n      }\n      prevIteration = tween._zTime;\n      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it\'ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there\'s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n      suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON\'T fire callbacks otherwise they\'ll seem like duplicates.\n      tween.ratio = ratio;\n      tween._from && (ratio = 1 - ratio);\n      tween._time = 0;\n      tween._tTime = tTime;\n      pt = tween._pt;\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n      tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);\n      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");\n      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");\n      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n        ratio && _removeFromParent(tween, 1);\n        if (!suppressEvents) {\n          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);\n          tween._prom && tween._prom();\n        }\n      }\n    } else if (!tween._zTime) {\n      tween._zTime = totalTime;\n    }\n  },\n  _findNextPauseTween = (animation, prevTime, time) => {\n    let child;\n    if (time > prevTime) {\n      child = animation._first;\n      while (child && child._start <= time) {\n        if (!child._dur && child.data === "isPause" && child._start > prevTime) {\n          return child;\n        }\n        child = child._next;\n      }\n    } else {\n      child = animation._last;\n      while (child && child._start >= time) {\n        if (!child._dur && child.data === "isPause" && child._start < prevTime) {\n          return child;\n        }\n        child = child._prev;\n      }\n    }\n  },\n  _setDuration = (animation, duration, skipUncache, leavePlayhead) => {\n    let repeat = animation._repeat,\n      dur = _round(duration) || 0,\n      totalProgress = animation._tTime / animation._tDur;\n    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n    animation._dur = dur;\n    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _round(dur * (repeat + 1) + animation._rDelay * repeat);\n    totalProgress && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);\n    skipUncache || _uncache(animation.parent, animation);\n    return animation;\n  },\n  _onUpdateTotalDuration = animation => animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur),\n  _zeroPosition = {\n    _start: 0,\n    endTime: _emptyFunc\n  },\n  _parsePosition = (animation, position) => {\n    let labels = animation.labels,\n      recent = animation._recent || _zeroPosition,\n      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\n      //in case there\'s a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child\'s endTime should be used instead.\n      i,\n      offset;\n    if (_isString(position) && (isNaN(position) || position in labels)) {\n      //if the string is a number like "1", check to see if there\'s a label with that name, otherwise interpret it as a number (absolute value).\n      i = position.charAt(0);\n      if (i === "<" || i === ">") {\n        return (i === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0);\n      }\n      i = position.indexOf("=");\n      if (i < 0) {\n        position in labels || (labels[position] = clippedDuration);\n        return labels[position];\n      }\n      offset = +(position.charAt(i - 1) + position.substr(i + 1));\n      return i > 1 ? _parsePosition(animation, position.substr(0, i - 1)) + offset : clippedDuration + offset;\n    }\n    return position == null ? clippedDuration : +position;\n  },\n  _conditionalReturn = (value, func) => value || value === 0 ? func(value) : func,\n  _clamp = (min, max, value) => value < min ? min : value > max ? max : value,\n  getUnit = value => {\n    if (typeof value !== "string") {\n      return "";\n    }\n    let v = _unitExp.exec(value);\n    return v ? value.substr(v.index + v[0].length) : "";\n  },\n  // note: protect against padded numbers as strings, like "100.100". That shouldn\'t return "00" as the unit. If it\'s numeric, return no unit.\n  clamp = (min, max, value) => _conditionalReturn(value, v => _clamp(min, max, v)),\n  _slice = [].slice,\n  _isArrayLike = (value, nonEmpty) => value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win,\n  _flatten = function (ar, leaveStrings) {\n    let accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    return ar.forEach(value => _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? accumulator.push(...toArray(value)) : accumulator.push(value)) || accumulator;\n  },\n  //takes any value and returns an array. If it\'s a string (and leaveStrings isn\'t true), it\'ll use document.querySelectorAll() and convert that to an array. It\'ll also accept iterables like jQuery objects.\n  toArray = (value, leaveStrings) => _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call(_doc.querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [],\n  shuffle = a => a.sort(() => .5 - Math.random()),\n  // alternative that\'s a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;\n  //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\n  distribute = v => {\n    if (_isFunction(v)) {\n      return v;\n    }\n    let vars = _isObject(v) ? v : {\n        each: v\n      },\n      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that\'s chunked out among them all.\n      ease = _parseEase(vars.ease),\n      from = vars.from || 0,\n      base = parseFloat(vars.base) || 0,\n      cache = {},\n      isDecimal = from > 0 && from < 1,\n      ratios = isNaN(from) || isDecimal,\n      axis = vars.axis,\n      ratioX = from,\n      ratioY = from;\n    if (_isString(from)) {\n      ratioX = ratioY = {\n        center: .5,\n        edges: .5,\n        end: 1\n      }[from] || 0;\n    } else if (!isDecimal && ratios) {\n      ratioX = from[0];\n      ratioY = from[1];\n    }\n    return (i, target, a) => {\n      let l = (a || vars).length,\n        distances = cache[l],\n        originX,\n        originY,\n        x,\n        y,\n        d,\n        j,\n        max,\n        min,\n        wrapAt;\n      if (!distances) {\n        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];\n        if (!wrapAt) {\n          max = -_bigNum;\n          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}\n          wrapAt--;\n        }\n        distances = cache[l] = [];\n        originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n        originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n        max = 0;\n        min = _bigNum;\n        for (j = 0; j < l; j++) {\n          x = j % wrapAt - originX;\n          y = originY - (j / wrapAt | 0);\n          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);\n          d > max && (max = d);\n          d < min && (min = d);\n        }\n        from === "random" && shuffle(distances);\n        distances.max = max - min;\n        distances.min = min;\n        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);\n        distances.b = l < 0 ? base - l : base;\n        distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n        ease = ease && l < 0 ? _invertEase(ease) : ease;\n      }\n      l = (distances[i] - distances.min) / distances.max || 0;\n      return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n    };\n  },\n  _roundModifier = v => {\n    //pass in 0.1 get a function that\'ll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n    let p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()\n    return raw => {\n      let n = Math.round(parseFloat(raw) / v) * v * p;\n      return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n    };\n  },\n  snap = (snapTo, value) => {\n    let isArray = _isArray(snapTo),\n      radius,\n      is2D;\n    if (!isArray && _isObject(snapTo)) {\n      radius = isArray = snapTo.radius || _bigNum;\n      if (snapTo.values) {\n        snapTo = toArray(snapTo.values);\n        if (is2D = !_isNumber(snapTo[0])) {\n          radius *= radius; //performance optimization so we don\'t have to Math.sqrt() in the loop.\n        }\n      } else {\n        snapTo = _roundModifier(snapTo.increment);\n      }\n    }\n    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? raw => {\n      is2D = snapTo(raw);\n      return Math.abs(is2D - raw) <= radius ? is2D : raw;\n    } : raw => {\n      let x = parseFloat(is2D ? raw.x : raw),\n        y = parseFloat(is2D ? raw.y : 0),\n        min = _bigNum,\n        closest = 0,\n        i = snapTo.length,\n        dx,\n        dy;\n      while (i--) {\n        if (is2D) {\n          dx = snapTo[i].x - x;\n          dy = snapTo[i].y - y;\n          dx = dx * dx + dy * dy;\n        } else {\n          dx = Math.abs(snapTo[i] - x);\n        }\n        if (dx < min) {\n          min = dx;\n          closest = i;\n        }\n      }\n      closest = !radius || min <= radius ? snapTo[closest] : raw;\n      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n    });\n  },\n  random = (min, max, roundingIncrement, returnFunction) => _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, () => _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? 10 ** ((roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction),\n  pipe = function () {\n    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\n      functions[_key] = arguments[_key];\n    }\n    return value => functions.reduce((v, f) => f(v), value);\n  },\n  unitize = (func, unit) => value => func(parseFloat(value)) + (unit || getUnit(value)),\n  normalize = (min, max, value) => mapRange(min, max, 0, 1, value),\n  _wrapArray = (a, wrapper, value) => _conditionalReturn(value, index => a[~~wrapper(index)]),\n  wrap = function (min, max, value) {\n    // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n    let range = max - min;\n    return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, value => (range + (value - min) % range) % range + min);\n  },\n  wrapYoyo = (min, max, value) => {\n    let range = max - min,\n      total = range * 2;\n    return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, value => {\n      value = (total + (value - min) % total) % total || 0;\n      return min + (value > range ? total - value : value);\n    });\n  },\n  _replaceRandom = value => {\n    //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n    let prev = 0,\n      s = "",\n      i,\n      nums,\n      end,\n      isArray;\n    while (~(i = value.indexOf("random(", prev))) {\n      end = value.indexOf(")", i);\n      isArray = value.charAt(i + 7) === "[";\n      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n      prev = end + 1;\n    }\n    return s + value.substr(prev, value.length - prev);\n  },\n  mapRange = (inMin, inMax, outMin, outMax, value) => {\n    let inRange = inMax - inMin,\n      outRange = outMax - outMin;\n    return _conditionalReturn(value, value => outMin + ((value - inMin) / inRange * outRange || 0));\n  },\n  interpolate = (start, end, progress, mutate) => {\n    let func = isNaN(start + end) ? 0 : p => (1 - p) * start + p * end;\n    if (!func) {\n      let isString = _isString(start),\n        master = {},\n        p,\n        i,\n        interpolators,\n        l,\n        il;\n      progress === true && (mutate = 1) && (progress = null);\n      if (isString) {\n        start = {\n          p: start\n        };\n        end = {\n          p: end\n        };\n      } else if (_isArray(start) && !_isArray(end)) {\n        interpolators = [];\n        l = start.length;\n        il = l - 2;\n        for (i = 1; i < l; i++) {\n          interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n        }\n        l--;\n        func = p => {\n          p *= l;\n          let i = Math.min(il, ~~p);\n          return interpolators[i](p - i);\n        };\n        progress = end;\n      } else if (!mutate) {\n        start = _merge(_isArray(start) ? [] : {}, start);\n      }\n      if (!interpolators) {\n        for (p in end) {\n          _addPropTween.call(master, start, p, "get", end[p]);\n        }\n        func = p => _renderPropTweens(p, master) || (isString ? start.p : start);\n      }\n    }\n    return _conditionalReturn(progress, func);\n  },\n  _getLabelInDirection = (timeline, fromTime, backward) => {\n    //used for nextLabel() and previousLabel()\n    let labels = timeline.labels,\n      min = _bigNum,\n      p,\n      distance,\n      label;\n    for (p in labels) {\n      distance = labels[p] - fromTime;\n      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n        label = p;\n        min = distance;\n      }\n    }\n    return label;\n  },\n  _callback = (animation, type, executeLazyFirst) => {\n    let v = animation.vars,\n      callback = v[type],\n      params,\n      scope;\n    if (!callback) {\n      return;\n    }\n    params = v[type + "Params"];\n    scope = v.callbackScope || animation;\n    executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n    return params ? callback.apply(scope, params) : callback.call(scope);\n  },\n  _interrupt = animation => {\n    _removeFromParent(animation);\n    animation.scrollTrigger && animation.scrollTrigger.kill(false);\n    animation.progress() < 1 && _callback(animation, "onInterrupt");\n    return animation;\n  },\n  _quickTween,\n  _createPlugin = config => {\n    config = !config.name && config.default || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n    let name = config.name,\n      isFunc = _isFunction(config),\n      Plugin = name && !isFunc && config.init ? function () {\n        this._props = [];\n      } : config,\n      //in case someone passes in an object that\'s not a plugin, like CustomEase\n      instanceDefaults = {\n        init: _emptyFunc,\n        render: _renderPropTweens,\n        add: _addPropTween,\n        kill: _killPropTweensOf,\n        modifier: _addPluginModifier,\n        rawVars: 0\n      },\n      statics = {\n        targetTest: 0,\n        get: 0,\n        getSetter: _getSetter,\n        aliases: {},\n        register: 0\n      };\n    _wake();\n    if (config !== Plugin) {\n      if (_plugins[name]) {\n        return;\n      }\n      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n      _plugins[Plugin.prop = name] = Plugin;\n      if (config.targetTest) {\n        _harnessPlugins.push(Plugin);\n        _reservedProps[name] = 1;\n      }\n      name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin\n    }\n    _addGlobal(name, Plugin);\n    config.register && config.register(gsap, Plugin, PropTween);\n  },\n  /*\n   * --------------------------------------------------------------------------------------\n   * COLORS\n   * --------------------------------------------------------------------------------------\n   */\n\n  _255 = 255,\n  _colorLookup = {\n    aqua: [0, _255, _255],\n    lime: [0, _255, 0],\n    silver: [192, 192, 192],\n    black: [0, 0, 0],\n    maroon: [128, 0, 0],\n    teal: [0, 128, 128],\n    blue: [0, 0, _255],\n    night: [0, 0, 128],\n    white: [_255, _255, _255],\n    olive: [128, 128, 0],\n    yellow: [_255, _255, 0],\n    orange: [_255, 165, 0],\n    gray: [128, 128, 128],\n    purple: [128, 0, 128],\n    green: [0, 128, 0],\n    red: [_255, 0, 0],\n    pink: [_255, 192, 203],\n    cyan: [0, _255, _255],\n    transparent: [_255, _255, _255, 0]\n  },\n  _hue = (h, m1, m2) => {\n    h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;\n    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n  },\n  splitColor = (v, toHSL, forceAlpha) => {\n    let a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\n      r,\n      g,\n      b,\n      h,\n      s,\n      l,\n      max,\n      min,\n      d,\n      wasHSL;\n    if (!a) {\n      if (v.substr(-1) === ",") {\n        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we\'d need to do it to the beginning and ending values plus it wouldn\'t provide protection from other potential scenarios like if the user passes in a similar value.\n        v = v.substr(0, v.length - 1);\n      }\n      if (_colorLookup[v]) {\n        a = _colorLookup[v];\n      } else if (v.charAt(0) === "#") {\n        if (v.length < 6) {\n          //for shorthand like #9F0 or #9F0F (could have alpha)\n          r = v.charAt(1);\n          g = v.charAt(2);\n          b = v.charAt(3);\n          v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");\n        }\n        if (v.length === 9) {\n          // hex with alpha, like #fd5e53ff\n          a = parseInt(v.substr(1, 6), 16);\n          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\n        }\n        v = parseInt(v.substr(1), 16);\n        a = [v >> 16, v >> 8 & _255, v & _255];\n      } else if (v.substr(0, 3) === "hsl") {\n        a = wasHSL = v.match(_strictNumExp);\n        if (!toHSL) {\n          h = +a[0] % 360 / 360;\n          s = +a[1] / 100;\n          l = +a[2] / 100;\n          g = l <= .5 ? l * (s + 1) : l + s - l * s;\n          r = l * 2 - g;\n          a.length > 3 && (a[3] *= 1); //cast as number\n          a[0] = _hue(h + 1 / 3, r, g);\n          a[1] = _hue(h, r, g);\n          a[2] = _hue(h - 1 / 3, r, g);\n        } else if (~v.indexOf("=")) {\n          //if relative values are found, just return the raw strings with the relative prefixes in place.\n          a = v.match(_numExp);\n          forceAlpha && a.length < 4 && (a[3] = 1);\n          return a;\n        }\n      } else {\n        a = v.match(_strictNumExp) || _colorLookup.transparent;\n      }\n      a = a.map(Number);\n    }\n    if (toHSL && !wasHSL) {\n      r = a[0] / _255;\n      g = a[1] / _255;\n      b = a[2] / _255;\n      max = Math.max(r, g, b);\n      min = Math.min(r, g, b);\n      l = (max + min) / 2;\n      if (max === min) {\n        h = s = 0;\n      } else {\n        d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n        h *= 60;\n      }\n      a[0] = ~~(h + .5);\n      a[1] = ~~(s * 100 + .5);\n      a[2] = ~~(l * 100 + .5);\n    }\n    forceAlpha && a.length < 4 && (a[3] = 1);\n    return a;\n  },\n  _colorOrderData = v => {\n    // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there\'s a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n    let values = [],\n      c = [],\n      i = -1;\n    v.split(_colorExp).forEach(v => {\n      let a = v.match(_numWithUnitExp) || [];\n      values.push(...a);\n      c.push(i += a.length + 1);\n    });\n    values.c = c;\n    return values;\n  },\n  _formatColors = (s, toHSL, orderMatchData) => {\n    let result = "",\n      colors = (s + result).match(_colorExp),\n      type = toHSL ? "hsla(" : "rgba(",\n      i = 0,\n      c,\n      shell,\n      d,\n      l;\n    if (!colors) {\n      return s;\n    }\n    colors = colors.map(color => (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")");\n    if (orderMatchData) {\n      d = _colorOrderData(s);\n      c = orderMatchData.c;\n      if (c.join(result) !== d.c.join(result)) {\n        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);\n        l = shell.length - 1;\n        for (; i < l; i++) {\n          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n        }\n      }\n    }\n    if (!shell) {\n      shell = s.split(_colorExp);\n      l = shell.length - 1;\n      for (; i < l; i++) {\n        result += shell[i] + colors[i];\n      }\n    }\n    return result + shell[l];\n  },\n  _colorExp = function () {\n    let s = "(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b",\n      //we\'ll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n      p;\n    for (p in _colorLookup) {\n      s += "|" + p + "\\\\b";\n    }\n    return new RegExp(s + ")", "gi");\n  }(),\n  _hslExp = /hsl[a]?\\(/,\n  _colorStringFilter = a => {\n    let combined = a.join(" "),\n      toHSL;\n    _colorExp.lastIndex = 0;\n    if (_colorExp.test(combined)) {\n      toHSL = _hslExp.test(combined);\n      a[1] = _formatColors(a[1], toHSL);\n      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n      return true;\n    }\n  },\n  /*\n   * --------------------------------------------------------------------------------------\n   * TICKER\n   * --------------------------------------------------------------------------------------\n   */\n  _tickerActive,\n  _ticker = function () {\n    let _getTime = Date.now,\n      _lagThreshold = 500,\n      _adjustedLag = 33,\n      _startTime = _getTime(),\n      _lastUpdate = _startTime,\n      _gap = 1000 / 240,\n      _nextTime = _gap,\n      _listeners = [],\n      _id,\n      _req,\n      _raf,\n      _self,\n      _delta,\n      _i,\n      _tick = v => {\n        let elapsed = _getTime() - _lastUpdate,\n          manual = v === true,\n          overlap,\n          dispatch,\n          time,\n          frame;\n        elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);\n        _lastUpdate += elapsed;\n        time = _lastUpdate - _startTime;\n        overlap = time - _nextTime;\n        if (overlap > 0 || manual) {\n          frame = ++_self.frame;\n          _delta = time - _self.time * 1000;\n          _self.time = time = time / 1000;\n          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n          dispatch = 1;\n        }\n        manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we\'re using a setTimeout() that\'s based on 16.7ms, it\'d technically take 31.7ms between frames otherwise.\n        if (dispatch) {\n          for (_i = 0; _i < _listeners.length; _i++) {\n            // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it\'d throw things off in the loop.\n            _listeners[_i](time, _delta, frame, v);\n          }\n        }\n      };\n    _self = {\n      time: 0,\n      frame: 0,\n      tick() {\n        _tick(true);\n      },\n      deltaRatio(fps) {\n        return _delta / (1000 / (fps || 60));\n      },\n      wake() {\n        if (_coreReady) {\n          if (!_coreInitted && _windowExists()) {\n            _win = _coreInitted = window;\n            _doc = _win.document || {};\n            _globals.gsap = gsap;\n            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n            _raf = _win.requestAnimationFrame;\n          }\n          _id && _self.sleep();\n          _req = _raf || (f => setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0));\n          _tickerActive = 1;\n          _tick(2);\n        }\n      },\n      sleep() {\n        (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);\n        _tickerActive = 0;\n        _req = _emptyFunc;\n      },\n      lagSmoothing(threshold, adjustedLag) {\n        _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited\n        _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);\n      },\n      fps(fps) {\n        _gap = 1000 / (fps || 240);\n        _nextTime = _self.time * 1000 + _gap;\n      },\n      add(callback) {\n        _listeners.indexOf(callback) < 0 && _listeners.push(callback);\n        _wake();\n      },\n      remove(callback) {\n        let i;\n        ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n      },\n      _listeners: _listeners\n    };\n    return _self;\n  }(),\n  _wake = () => !_tickerActive && _ticker.wake(),\n  //also ensures the core classes are initialized.\n\n  /*\n  * -------------------------------------------------\n  * EASING\n  * -------------------------------------------------\n  */\n  _easeMap = {},\n  _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\n  _quotesExp = /["\']/g,\n  _parseObjectInString = value => {\n    //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n    let obj = {},\n      split = value.substr(1, value.length - 3).split(":"),\n      key = split[0],\n      i = 1,\n      l = split.length,\n      index,\n      val,\n      parsedVal;\n    for (; i < l; i++) {\n      val = split[i];\n      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;\n      parsedVal = val.substr(0, index);\n      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;\n      key = val.substr(index + 1).trim();\n    }\n    return obj;\n  },\n  _valueInParentheses = value => {\n    let open = value.indexOf("(") + 1,\n      close = value.indexOf(")"),\n      nested = value.indexOf("(", open);\n    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);\n  },\n  _configEaseFromString = name => {\n    //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it\'ll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n    let split = (name + "").split("("),\n      ease = _easeMap[split[0]];\n    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;\n  },\n  _invertEase = ease => p => 1 - ease(1 - p),\n  // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n  _propagateYoyoEase = (timeline, isYoyo) => {\n    let child = timeline._first,\n      ease;\n    while (child) {\n      if (child instanceof Timeline) {\n        _propagateYoyoEase(child, isYoyo);\n      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n        if (child.timeline) {\n          _propagateYoyoEase(child.timeline, isYoyo);\n        } else {\n          ease = child._ease;\n          child._ease = child._yEase;\n          child._yEase = ease;\n          child._yoyo = isYoyo;\n        }\n      }\n      child = child._next;\n    }\n  },\n  _parseEase = (ease, defaultEase) => !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase,\n  _insertEase = function (names, easeIn) {\n    let easeOut = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : p => 1 - easeIn(1 - p);\n    let easeInOut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : p => p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n    let ease = {\n        easeIn,\n        easeOut,\n        easeInOut\n      },\n      lowercaseName;\n    _forEachName(names, name => {\n      _easeMap[name] = _globals[name] = ease;\n      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n      for (let p in ease) {\n        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];\n      }\n    });\n    return ease;\n  },\n  _easeInOutFromOut = easeOut => p => p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2,\n  _configElastic = (type, amplitude, period) => {\n    let p1 = amplitude >= 1 ? amplitude : 1,\n      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn\'t work right and the curve starts at 1.\n      p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\n      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\n      easeOut = p => p === 1 ? 1 : p1 * 2 ** (-10 * p) * _sin((p - p3) * p2) + 1,\n      ease = type === "out" ? easeOut : type === "in" ? p => 1 - easeOut(1 - p) : _easeInOutFromOut(easeOut);\n    p2 = _2PI / p2; //precalculate to optimize\n    ease.config = (amplitude, period) => _configElastic(type, amplitude, period);\n    return ease;\n  },\n  _configBack = function (type) {\n    let overshoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.70158;\n    let easeOut = p => p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0,\n      ease = type === "out" ? easeOut : type === "in" ? p => 1 - easeOut(1 - p) : _easeInOutFromOut(easeOut);\n    ease.config = overshoot => _configBack(type, overshoot);\n    return ease;\n  };\n// a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n\n_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", (name, i) => {\n  let power = i < 5 ? i + 1 : i;\n  _insertEase(name + ",Power" + (power - 1), i ? p => p ** power : p => p, p => 1 - (1 - p) ** power, p => p < .5 ? (p * 2) ** power / 2 : 1 - ((1 - p) * 2) ** power / 2);\n});\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());\n((n, c) => {\n  let n1 = 1 / c,\n    n2 = 2 * n1,\n    n3 = 2.5 * n1,\n    easeOut = p => p < n1 ? n * p * p : p < n2 ? n * (p - 1.5 / c) ** 2 + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * (p - 2.625 / c) ** 2 + .984375;\n  _insertEase("Bounce", p => 1 - easeOut(1 - p), easeOut);\n})(7.5625, 2.75);\n_insertEase("Expo", p => p ? 2 ** (10 * (p - 1)) : 0);\n_insertEase("Circ", p => -(_sqrt(1 - p * p) - 1));\n_insertEase("Sine", p => p === 1 ? 1 : -_cos(p * _HALF_PI) + 1);\n_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n  config() {\n    let steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let immediateStart = arguments.length > 1 ? arguments[1] : undefined;\n    let p1 = 1 / steps,\n      p2 = steps + (immediateStart ? 0 : 1),\n      p3 = immediateStart ? 1 : 0,\n      max = 1 - _tinyNum;\n    return p => ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n  }\n};\n_defaults.ease = _easeMap["quad.out"];\n_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", name => _callbackNames += name + "," + name + "Params,");\n\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */\nclass GSCache {\n  constructor(target, harness) {\n    this.id = _gsID++;\n    target._gsap = this;\n    this.target = target;\n    this.harness = harness;\n    this.get = harness ? harness.get : _getProperty;\n    this.set = harness ? harness.getSetter : _getSetter;\n  }\n}\n\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */\n\nclass Animation {\n  constructor(vars, time) {\n    let parent = vars.parent || _globalTimeline;\n    this.vars = vars;\n    this._delay = +vars.delay || 0;\n    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n      // TODO: repeat: Infinity on a timeline\'s children must flag that timeline internally and affect its totalDuration, otherwise it\'ll stop in the negative direction when reaching the start.\n      this._rDelay = vars.repeatDelay || 0;\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n    }\n    this._ts = 1;\n    _setDuration(this, +vars.duration, 1, 1);\n    this.data = vars.data;\n    _tickerActive || _ticker.wake();\n    parent && _addToTimeline(parent, this, time || time === 0 ? time : parent._time, 1);\n    vars.reversed && this.reverse();\n    vars.paused && this.paused(true);\n  }\n  delay(value) {\n    if (value || value === 0) {\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n      this._delay = value;\n      return this;\n    }\n    return this._delay;\n  }\n  duration(value) {\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n  }\n  totalDuration(value) {\n    if (!arguments.length) {\n      return this._tDur;\n    }\n    this._dirty = 0;\n    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n  }\n  totalTime(totalTime, suppressEvents) {\n    _wake();\n    if (!arguments.length) {\n      return this._tTime;\n    }\n    let parent = this._dp;\n    if (parent && parent.smoothChildTiming && this._ts) {\n      _alignPlayhead(this, totalTime);\n      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they\'re lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there\'s a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n      while (parent.parent) {\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n          parent.totalTime(parent._tTime, true);\n        }\n        parent = parent.parent;\n      }\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && totalTime < this._tDur || this._ts < 0 && totalTime > 0 || !this._tDur && !totalTime)) {\n        //if the animation doesn\'t have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn\'t get added back in.\n        _addToTimeline(this._dp, this, this._start - this._delay);\n      }\n    }\n    if (this._tTime !== totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !totalTime && !this._initted && (this.add || this._ptLookup)) {\n      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren\'t populated, thus when _init() is called there won\'t be any PropTweens (it\'ll act like the tween is non-functional)\n      this._ts || (this._pTime = totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it\'d revert back to the original time at the pause\n      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it\'s worth the performance hit)\n      //   this._lock = 1;\n      _lazySafeRender(this, totalTime, suppressEvents);\n      //   this._lock = 0;\n      //}\n    }\n    return this;\n  }\n  time(value, suppressEvents) {\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % this._dur || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n  }\n  totalProgress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;\n  }\n  progress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;\n  }\n  iteration(value, suppressEvents) {\n    let cycleDuration = this.duration() + this._rDelay;\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n  }\n\n  // potential future addition:\n  // isPlayingBackwards() {\n  // \tlet animation = this,\n  // \t\torientation = 1; // 1 = forward, -1 = backward\n  // \twhile (animation) {\n  // \t\torientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;\n  // \t\tanimation = animation.parent;\n  // \t}\n  // \treturn orientation < 0;\n  // }\n\n  timeScale(value) {\n    if (!arguments.length) {\n      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it\'s reversed.\n    }\n    if (this._rts === value) {\n      return this;\n    }\n    let tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n    // prioritize rendering where the parent\'s playhead lines up instead of this._tTime because there could be a tween that\'s animating another tween\'s timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n    this._rts = +value || 0;\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n    return _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));\n  }\n  paused(value) {\n    if (!arguments.length) {\n      return this._ps;\n    }\n    if (this._ps !== value) {\n      this._ps = value;\n      if (value) {\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that\'s factored in when resuming.\n        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)\n      } else {\n        _wake();\n        this._ts = this._rts;\n        //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn\'t have smoothChildTiming, we render at the rawTime() because the startTime won\'t get updated.\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && (this._tTime -= _tinyNum) && Math.abs(this._zTime) !== _tinyNum); // edge case: animation.progress(1).pause().play() wouldn\'t render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that\'ll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn\'t -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn\'t render those otherwise.\n      }\n    }\n    return this;\n  }\n  startTime(value) {\n    if (arguments.length) {\n      this._start = value;\n      let parent = this.parent || this._dp;\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n      return this;\n    }\n    return this._start;\n  }\n  endTime(includeRepeats) {\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);\n  }\n  rawTime(wrapRepeats) {\n    let parent = this.parent || this._dp; // _dp = detatched parent\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n  }\n  globalTime(rawTime) {\n    let animation = this,\n      time = arguments.length ? rawTime : animation.rawTime();\n    while (animation) {\n      time = animation._start + time / (animation._ts || 1);\n      animation = animation._dp;\n    }\n    return time;\n  }\n  repeat(value) {\n    if (arguments.length) {\n      this._repeat = value === Infinity ? -2 : value;\n      return _onUpdateTotalDuration(this);\n    }\n    return this._repeat === -2 ? Infinity : this._repeat;\n  }\n  repeatDelay(value) {\n    if (arguments.length) {\n      this._rDelay = value;\n      return _onUpdateTotalDuration(this);\n    }\n    return this._rDelay;\n  }\n  yoyo(value) {\n    if (arguments.length) {\n      this._yoyo = value;\n      return this;\n    }\n    return this._yoyo;\n  }\n  seek(position, suppressEvents) {\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n  }\n  restart(includeDelay, suppressEvents) {\n    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n  }\n  play(from, suppressEvents) {\n    from != null && this.seek(from, suppressEvents);\n    return this.reversed(false).paused(false);\n  }\n  reverse(from, suppressEvents) {\n    from != null && this.seek(from || this.totalDuration(), suppressEvents);\n    return this.reversed(true).paused(false);\n  }\n  pause(atTime, suppressEvents) {\n    atTime != null && this.seek(atTime, suppressEvents);\n    return this.paused(true);\n  }\n  resume() {\n    return this.paused(false);\n  }\n  reversed(value) {\n    if (arguments.length) {\n      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n      return this;\n    }\n    return this._rts < 0;\n  }\n  invalidate() {\n    this._initted = this._act = 0;\n    this._zTime = -_tinyNum;\n    return this;\n  }\n  isActive() {\n    let parent = this.parent || this._dp,\n      start = this._start,\n      rawTime;\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n  }\n  eventCallback(type, callback, params) {\n    let vars = this.vars;\n    if (arguments.length > 1) {\n      if (!callback) {\n        delete vars[type];\n      } else {\n        vars[type] = callback;\n        params && (vars[type + "Params"] = params);\n        type === "onUpdate" && (this._onUpdate = callback);\n      }\n      return this;\n    }\n    return vars[type];\n  }\n  then(onFulfilled) {\n    let self = this;\n    return new Promise(resolve => {\n      let f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\n        _resolve = () => {\n          let _then = self.then;\n          self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n          _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n          resolve(f);\n          self.then = _then;\n        };\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n        _resolve();\n      } else {\n        self._prom = _resolve;\n      }\n    });\n  }\n  kill() {\n    _interrupt(this);\n  }\n}\n_setDefaults(Animation.prototype, {\n  _time: 0,\n  _start: 0,\n  _end: 0,\n  _tTime: 0,\n  _tDur: 0,\n  _dirty: 0,\n  _repeat: 0,\n  _yoyo: false,\n  parent: null,\n  _initted: false,\n  _rDelay: 0,\n  _ts: 1,\n  _dp: 0,\n  ratio: 0,\n  _zTime: -_tinyNum,\n  _prom: 0,\n  _ps: false,\n  _rts: 1\n});\n\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */\n\nclass Timeline extends Animation {\n  constructor() {\n    let vars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let time = arguments.length > 1 ? arguments[1] : undefined;\n    super(vars, time);\n    this.labels = {};\n    this.smoothChildTiming = !!vars.smoothChildTiming;\n    this.autoRemoveChildren = !!vars.autoRemoveChildren;\n    this._sort = _isNotFalse(vars.sortChildren);\n    this.parent && _postAddChecks(this.parent, this);\n    vars.scrollTrigger && _scrollTrigger(this, vars.scrollTrigger);\n  }\n  to(targets, vars, position) {\n    new Tween(targets, _parseVars(arguments, 0, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));\n    return this;\n  }\n  from(targets, vars, position) {\n    new Tween(targets, _parseVars(arguments, 1, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));\n    return this;\n  }\n  fromTo(targets, fromVars, toVars, position) {\n    new Tween(targets, _parseVars(arguments, 2, this), _parsePosition(this, _isNumber(fromVars) ? arguments[4] : position));\n    return this;\n  }\n  set(targets, vars, position) {\n    vars.duration = 0;\n    vars.parent = this;\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n    vars.immediateRender = !!vars.immediateRender;\n    new Tween(targets, vars, _parsePosition(this, position), 1);\n    return this;\n  }\n  call(callback, params, position) {\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), _parsePosition(this, position));\n  }\n\n  //ONLY for backward compatibility! Maybe delete?\n  staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.duration = duration;\n    vars.stagger = vars.stagger || stagger;\n    vars.onComplete = onCompleteAll;\n    vars.onCompleteParams = onCompleteAllParams;\n    vars.parent = this;\n    new Tween(targets, vars, _parsePosition(this, position));\n    return this;\n  }\n  staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.runBackwards = 1;\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n  }\n  staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    toVars.startAt = fromVars;\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n  }\n  render(totalTime, suppressEvents, force) {\n    let prevTime = this._time,\n      tDur = this._dirty ? this.totalDuration() : this._tDur,\n      dur = this._dur,\n      tTime = this !== _globalTimeline && totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n      crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\n      time,\n      child,\n      next,\n      iteration,\n      cycleDuration,\n      prevPaused,\n      pauseTween,\n      timeScale,\n      prevStart,\n      prevIteration,\n      yoyo,\n      isYoyo;\n    if (tTime !== this._tTime || force || crossingStart) {\n      if (prevTime !== this._time && dur) {\n        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline\'s startTime backward by 30 seconds so that things align with the playhead (no jump).\n        tTime += this._time - prevTime;\n        totalTime += this._time - prevTime;\n      }\n      time = tTime;\n      prevStart = this._start;\n      timeScale = this._ts;\n      prevPaused = !timeScale;\n      if (crossingStart) {\n        dur || (prevTime = this._zTime);\n        //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it\'ll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there\'s a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\n      }\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        yoyo = this._yoyo;\n        cycleDuration = dur + this._rDelay;\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there\'s a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn\'t)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n          time > dur && (time = dur);\n        }\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005\n        if (yoyo && iteration & 1) {\n          time = dur - time;\n          isYoyo = 1;\n        }\n        /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that\'s at 2.95 or 3 seconds in which wouldn\'t render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */\n        if (iteration !== prevIteration && !this._lock) {\n          let rewinding = yoyo && prevIteration & 1,\n            doesWrap = rewinding === (yoyo && iteration & 1);\n          iteration < prevIteration && (rewinding = !rewinding);\n          prevTime = rewinding ? 0 : dur;\n          this._lock = 1;\n          this.render(prevTime || (isYoyo ? 0 : _round(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n          !suppressEvents && this.parent && _callback(this, "onRepeat");\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n            // if prevTime is 0 and we render at the very end, _time will be the end, thus won\'t match. So in this edge case, prevTime won\'t match _time but that\'s okay. If it gets killed in the onRepeat, eject as well.\n            return this;\n          }\n          dur = this._dur; // in case the duration changed in the onRepeat\n          tDur = this._tDur;\n          if (doesWrap) {\n            this._lock = 2;\n            prevTime = rewinding ? dur : -0.0001;\n            this.render(prevTime, true);\n          }\n          this._lock = 0;\n          if (!this._ts && !prevPaused) {\n            return this;\n          }\n          //in order for yoyoEase to work properly when there\'s a stagger, we must swap out the ease in each sub-tween.\n          _propagateYoyoEase(this, isYoyo);\n        }\n      }\n      if (this._hasPause && !this._forcing && this._lock < 2) {\n        pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));\n        if (pauseTween) {\n          tTime -= time - (time = pauseTween._start);\n        }\n      }\n      this._tTime = tTime;\n      this._time = time;\n      this._act = !timeScale; //as long as it\'s not paused, force it to be active so that if the user renders independent of the parent timeline, it\'ll be forced to re-render on the next tick.\n\n      if (!this._initted) {\n        this._onUpdate = this.vars.onUpdate;\n        this._initted = 1;\n        this._zTime = totalTime;\n        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n      }\n      !prevTime && time && !suppressEvents && _callback(this, "onStart");\n      if (time >= prevTime && totalTime >= 0) {\n        child = this._first;\n        while (child) {\n          next = child._next;\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child\'s render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = -_tinyNum); // it didn\'t finish rendering, so flag zTime as negative so that so that the next time render() is called it\'ll be forced (to render any remaining children)\n              break;\n            }\n          }\n          child = next;\n        }\n      } else {\n        child = this._last;\n        let adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n        while (child) {\n          next = child._prev;\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child\'s render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn\'t finish rendering, so adjust zTime so that so that the next time render() is called it\'ll be forced (to render any remaining children)\n              break;\n            }\n          }\n          child = next;\n        }\n      }\n      if (pauseTween && !suppressEvents) {\n        this.pause();\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n        if (this._ts) {\n          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it\'s SUPPOSED to be (if no pause happened).\n          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn\'t shift.\n          _setEnd(this);\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);\n      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\n        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don\'t remove if the timeline is reversed and the playhead isn\'t at 0, otherwise tl.progress(1).reverse() won\'t work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {\n          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n    return this;\n  }\n  add(child, position) {\n    _isNumber(position) || (position = _parsePosition(this, position));\n    if (!(child instanceof Animation)) {\n      if (_isArray(child)) {\n        child.forEach(obj => this.add(obj, position));\n        return this;\n      }\n      if (_isString(child)) {\n        return this.addLabel(child, position);\n      }\n      if (_isFunction(child)) {\n        child = Tween.delayedCall(0, child);\n      } else {\n        return this;\n      }\n    }\n    return this !== child ? _addToTimeline(this, child, position) : this; //don\'t allow a timeline to be added to itself as a child!\n  }\n  getChildren() {\n    let nested = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let tweens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let timelines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let ignoreBeforeTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -_bigNum;\n    let a = [],\n      child = this._first;\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        if (child instanceof Tween) {\n          tweens && a.push(child);\n        } else {\n          timelines && a.push(child);\n          nested && a.push(...child.getChildren(true, tweens, timelines));\n        }\n      }\n      child = child._next;\n    }\n    return a;\n  }\n  getById(id) {\n    let animations = this.getChildren(1, 1, 1),\n      i = animations.length;\n    while (i--) {\n      if (animations[i].vars.id === id) {\n        return animations[i];\n      }\n    }\n  }\n  remove(child) {\n    if (_isString(child)) {\n      return this.removeLabel(child);\n    }\n    if (_isFunction(child)) {\n      return this.killTweensOf(child);\n    }\n    _removeLinkedListItem(this, child);\n    if (child === this._recent) {\n      this._recent = this._last;\n    }\n    return _uncache(this);\n  }\n  totalTime(totalTime, suppressEvents) {\n    if (!arguments.length) {\n      return this._tTime;\n    }\n    this._forcing = 1;\n    if (!this._dp && this._ts) {\n      //special case for the global timeline (or any other that has no parent or detached parent).\n      this._start = _round(_ticker.time - (this._ts > 0 ? totalTime / this._ts : (this.totalDuration() - totalTime) / -this._ts));\n    }\n    super.totalTime(totalTime, suppressEvents);\n    this._forcing = 0;\n    return this;\n  }\n  addLabel(label, position) {\n    this.labels[label] = _parsePosition(this, position);\n    return this;\n  }\n  removeLabel(label) {\n    delete this.labels[label];\n    return this;\n  }\n  addPause(position, callback, params) {\n    let t = Tween.delayedCall(0, callback || _emptyFunc, params);\n    t.data = "isPause";\n    this._hasPause = 1;\n    return _addToTimeline(this, t, _parsePosition(this, position));\n  }\n  removePause(position) {\n    let child = this._first;\n    position = _parsePosition(this, position);\n    while (child) {\n      if (child._start === position && child.data === "isPause") {\n        _removeFromParent(child);\n      }\n      child = child._next;\n    }\n  }\n  killTweensOf(targets, props, onlyActive) {\n    let tweens = this.getTweensOf(targets, onlyActive),\n      i = tweens.length;\n    while (i--) {\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n    }\n    return this;\n  }\n  getTweensOf(targets, onlyActive) {\n    let a = [],\n      parsedTargets = toArray(targets),\n      child = this._first,\n      isGlobalTime = _isNumber(onlyActive),\n      // a number is interpreted as a global time. If the animation spans\n      children;\n    while (child) {\n      if (child instanceof Tween) {\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n          // note: if this is for overwriting, it should only be for tweens that aren\'t paused and are initted.\n          a.push(child);\n        }\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n        a.push(...children);\n      }\n      child = child._next;\n    }\n    return a;\n  }\n\n  // potential future feature - targets() on timelines\n  // targets() {\n  // \tlet result = [];\n  // \tthis.getChildren(true, true, false).forEach(t => result.push(...t.targets()));\n  // \treturn result;\n  // }\n\n  tweenTo(position, vars) {\n    vars = vars || {};\n    let tl = this,\n      endTime = _parsePosition(tl, position),\n      {\n        startAt,\n        onStart,\n        onStartParams,\n        immediateRender\n      } = vars,\n      tween = Tween.to(tl, _setDefaults({\n        ease: vars.ease || "none",\n        lazy: false,\n        immediateRender: false,\n        time: endTime,\n        overwrite: "auto",\n        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n        onStart: () => {\n          tl.pause();\n          let duration = vars.duration || Math.abs((endTime - tl._time) / tl.timeScale());\n          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n          onStart && onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don\'t want to overwrite it.\n        }\n      }, vars));\n    return immediateRender ? tween.render(0) : tween;\n  }\n  tweenFromTo(fromPosition, toPosition, vars) {\n    return this.tweenTo(toPosition, _setDefaults({\n      startAt: {\n        time: _parsePosition(this, fromPosition)\n      }\n    }, vars));\n  }\n  recent() {\n    return this._recent;\n  }\n  nextLabel() {\n    let afterTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._time;\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\n  }\n  previousLabel() {\n    let beforeTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._time;\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n  }\n  currentLabel(value) {\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n  }\n  shiftChildren(amount, adjustLabels) {\n    let ignoreBeforeTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let child = this._first,\n      labels = this.labels,\n      p;\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        child._start += amount;\n        child._end += amount;\n      }\n      child = child._next;\n    }\n    if (adjustLabels) {\n      for (p in labels) {\n        if (labels[p] >= ignoreBeforeTime) {\n          labels[p] += amount;\n        }\n      }\n    }\n    return _uncache(this);\n  }\n  invalidate() {\n    let child = this._first;\n    this._lock = 0;\n    while (child) {\n      child.invalidate();\n      child = child._next;\n    }\n    return super.invalidate();\n  }\n  clear() {\n    let includeLabels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let child = this._first,\n      next;\n    while (child) {\n      next = child._next;\n      this.remove(child);\n      child = next;\n    }\n    this._dp && (this._time = this._tTime = this._pTime = 0);\n    includeLabels && (this.labels = {});\n    return _uncache(this);\n  }\n  totalDuration(value) {\n    let max = 0,\n      self = this,\n      child = self._last,\n      prevStart = _bigNum,\n      prev,\n      start,\n      parent;\n    if (arguments.length) {\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n    }\n    if (self._dirty) {\n      parent = self.parent;\n      while (child) {\n        prev = child._prev; //record it here in case the tween changes position in the sequence...\n        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation\'s cache is clean before analyzing it.\n        start = child._start;\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\n          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n        } else {\n          prevStart = start;\n        }\n        if (start < 0 && child._ts) {\n          //children aren\'t allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n          max -= start;\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n            self._start += start / self._ts;\n            self._time -= start;\n            self._tTime -= start;\n          }\n          self.shiftChildren(-start, false, -1e999);\n          prevStart = 0;\n        }\n        child._end > max && child._ts && (max = child._end);\n        child = prev;\n      }\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n      self._dirty = 0;\n    }\n    return self._tDur;\n  }\n  static updateRoot(time) {\n    if (_globalTimeline._ts) {\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n      _lastRenderedFrame = _ticker.frame;\n    }\n    if (_ticker.frame >= _nextGCFrame) {\n      _nextGCFrame += _config.autoSleep || 120;\n      let child = _globalTimeline._first;\n      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\n        while (child && !child._ts) {\n          child = child._next;\n        }\n        child || _ticker.sleep();\n      }\n    }\n  }\n}\n_setDefaults(Timeline.prototype, {\n  _lock: 0,\n  _hasPause: 0,\n  _forcing: 0\n});\nlet _addComplexStringPropTween = function (target, prop, start, end, setter, stringFilter, funcParam) {\n    //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n    let pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\n      index = 0,\n      matchIndex = 0,\n      result,\n      startNums,\n      color,\n      endNum,\n      chunk,\n      startNum,\n      hasRandom,\n      a;\n    pt.b = start;\n    pt.e = end;\n    start += ""; //ensure values are strings\n    end += "";\n    if (hasRandom = ~end.indexOf("random(")) {\n      end = _replaceRandom(end);\n    }\n    if (stringFilter) {\n      a = [start, end];\n      stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n      start = a[0];\n      end = a[1];\n    }\n    startNums = start.match(_complexStringNumExp) || [];\n    while (result = _complexStringNumExp.exec(end)) {\n      endNum = result[0];\n      chunk = end.substring(index, result.index);\n      if (color) {\n        color = (color + 1) % 5;\n      } else if (chunk.substr(-5) === "rgba(") {\n        color = 1;\n      }\n      if (endNum !== startNums[matchIndex++]) {\n        startNum = parseFloat(startNums[matchIndex - 1]) || 0;\n        //these nested PropTweens are handled in a special way - we\'ll never actually call a render or setter method on them. We\'ll just loop through them in the parent complex string PropTween\'s render method.\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : ",",\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n          s: startNum,\n          c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,\n          m: color && color < 4 ? Math.round : 0\n        };\n        index = _complexStringNumExp.lastIndex;\n      }\n    }\n    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)\n    pt.fp = funcParam;\n    if (_relExp.test(end) || hasRandom) {\n      pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don\'t actually set it to the string with += or -= characters (forces it to use the calculated value).\n    }\n    this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it\'s scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.\n    return pt;\n  },\n  _addPropTween = function (target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {\n    _isFunction(end) && (end = end(index || 0, target, targets));\n    let currentValue = target[prop],\n      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),\n      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\n      pt;\n    if (_isString(end)) {\n      if (~end.indexOf("random(")) {\n        end = _replaceRandom(end);\n      }\n      if (end.charAt(1) === "=") {\n        end = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);\n      }\n    }\n    if (parsedStart !== end) {\n      if (!isNaN(parsedStart * end)) {\n        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);\n        funcParam && (pt.fp = funcParam);\n        modifier && pt.modifier(modifier, this, target);\n        return this._pt = pt;\n      }\n      !currentValue && !(prop in target) && _missingPlugin(prop, end);\n      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n    }\n  },\n  //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.\n  _processVars = (vars, index, target, targets, tween) => {\n    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n    }\n    let copy = {},\n      p;\n    for (p in vars) {\n      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n    }\n    return copy;\n  },\n  _checkPlugin = (property, vars, tween, index, target, targets) => {\n    let plugin, pt, ptLookup, i;\n    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n      if (tween !== _quickTween) {\n        ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can\'t use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won\'t match what it is in each individual tween that spawns from the stagger.\n        i = plugin._props.length;\n        while (i--) {\n          ptLookup[plugin._props[i]] = pt;\n        }\n      }\n    }\n    return plugin;\n  },\n  _overwritingTween,\n  //store a reference temporarily so we can avoid overwriting itself.\n  _initTween = (tween, time) => {\n    let vars = tween.vars,\n      {\n        ease,\n        startAt,\n        immediateRender,\n        lazy,\n        onUpdate,\n        onUpdateParams,\n        callbackScope,\n        runBackwards,\n        yoyoEase,\n        keyframes,\n        autoRevert\n      } = vars,\n      dur = tween._dur,\n      prevStartAt = tween._startAt,\n      targets = tween._targets,\n      parent = tween.parent,\n      //when a stagger (or function-based duration/delay) is on a Tween instance, we create a nested timeline which means that the "targets" of that tween don\'t reflect the parent. This function allows us to discern when it\'s a nested tween and in that case, return the full targets array so that function-based values get calculated properly.\n      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,\n      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,\n      tl = tween.timeline,\n      cleanVars,\n      i,\n      p,\n      pt,\n      target,\n      hasPriority,\n      gsData,\n      harness,\n      plugin,\n      ptLookup,\n      index,\n      harnessVars,\n      overwritten;\n    tl && (!keyframes || !ease) && (ease = "none");\n    tween._ease = _parseEase(ease, _defaults.ease);\n    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n    if (yoyoEase && tween._yoyo && !tween._repeat) {\n      //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n      yoyoEase = tween._yEase;\n      tween._yEase = tween._ease;\n      tween._ease = yoyoEase;\n    }\n    if (!tl) {\n      //if there\'s an internal timeline, skip all the parsing because we passed that task down the chain.\n      harness = targets[0] ? _getCache(targets[0]).harness : 0;\n      harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it\'s a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n      cleanVars = _copyExcluding(vars, _reservedProps);\n      prevStartAt && prevStartAt.render(-1, true).kill();\n      if (startAt) {\n        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n          data: "isStart",\n          overwrite: false,\n          parent: parent,\n          immediateRender: true,\n          lazy: _isNotFalse(lazy),\n          startAt: null,\n          delay: 0,\n          onUpdate: onUpdate,\n          onUpdateParams: onUpdateParams,\n          callbackScope: callbackScope,\n          stagger: 0\n        }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n        if (immediateRender) {\n          if (time > 0) {\n            autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn\'t revert when their parent timeline\'s playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn\'t be directly correlated to this tween\'s startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn\'t happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween\'s startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.\n          } else if (dur && !(time < 0 && prevStartAt)) {\n            time && (tween._zTime = time);\n            return; //we skip initialization here so that overwriting doesn\'t occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn\'t get placed into the timeline yet before the first render occurs and kicks in overwriting.\n          }\n        } else if (autoRevert === false) {\n          tween._startAt = 0;\n        }\n      } else if (runBackwards && dur) {\n        //from() tweens must be handled uniquely: their beginning values must be rendered but we don\'t want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n        if (prevStartAt) {\n          !autoRevert && (tween._startAt = 0);\n        } else {\n          time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there\'s no need to force the render in this context when the _time is greater than 0\n          p = _setDefaults({\n            overwrite: false,\n            data: "isFromStart",\n            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that\'s setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it\'d kick back in.\n            lazy: immediateRender && _isNotFalse(lazy),\n            immediateRender: immediateRender,\n            //zero-duration tweens render immediately by default, but if we\'re not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we\'d have to render(-1) immediately after)\n            stagger: 0,\n            parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})\n          }, cleanVars);\n          harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n          _removeFromParent(tween._startAt = Tween.set(targets, p));\n          if (!immediateRender) {\n            _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded\n          } else if (!time) {\n            return;\n          }\n        }\n      }\n      tween._pt = 0;\n      lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n      for (i = 0; i < targets.length; i++) {\n        target = targets[i];\n        gsData = target._gsap || _harness(targets)[i]._gsap;\n        tween._ptLookup[i] = ptLookup = {};\n        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven\'t rendered yet, we\'ve got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n        index = fullTargets === targets ? i : fullTargets.indexOf(target);\n        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n          plugin._props.forEach(name => {\n            ptLookup[name] = pt;\n          });\n          plugin.priority && (hasPriority = 1);\n        }\n        if (!harness || harnessVars) {\n          for (p in cleanVars) {\n            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n              plugin.priority && (hasPriority = 1);\n            } else {\n              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n            }\n          }\n        }\n        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n        if (autoOverwrite && tween._pt) {\n          _overwritingTween = tween;\n          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(0)); //Also make sure the overwriting doesn\'t overwrite THIS tween!!!\n          overwritten = !tween.parent;\n          _overwritingTween = 0;\n        }\n        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n      }\n      hasPriority && _sortPropTweensByPriority(tween);\n      tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin\'s init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it\'s fast and keeps file size down.\n    }\n    tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n    tween._onUpdate = onUpdate;\n    tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n  },\n  _addAliasesToVars = (targets, vars) => {\n    let harness = targets[0] ? _getCache(targets[0]).harness : 0,\n      propertyAliases = harness && harness.aliases,\n      copy,\n      p,\n      i,\n      aliases;\n    if (!propertyAliases) {\n      return vars;\n    }\n    copy = _merge({}, vars);\n    for (p in propertyAliases) {\n      if (p in copy) {\n        aliases = propertyAliases[p].split(",");\n        i = aliases.length;\n        while (i--) {\n          copy[aliases[i]] = copy[p];\n        }\n      }\n    }\n    return copy;\n  },\n  _parseFuncOrString = (value, tween, i, target, targets) => _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value,\n  _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",\n  _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger").split(",");\n\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */\n\nclass Tween extends Animation {\n  constructor(targets, vars, time, skipInherit) {\n    if (typeof vars === "number") {\n      time.duration = vars;\n      vars = time;\n      time = null;\n    }\n    super(skipInherit ? vars : _inheritDefaults(vars), time);\n    let {\n        duration,\n        delay,\n        immediateRender,\n        stagger,\n        overwrite,\n        keyframes,\n        defaults,\n        scrollTrigger,\n        yoyoEase\n      } = this.vars,\n      parent = this.parent,\n      parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),\n      // edge case: someone might try animating the "length" of an object with a "length" property that\'s initially set to 0 so don\'t interpret that as an empty Array-like object.\n      tl,\n      i,\n      copy,\n      l,\n      p,\n      curTarget,\n      staggerFunc,\n      staggerVarsToMerge;\n    this._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];\n    this._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n    this._overwrite = overwrite;\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n      vars = this.vars;\n      tl = this.timeline = new Timeline({\n        data: "nested",\n        defaults: defaults || {}\n      });\n      tl.kill();\n      tl.parent = tl._dp = this;\n      tl._start = 0;\n      if (keyframes) {\n        _setDefaults(tl.vars.defaults, {\n          ease: "none"\n        });\n        keyframes.forEach(frame => tl.to(parsedTargets, frame, ">"));\n      } else {\n        l = parsedTargets.length;\n        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;\n        if (_isObject(stagger)) {\n          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n          for (p in stagger) {\n            if (~_staggerTweenProps.indexOf(p)) {\n              staggerVarsToMerge || (staggerVarsToMerge = {});\n              staggerVarsToMerge[p] = stagger[p];\n            }\n          }\n        }\n        for (i = 0; i < l; i++) {\n          copy = {};\n          for (p in vars) {\n            if (_staggerPropsToSkip.indexOf(p) < 0) {\n              copy[p] = vars[p];\n            }\n          }\n          copy.stagger = 0;\n          yoyoEase && (copy.yoyoEase = yoyoEase);\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n          curTarget = parsedTargets[i];\n          //don\'t just copy duration or delay because if they\'re a string or function, we\'d end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n          copy.duration = +_parseFuncOrString(duration, this, i, curTarget, parsedTargets);\n          copy.delay = (+_parseFuncOrString(delay, this, i, curTarget, parsedTargets) || 0) - this._delay;\n          if (!stagger && l === 1 && copy.delay) {\n            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn\'t be inside the repeat.\n            this._delay = delay = copy.delay;\n            this._start += delay;\n            copy.delay = 0;\n          }\n          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));\n        }\n        tl.duration() ? duration = delay = 0 : this.timeline = 0; // if the timeline\'s duration is 0, we don\'t need a timeline internally!\n      }\n      duration || this.duration(duration = tl.duration());\n    } else {\n      this.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n    }\n    if (overwrite === true && !_suppressOverwrites) {\n      _overwritingTween = this;\n      _globalTimeline.killTweensOf(parsedTargets);\n      _overwritingTween = 0;\n    }\n    parent && _postAddChecks(parent, this);\n    if (immediateRender || !duration && !keyframes && this._start === _round(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(this) && parent.data !== "nested") {\n      this._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)\n      this.render(Math.max(0, -delay)); //in case delay is negative\n    }\n    scrollTrigger && _scrollTrigger(this, scrollTrigger);\n  }\n  render(totalTime, suppressEvents, force) {\n    let prevTime = this._time,\n      tDur = this._tDur,\n      dur = this._dur,\n      tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n      time,\n      pt,\n      iteration,\n      cycleDuration,\n      prevIteration,\n      isYoyo,\n      ratio,\n      timeline,\n      yoyoEase;\n    if (!dur) {\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {\n      //this senses if we\'re crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n      time = tTime;\n      timeline = this.timeline;\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        cycleDuration = dur + this._rDelay;\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there\'s a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn\'t)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n          time > dur && (time = dur);\n        }\n        isYoyo = this._yoyo && iteration & 1;\n        if (isYoyo) {\n          yoyoEase = this._yEase;\n          time = dur - time;\n        }\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        if (time === prevTime && !force && this._initted) {\n          //could be during the repeatDelay part. No need to render and fire callbacks.\n          return this;\n        }\n        if (iteration !== prevIteration) {\n          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);\n          //repeatRefresh functionality\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {\n            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we\'ll jump out and get caught bouncing on each tick.\n            this.render(_round(cycleDuration * iteration), true).invalidate()._lock = 0;\n          }\n        }\n      }\n      if (!this._initted) {\n        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {\n          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can\'t leave _tTime as a negative number.\n          return this;\n        }\n        if (dur !== this._dur) {\n          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n      this._tTime = tTime;\n      this._time = time;\n      if (!this._act && this._ts) {\n        this._act = 1; //as long as it\'s not paused, force it to be active so that if the user renders independent of the parent timeline, it\'ll be forced to re-render on the next tick.\n        this._lazy = 0;\n      }\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n      if (this._from) {\n        this.ratio = ratio = 1 - ratio;\n      }\n      time && !prevTime && !suppressEvents && _callback(this, "onStart");\n      pt = this._pt;\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n      if (this._onUpdate && !suppressEvents) {\n        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don\'t have an onUpdate). We\'d just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it\'s not called, we do so later near the onComplete.\n        _callback(this, "onUpdate");\n      }\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don\'t remove if we\'re rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don\'t remove if the timeline is reversed and the playhead isn\'t at 0, otherwise tl.progress(1).reverse() won\'t work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {\n          // if prevTime and tTime are zero, we shouldn\'t fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n    return this;\n  }\n  targets() {\n    return this._targets;\n  }\n  invalidate() {\n    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;\n    this._ptLookup = [];\n    this.timeline && this.timeline.invalidate();\n    return super.invalidate();\n  }\n  kill(targets) {\n    let vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "all";\n    if (!targets && (!vars || vars === "all")) {\n      this._lazy = this._pt = 0;\n      return this.parent ? _interrupt(this) : this;\n    }\n    if (this.timeline) {\n      let tDur = this.timeline.totalDuration();\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween\'s duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don\'t all add up to whatever the parent tween\'s duration was set to.\n      return this;\n    }\n    let parsedTargets = this._targets,\n      killingTargets = targets ? toArray(targets) : parsedTargets,\n      propTweenLookup = this._ptLookup,\n      firstPT = this._pt,\n      overwrittenProps,\n      curLookup,\n      curOverwriteProps,\n      props,\n      p,\n      pt,\n      i;\n    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {\n      vars === "all" && (this._pt = 0);\n      return _interrupt(this);\n    }\n    overwrittenProps = this._op = this._op || [];\n    if (vars !== "all") {\n      //so people can pass in a comma-delimited list of property names\n      if (_isString(vars)) {\n        p = {};\n        _forEachName(vars, name => p[name] = 1);\n        vars = p;\n      }\n      vars = _addAliasesToVars(parsedTargets, vars);\n    }\n    i = parsedTargets.length;\n    while (i--) {\n      if (~killingTargets.indexOf(parsedTargets[i])) {\n        curLookup = propTweenLookup[i];\n        if (vars === "all") {\n          overwrittenProps[i] = vars;\n          props = curLookup;\n          curOverwriteProps = {};\n        } else {\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n          props = vars;\n        }\n        for (p in props) {\n          pt = curLookup && curLookup[p];\n          if (pt) {\n            if (!("kill" in pt.d) || pt.d.kill(p) === true) {\n              _removeLinkedListItem(this, pt, "_pt");\n            }\n            delete curLookup[p];\n          }\n          if (curOverwriteProps !== "all") {\n            curOverwriteProps[p] = 1;\n          }\n        }\n      }\n    }\n    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there\'s a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren\'t any more properties tweening.\n    return this;\n  }\n  static to(targets, vars) {\n    return new Tween(targets, vars, arguments[2]);\n  }\n  static from(targets, vars) {\n    return new Tween(targets, _parseVars(arguments, 1));\n  }\n  static delayedCall(delay, callback, params, scope) {\n    return new Tween(callback, 0, {\n      immediateRender: false,\n      lazy: false,\n      overwrite: false,\n      delay: delay,\n      onComplete: callback,\n      onReverseComplete: callback,\n      onCompleteParams: params,\n      onReverseCompleteParams: params,\n      callbackScope: scope\n    });\n  }\n  static fromTo(targets, fromVars, toVars) {\n    return new Tween(targets, _parseVars(arguments, 2));\n  }\n  static set(targets, vars) {\n    vars.duration = 0;\n    vars.repeatDelay || (vars.repeat = 0);\n    return new Tween(targets, vars);\n  }\n  static killTweensOf(targets, props, onlyActive) {\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\n  }\n}\n_setDefaults(Tween.prototype, {\n  _targets: [],\n  _lazy: 0,\n  _startAt: 0,\n  _op: 0,\n  _onInit: 0\n});\n\n//add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it\'d ultimately add to more confusion especially for beginners)\n// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n\n//for backward compatibility. Leverage the timeline calls.\n_forEachName("staggerTo,staggerFrom,staggerFromTo", name => {\n  Tween[name] = function () {\n    let tl = new Timeline(),\n      params = _slice.call(arguments, 0);\n    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);\n    return tl[name].apply(tl, params);\n  };\n});\n\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */\nlet _setterPlain = (target, property, value) => target[property] = value,\n  _setterFunc = (target, property, value) => target[property](value),\n  _setterFuncWithParam = (target, property, value, data) => target[property](data.fp, value),\n  _setterAttribute = (target, property, value) => target.setAttribute(property, value),\n  _getSetter = (target, property) => _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain,\n  _renderPlain = (ratio, data) => data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000, data),\n  _renderBoolean = (ratio, data) => data.set(data.t, data.p, !!(data.s + data.c * ratio), data),\n  _renderComplexString = function (ratio, data) {\n    let pt = data._pt,\n      s = "";\n    if (!ratio && data.b) {\n      //b = beginning string\n      s = data.b;\n    } else if (ratio === 1 && data.e) {\n      //e = ending string\n      s = data.e;\n    } else {\n      while (pt) {\n        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n        pt = pt._next;\n      }\n      s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.\n    }\n    data.set(data.t, data.p, s, data);\n  },\n  _renderPropTweens = function (ratio, data) {\n    let pt = data._pt;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n  },\n  _addPluginModifier = function (modifier, tween, target, property) {\n    let pt = this._pt,\n      next;\n    while (pt) {\n      next = pt._next;\n      pt.p === property && pt.modifier(modifier, tween, target);\n      pt = next;\n    }\n  },\n  _killPropTweensOf = function (property) {\n    let pt = this._pt,\n      hasNonDependentRemaining,\n      next;\n    while (pt) {\n      next = pt._next;\n      if (pt.p === property && !pt.op || pt.op === property) {\n        _removeLinkedListItem(this, pt, "_pt");\n      } else if (!pt.dep) {\n        hasNonDependentRemaining = 1;\n      }\n      pt = next;\n    }\n    return !hasNonDependentRemaining;\n  },\n  _setterWithModifier = (target, property, value, data) => {\n    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n  },\n  _sortPropTweensByPriority = parent => {\n    let pt = parent._pt,\n      next,\n      pt2,\n      first,\n      last;\n    //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n    while (pt) {\n      next = pt._next;\n      pt2 = first;\n      while (pt2 && pt2.pr > pt.pr) {\n        pt2 = pt2._next;\n      }\n      if (pt._prev = pt2 ? pt2._prev : last) {\n        pt._prev._next = pt;\n      } else {\n        first = pt;\n      }\n      if (pt._next = pt2) {\n        pt2._prev = pt;\n      } else {\n        last = pt;\n      }\n      pt = next;\n    }\n    parent._pt = first;\n  };\n\n//PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it\'s different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\nclass PropTween {\n  constructor(next, target, prop, start, change, renderer, data, setter, priority) {\n    this.t = target;\n    this.s = start;\n    this.c = change;\n    this.p = prop;\n    this.r = renderer || _renderPlain;\n    this.d = data || this;\n    this.set = setter || _setterPlain;\n    this.pr = priority || 0;\n    this._next = next;\n    if (next) {\n      next._prev = this;\n    }\n  }\n  modifier(func, tween, target) {\n    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n    this.set = _setterWithModifier;\n    this.m = func;\n    this.mt = target; //modifier target\n    this.tween = tween;\n  }\n}\n\n//Initialization tasks\n_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", name => _reservedProps[name] = 1);\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n  sortChildren: false,\n  defaults: _defaults,\n  autoRemoveChildren: true,\n  id: "root",\n  smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\n\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */\nconst _gsap = {\n  registerPlugin() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    args.forEach(config => _createPlugin(config));\n  },\n  timeline(vars) {\n    return new Timeline(vars);\n  },\n  getTweensOf(targets, onlyActive) {\n    return _globalTimeline.getTweensOf(targets, onlyActive);\n  },\n  getProperty(target, property, unit, uncache) {\n    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n    let getter = _getCache(target || {}).get,\n      format = unit ? _passThrough : _numericIfPossible;\n    unit === "native" && (unit = "");\n    return !target ? target : !property ? (property, unit, uncache) => format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache)) : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n  },\n  quickSetter(target, property, unit) {\n    target = toArray(target);\n    if (target.length > 1) {\n      let setters = target.map(t => gsap.quickSetter(t, property, unit)),\n        l = setters.length;\n      return value => {\n        let i = l;\n        while (i--) {\n          setters[i](value);\n        }\n      };\n    }\n    target = target[0] || {};\n    let Plugin = _plugins[property],\n      cache = _getCache(target),\n      p = cache.harness && (cache.harness.aliases || {})[property] || property,\n      // in case it\'s an alias, like "rotate" for "rotation".\n      setter = Plugin ? value => {\n        let p = new Plugin();\n        _quickTween._pt = 0;\n        p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\n        p.render(1, p);\n        _quickTween._pt && _renderPropTweens(1, _quickTween);\n      } : cache.set(target, p);\n    return Plugin ? setter : value => setter(target, p, unit ? value + unit : value, cache, 1);\n  },\n  isTweening(targets) {\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\n  },\n  defaults(value) {\n    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n    return _mergeDeep(_defaults, value || {});\n  },\n  config(value) {\n    return _mergeDeep(_config, value || {});\n  },\n  registerEffect(_ref2) {\n    let {\n      name,\n      effect,\n      plugins,\n      defaults,\n      extendTimeline\n    } = _ref2;\n    (plugins || "").split(",").forEach(pluginName => pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin."));\n    _effects[name] = (targets, vars, tl) => effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n    if (extendTimeline) {\n      Timeline.prototype[name] = function (targets, vars, position) {\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n      };\n    }\n  },\n  registerEase(name, ease) {\n    _easeMap[name] = _parseEase(ease);\n  },\n  parseEase(ease, defaultEase) {\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n  },\n  getById(id) {\n    return _globalTimeline.getById(id);\n  },\n  exportRoot() {\n    let vars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let includeDelayedCalls = arguments.length > 1 ? arguments[1] : undefined;\n    let tl = new Timeline(vars),\n      child,\n      next;\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n    _globalTimeline.remove(tl);\n    tl._dp = 0; //otherwise it\'ll get re-activated when adding children and be re-introduced into _globalTimeline\'s linked list (then added to itself).\n    tl._time = tl._tTime = _globalTimeline._time;\n    child = _globalTimeline._first;\n    while (child) {\n      next = child._next;\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n        _addToTimeline(tl, child, child._start - child._delay);\n      }\n      child = next;\n    }\n    _addToTimeline(_globalTimeline, tl, 0);\n    return tl;\n  },\n  utils: {\n    wrap,\n    wrapYoyo,\n    distribute,\n    random,\n    snap,\n    normalize,\n    getUnit,\n    clamp,\n    splitColor,\n    toArray,\n    mapRange,\n    pipe,\n    unitize,\n    interpolate,\n    shuffle\n  },\n  install: _install,\n  effects: _effects,\n  ticker: _ticker,\n  updateRoot: Timeline.updateRoot,\n  plugins: _plugins,\n  globalTimeline: _globalTimeline,\n  core: {\n    PropTween,\n    globals: _addGlobal,\n    Tween,\n    Timeline,\n    Animation,\n    getCache: _getCache,\n    _removeLinkedListItem,\n    suppressOverwrites: value => _suppressOverwrites = value\n  }\n};\n_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", name => _gsap[name] = Tween[name]);\n_ticker.add(Timeline.updateRoot);\n_quickTween = _gsap.to({}, {\n  duration: 0\n});\n\n// ---- EXTRA PLUGINS --------------------------------------------------------\n\nlet _getPluginPropTween = (plugin, prop) => {\n    let pt = plugin._pt;\n    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n      pt = pt._next;\n    }\n    return pt;\n  },\n  _addModifiers = (tween, modifiers) => {\n    let targets = tween._targets,\n      p,\n      i,\n      pt;\n    for (p in modifiers) {\n      i = targets.length;\n      while (i--) {\n        pt = tween._ptLookup[i][p];\n        if (pt && (pt = pt.d)) {\n          if (pt._pt) {\n            // is a plugin\n            pt = _getPluginPropTween(pt, p);\n          }\n          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n        }\n      }\n    }\n  },\n  _buildModifierPlugin = (name, modifier) => {\n    return {\n      name: name,\n      rawVars: 1,\n      //don\'t pre-process function-based values or "random()" strings.\n      init(target, vars, tween) {\n        tween._onInit = tween => {\n          let temp, p;\n          if (_isString(vars)) {\n            temp = {};\n            _forEachName(vars, name => temp[name] = 1); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.\n            vars = temp;\n          }\n          if (modifier) {\n            temp = {};\n            for (p in vars) {\n              temp[p] = modifier(vars[p]);\n            }\n            vars = temp;\n          }\n          _addModifiers(tween, vars);\n        };\n      }\n    };\n  };\n\n//register core plugins\nconst gsap = _gsap.registerPlugin({\n  name: "attr",\n  init(target, vars, tween, index, targets) {\n    let p, pt;\n    for (p in vars) {\n      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);\n      pt && (pt.op = p);\n      this._props.push(p);\n    }\n  }\n}, {\n  name: "endArray",\n  init(target, value) {\n    let i = value.length;\n    while (i--) {\n      this.add(target, i, target[i] || 0, value[i]);\n    }\n  }\n}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\n\nTween.version = Timeline.version = gsap.version = "3.6.1";\n_coreReady = 1;\nif (_windowExists()) {\n  _wake();\n}\nconst {\n  Power0,\n  Power1,\n  Power2,\n  Power3,\n  Power4,\n  Linear,\n  Quad,\n  Cubic,\n  Quart,\n  Quint,\n  Strong,\n  Elastic,\n  Back,\n  SteppedEase,\n  Bounce,\n  Sine,\n  Expo,\n  Circ\n} = _easeMap;\n\n//export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/gsap-core.js?')},"./build/scripts/vendor/gsap/src/utils/PathEditor.js":
/*!***********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/utils/PathEditor.js ***!
  \***********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PathEditor: () => (/* binding */ PathEditor),\n/* harmony export */   "default": () => (/* binding */ PathEditor)\n/* harmony export */ });\n/* harmony import */ var _paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paths.js */ "./build/scripts/vendor/gsap/src/utils/paths.js");\n/* harmony import */ var _matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix.js */ "./build/scripts/vendor/gsap/src/utils/matrix.js");\n/*!\n * PathEditor 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\n\nlet _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n  _doc,\n  _supportsPointer,\n  _win,\n  _body,\n  _selectionColor = "#4e7fff",\n  _minimumMovement = 1,\n  _DEG2RAD = Math.PI / 180,\n  _getTime = Date.now || (() => new Date().getTime()),\n  _lastInteraction = 0,\n  _isPressed = 0,\n  _emptyFunc = () => false,\n  _interacted = () => _lastInteraction = _getTime(),\n  _CTRL,\n  _ALT,\n  _SHIFT,\n  _CMD,\n  _recentlyAddedAnchor,\n  _editingAxis = {},\n  //stores the x/y of the most recently-selected anchor point\'s x and y axis. We tap into this for snapping horizontally and vertically.\n  _history = [],\n  _point = {},\n  //reuse to minimize memory and maximize performance (mostly for snapping)\n  _temp = [],\n  //reuse this in places like getNormalizedSVG() to conserve memory\n  _comma = ",",\n  _selectedPaths = [],\n  _preventDefault = event => {\n    if (event.preventDefault) {\n      event.preventDefault();\n      if (event.preventManipulation) {\n        event.preventManipulation(); //for some Microsoft browsers\n      }\n    }\n  },\n  _createElement = type => _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type),\n  _createSVG = (type, container, attributes) => {\n    let element = _doc.createElementNS("http://www.w3.org/2000/svg", type),\n      reg = /([a-z])([A-Z])/g,\n      p;\n    attributes = attributes || {};\n    attributes.class = attributes.class || "path-editor";\n    for (p in attributes) {\n      if (element.style[p] !== undefined) {\n        element.style[p] = attributes[p];\n      } else {\n        element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);\n      }\n    }\n    container.appendChild(element);\n    return element;\n  },\n  _identityMatrixObject = {\n    matrix: new _matrix_js__WEBPACK_IMPORTED_MODULE_1__.Matrix2D()\n  },\n  _getConsolidatedMatrix = target => (target.transform && target.transform.baseVal.consolidate() || _identityMatrixObject).matrix,\n  _getConcatenatedTransforms = target => {\n    let m = _getConsolidatedMatrix(target),\n      owner = target.ownerSVGElement;\n    while ((target = target.parentNode) && target.ownerSVGElement === owner) {\n      m.multiply(_getConsolidatedMatrix(target));\n    }\n    return "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";\n  },\n  _addHistory = pathEditor => {\n    let selectedIndexes = [],\n      a = pathEditor._selectedAnchors,\n      i;\n    for (i = 0; i < a.length; i++) {\n      selectedIndexes[i] = a[i].i;\n    }\n    _history.unshift({\n      path: pathEditor,\n      d: pathEditor.path.getAttribute("d"),\n      transform: pathEditor.path.getAttribute("transform") || "",\n      selectedIndexes: selectedIndexes\n    });\n    if (_history.length > 30) {\n      _history.length = 30;\n    }\n  },\n  _round = value => ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000,\n  _getSquarePathData = size => {\n    size = _round(size);\n    return ["M-" + size, -size, size, -size, size, size, -size, size + "z"].join(_comma);\n  },\n  _getCirclePathData = size => {\n    let circ = 0.552284749831,\n      rcirc = _round(size * circ);\n    size = _round(size);\n    return "M" + size + ",0C" + [size, rcirc, rcirc, size, 0, size, -rcirc, size, -size, rcirc, -size, 0, -size, -rcirc, -rcirc, -size, 0, -size, rcirc, -size, size, -rcirc, size, 0].join(_comma) + "z";\n  },\n  _checkDeselect = function (e) {\n    if (!e.target._gsSelection && !_isPressed && _getTime() - _lastInteraction > 100) {\n      let i = _selectedPaths.length;\n      while (--i > -1) {\n        _selectedPaths[i].deselect();\n      }\n      _selectedPaths.length = 0;\n    }\n  },\n  _tempDiv,\n  _touchEventLookup,\n  _isMultiTouching = 0,\n  _addListener = (element, type, func, capture) => {\n    if (element.addEventListener) {\n      let touchType = _touchEventLookup[type];\n      capture = capture || {\n        passive: false\n      };\n      element.addEventListener(touchType || type, func, capture);\n      if (touchType && type !== touchType && touchType.substr(0, 7) !== "pointer") {\n        //some browsers actually support both, so must we. But pointer events cover all.\n        element.addEventListener(type, func, capture);\n      }\n    } else if (element.attachEvent) {\n      element.attachEvent("on" + type, func);\n    }\n  },\n  _removeListener = (element, type, func) => {\n    if (element.removeEventListener) {\n      let touchType = _touchEventLookup[type];\n      element.removeEventListener(touchType || type, func);\n      if (touchType && type !== touchType && touchType.substr(0, 7) !== "pointer") {\n        element.removeEventListener(type, func);\n      }\n    } else if (element.detachEvent) {\n      element.detachEvent("on" + type, func);\n    }\n  },\n  _hasTouchID = (list, ID) => {\n    let i = list.length;\n    while (--i > -1) {\n      if (list[i].identifier === ID) {\n        return true;\n      }\n    }\n    return false;\n  },\n  _onMultiTouchDocumentEnd = e => {\n    _isMultiTouching = e.touches && _dragCount < e.touches.length;\n    _removeListener(e.target, "touchend", _onMultiTouchDocumentEnd);\n  },\n  _onMultiTouchDocument = e => {\n    _isMultiTouching = e.touches && _dragCount < e.touches.length;\n    _addListener(e.target, "touchend", _onMultiTouchDocumentEnd);\n  },\n  _bind = (func, scope) => e => func.call(scope, e),\n  _callback = (type, self, param) => {\n    let callback = self.vars[type];\n    if (callback) {\n      callback.call(self.vars.callbackScope || self, param || self);\n    }\n    return self;\n  },\n  _copyElement,\n  _resetSelection = () => {\n    _copyElement.style.display = "block";\n    _copyElement.select();\n    _copyElement.style.display = "none";\n  },\n  _coreInitted,\n  _initCore = () => {\n    _doc = document;\n    _win = window;\n    _body = _doc.body;\n    _tempDiv = _createElement("div");\n    _copyElement = _createElement("textarea");\n    _copyElement.style.display = "none";\n    _body && _body.appendChild(_copyElement);\n    _touchEventLookup = function (types) {\n      //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we\'re in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.\n      let standard = types.split(","),\n        converted = (_tempDiv.onpointerdown !== undefined ? "pointerdown,pointermove,pointerup,pointercancel" : _tempDiv.onmspointerdown !== undefined ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),\n        obj = {},\n        i = 4;\n      while (--i > -1) {\n        obj[standard[i]] = converted[i];\n        obj[converted[i]] = standard[i];\n      }\n      return obj;\n    }("touchstart,touchmove,touchend,touchcancel");\n    SVGElement.prototype.getTransformToElement = SVGElement.prototype.getTransformToElement || function (e) {\n      //adds Chrome support\n      return e.getScreenCTM().inverse().multiply(this.getScreenCTM());\n    };\n    _doc.addEventListener("keydown", function (e) {\n      let key = e.keyCode || e.which,\n        keyString = e.key || key,\n        i,\n        state,\n        a,\n        path;\n      if (keyString === "Shift" || key === 16) {\n        _SHIFT = true;\n      } else if (keyString === "Control" || key === 17) {\n        _CTRL = true;\n      } else if (keyString === "Meta" || key === 91) {\n        _CMD = true;\n      } else if (keyString === "Alt" || key === 18) {\n        _ALT = true;\n        i = _selectedPaths.length;\n        while (--i > -1) {\n          _selectedPaths[i]._onPressAlt();\n        }\n      } else if ((keyString === "z" || key === 90) && (_CTRL || _CMD) && _history.length > 1) {\n        //UNDO\n        _history.shift();\n        state = _history[0];\n        if (state) {\n          path = state.path;\n          path.path.setAttribute("d", state.d);\n          path.path.setAttribute("transform", state.transform);\n          path.init();\n          a = path._anchors;\n          for (i = 0; i < a.length; i++) {\n            if (state.selectedIndexes.indexOf(a[i].i) !== -1) {\n              path._selectedAnchors.push(a[i]);\n            }\n          }\n          path._updateAnchors();\n          path.update();\n          if (path.vars.onUndo) {\n            path.vars.onUndo.call(path);\n          }\n        }\n      } else if (keyString === "Delete" || keyString === "Backspace" || key === 8 || key === 46 || key === 63272 || key === "d" && (_CTRL || _CMD)) {\n        //DELETE\n        i = _selectedPaths.length;\n        while (--i > -1) {\n          _selectedPaths[i]._deleteSelectedAnchors();\n        }\n      } else if ((keyString === "a" || key === 65) && (_CMD || _CTRL)) {\n        //SELECT ALL\n        i = _selectedPaths.length;\n        while (--i > -1) {\n          _selectedPaths[i].select(true);\n        }\n      }\n    }, true);\n    _doc.addEventListener("keyup", function (e) {\n      let key = e.key || e.keyCode || e.which;\n      if (key === "Shift" || key === 16) {\n        _SHIFT = false;\n      } else if (key === "Control" || key === 17) {\n        _CTRL = false;\n      } else if (key === "Meta" || key === 91) {\n        _CMD = false;\n      } else if (key === "Alt" || key === 18) {\n        _ALT = false;\n        let i = _selectedPaths.length;\n        while (--i > -1) {\n          _selectedPaths[i]._onReleaseAlt();\n        }\n      }\n    }, true);\n    _supportsPointer = !!_win.PointerEvent;\n    _addListener(_doc, "mouseup", _checkDeselect);\n    _addListener(_doc, "touchend", _checkDeselect);\n    _addListener(_doc, "touchcancel", _emptyFunc); //some older Android devices intermittently stop dispatching "touchmove" events if we don\'t listen for "touchcancel" on the document. Very strange indeed.\n    _addListener(_win, "touchmove", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.\n    _body && _body.addEventListener("touchstart", _emptyFunc); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/\n    _coreInitted = 1;\n  },\n  _onPress = function (e) {\n    let self = this,\n      ctm = (0,_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(self.target.parentNode, true),\n      //previously used self.target.parentNode.getScreenCTM().inverse() but there\'s a major bug in Firefox that prevents it from working properly when there\'s an ancestor with a transform applied, so we bootstrapped our own solution that seems to work great across all browsers.\n      touchEventTarget,\n      temp;\n    this._matrix = this.target.transform.baseVal.getItem(0).matrix;\n    this._ctm = ctm;\n    if (_touchEventLookup[e.type]) {\n      //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.\n      touchEventTarget = e.type.indexOf("touch") !== -1 ? e.currentTarget || e.target : _doc; //pointer-based touches (for Microsoft browsers) don\'t remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".\n      _addListener(touchEventTarget, "touchend", self._onRelease);\n      _addListener(touchEventTarget, "touchmove", self._onMove);\n      _addListener(touchEventTarget, "touchcancel", self._onRelease);\n      _addListener(_doc, "touchstart", _onMultiTouchDocument);\n      _addListener(_win, "touchforcechange", _preventDefault); //otherwise iOS will scroll when dragging.\n    } else {\n      touchEventTarget = null;\n      _addListener(_doc, "mousemove", self._onMove); //attach these to the document instead of the box itself so that if the user\'s mouse moves too quickly (and off of the box), things still work.\n    }\n    if (!_supportsPointer) {\n      _addListener(_doc, "mouseup", self._onRelease);\n    }\n    _preventDefault(e);\n    _resetSelection(); // when a PathEditor is in an iframe in an environment like codepen, this helps avoid situations where the DELETE key won\'t actually work because the parent frame is intercepting the event.\n    if (e.changedTouches) {\n      //touch events store the data slightly differently\n      e = self.touch = e.changedTouches[0];\n      self.touchID = e.identifier;\n    } else if (e.pointerId) {\n      self.touchID = e.pointerId; //for some Microsoft browsers\n    } else {\n      self.touch = self.touchID = null;\n    }\n    self._startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove\n    self._startPointerX = self.pointerX = e.pageX;\n    self._startElementX = self._matrix.e;\n    self._startElementY = self._matrix.f;\n    if (this._ctm.a === 1 && this._ctm.b === 0 && this._ctm.c === 0 && this._ctm.d === 1) {\n      this._ctm = null;\n    } else {\n      temp = self._startPointerX * this._ctm.a + self._startPointerY * this._ctm.c + this._ctm.e;\n      self._startPointerY = self._startPointerX * this._ctm.b + self._startPointerY * this._ctm.d + this._ctm.f;\n      self._startPointerX = temp;\n    }\n    self.isPressed = _isPressed = true;\n    self.touchEventTarget = touchEventTarget;\n    if (self.vars.onPress) {\n      self.vars.onPress.call(self.vars.callbackScope || self, self.pointerEvent);\n    }\n  },\n  _onMove = function (e) {\n    let self = this,\n      originalEvent = e,\n      touches,\n      i;\n    if (!self._enabled || _isMultiTouching || !self.isPressed || !e) {\n      return;\n    }\n    self.pointerEvent = e;\n    touches = e.changedTouches;\n    if (touches) {\n      //touch events store the data slightly differently\n      e = touches[0];\n      if (e !== self.touch && e.identifier !== self.touchID) {\n        //Usually changedTouches[0] will be what we\'re looking for, but in case it\'s not, look through the rest of the array...(and Android browsers don\'t reuse the event like iOS)\n        i = touches.length;\n        while (--i > -1 && (e = touches[i]).identifier !== self.touchID) {}\n        if (i < 0) {\n          return;\n        }\n      }\n    } else if (e.pointerId && self.touchID && e.pointerId !== self.touchID) {\n      //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we\'re receiving has a pointerId that doesn\'t match the touchID, ignore it (for multi-touch)\n      return;\n    }\n    _preventDefault(originalEvent);\n    self.setPointerPosition(e.pageX, e.pageY);\n    if (self.vars.onDrag) {\n      self.vars.onDrag.call(self.vars.callbackScope || self, self.pointerEvent);\n    }\n  },\n  _onRelease = function (e, force) {\n    let self = this;\n    if (!self._enabled || !self.isPressed || e && self.touchID != null && !force && (e.pointerId && e.pointerId !== self.touchID || e.changedTouches && !_hasTouchID(e.changedTouches, self.touchID))) {\n      //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we\'re receiving has a pointerId that doesn\'t match the touchID, ignore it (for multi-touch)\n      return;\n    }\n    _interacted();\n    self.isPressed = _isPressed = false; //TODO: if we want to accommodate multi-touch, we\'d need to introduce a counter to track how many touches there are and only toggle this when they\'re all off.\n    let originalEvent = e,\n      wasDragging = self.isDragging,\n      touchEventTarget = self.touchEventTarget,\n      touches,\n      i;\n    if (touchEventTarget) {\n      _removeListener(touchEventTarget, "touchend", self._onRelease);\n      _removeListener(touchEventTarget, "touchmove", self._onMove);\n      _removeListener(touchEventTarget, "touchcancel", self._onRelease);\n      _removeListener(_doc, "touchstart", _onMultiTouchDocument);\n    } else {\n      _removeListener(_doc, "mousemove", self._onMove);\n    }\n    if (!_supportsPointer) {\n      _removeListener(_doc, "mouseup", self._onRelease);\n      if (e && e.target) {\n        _removeListener(e.target, "mouseup", self._onRelease);\n      }\n    }\n    if (wasDragging) {\n      self.isDragging = false;\n    } else if (self.vars.onClick) {\n      self.vars.onClick.call(self.vars.callbackScope || self, originalEvent);\n    }\n    if (e) {\n      touches = e.changedTouches;\n      if (touches) {\n        //touch events store the data slightly differently\n        e = touches[0];\n        if (e !== self.touch && e.identifier !== self.touchID) {\n          //Usually changedTouches[0] will be what we\'re looking for, but in case it\'s not, look through the rest of the array...(and Android browsers don\'t reuse the event like iOS)\n          i = touches.length;\n          while (--i > -1 && (e = touches[i]).identifier !== self.touchID) {}\n          if (i < 0) {\n            return;\n          }\n        }\n      }\n      self.pointerEvent = originalEvent;\n      self.pointerX = e.pageX;\n      self.pointerY = e.pageY;\n    }\n    if (originalEvent && !wasDragging && self.vars.onDragRelease) {\n      self.vars.onDragRelease.call(self, self.pointerEvent);\n    } else {\n      if (originalEvent) {\n        _preventDefault(originalEvent);\n      }\n      if (self.vars.onRelease) {\n        self.vars.onRelease.call(self.vars.callbackScope || self, self.pointerEvent);\n      }\n    }\n    if (wasDragging && self.vars.onDragEnd) {\n      self.vars.onDragEnd.call(self.vars.callbackScope || self, self.pointerEvent);\n    }\n    return true;\n  },\n  _createSegmentAnchors = (rawPath, j, editor, vars) => {\n    let segment = rawPath[j],\n      l = segment.length - (segment.closed ? 6 : 0),\n      a = [],\n      i;\n    for (i = 0; i < l; i += 6) {\n      a.push(new Anchor(editor, rawPath, j, i, vars));\n    }\n    segment.closed && (a[0].isClosedStart = true);\n    return a;\n  },\n  _getLength = (segment, i, i2) => {\n    //i is the starting index, and it\'ll return the length to the next x/y pair. So if you\'re looking for the length to handle1, you\'d feed in the index of the handle control point x whereas if you\'re looking for the length to handle2, i would be the x of the anchor.\n    let x = segment[i2] - segment[i],\n      y = segment[i2 + 1] - segment[i + 1];\n    return Math.sqrt(x * x + y * y);\n  };\nclass DraggableSVG {\n  constructor(target, vars) {\n    this.target = typeof target === "string" ? _doc.querySelectorAll(target)[0] : target;\n    this.vars = vars || {};\n    this._onPress = _bind(_onPress, this);\n    this._onMove = _bind(_onMove, this);\n    this._onRelease = _bind(_onRelease, this);\n    this.target.setAttribute("transform", (this.target.getAttribute("transform") || "") + " translate(0,0)");\n    this._matrix = _getConsolidatedMatrix(this.target);\n    this.x = this._matrix.e;\n    this.y = this._matrix.f;\n    this.snap = vars.snap;\n    if (!isNaN(vars.maxX) || !isNaN(vars.minX)) {\n      this._bounds = 1;\n      this.maxX = +vars.maxX;\n      this.minX = +vars.minX;\n    } else {\n      this._bounds = 0;\n    }\n    this.enabled(true);\n  }\n  setPointerPosition(pointerX, pointerY) {\n    let rnd = 1000,\n      xChange,\n      yChange,\n      x,\n      y,\n      temp;\n    this.pointerX = pointerX;\n    this.pointerY = pointerY;\n    if (this._ctm) {\n      temp = pointerX * this._ctm.a + pointerY * this._ctm.c + this._ctm.e;\n      pointerY = pointerX * this._ctm.b + pointerY * this._ctm.d + this._ctm.f;\n      pointerX = temp;\n    }\n    yChange = pointerY - this._startPointerY;\n    xChange = pointerX - this._startPointerX;\n    if (yChange < _minimumMovement && yChange > -_minimumMovement) {\n      yChange = 0;\n    }\n    if (xChange < _minimumMovement && xChange > -_minimumMovement) {\n      xChange = 0;\n    }\n    x = ((this._startElementX + xChange) * rnd | 0) / rnd;\n    y = ((this._startElementY + yChange) * rnd | 0) / rnd;\n    if (this.snap && !_SHIFT) {\n      _point.x = x;\n      _point.y = y;\n      this.snap.call(this, _point);\n      x = _point.x;\n      y = _point.y;\n    }\n    if (this.x !== x || this.y !== y) {\n      this._matrix.f = this.y = y;\n      this._matrix.e = this.x = x;\n      if (!this.isDragging && this.isPressed) {\n        this.isDragging = true;\n        _callback("onDragStart", this, this.pointerEvent);\n      }\n    }\n  }\n  enabled(enabled) {\n    if (!arguments.length) {\n      return this._enabled;\n    }\n    let dragging;\n    this._enabled = enabled;\n    if (enabled) {\n      if (!_supportsPointer) {\n        _addListener(this.target, "mousedown", this._onPress);\n      }\n      _addListener(this.target, "touchstart", this._onPress);\n      _addListener(this.target, "click", this._onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.\n    } else {\n      dragging = this.isDragging;\n      _removeListener(this.target, "mousedown", this._onPress);\n      _removeListener(this.target, "touchstart", this._onPress);\n      _removeListener(_win, "touchforcechange", _preventDefault);\n      _removeListener(this.target, "click", this._onClick);\n      if (this.touchEventTarget) {\n        _removeListener(this.touchEventTarget, "touchcancel", this._onRelease);\n        _removeListener(this.touchEventTarget, "touchend", this._onRelease);\n        _removeListener(this.touchEventTarget, "touchmove", this._onMove);\n      }\n      _removeListener(_doc, "mouseup", this._onRelease);\n      _removeListener(_doc, "mousemove", this._onMove);\n      this.isDragging = this.isPressed = false;\n      if (dragging) {\n        _callback("onDragEnd", this, this.pointerEvent);\n      }\n    }\n    return this;\n  }\n  endDrag(e) {\n    this._onRelease(e);\n  }\n}\nclass Anchor {\n  constructor(editor, rawPath, j, i, vars) {\n    this.editor = editor;\n    this.element = _createSVG("path", editor._selection, {\n      fill: _selectionColor,\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      vectorEffect: "non-scaling-stroke"\n    });\n    this.update(rawPath, j, i);\n    this.element._gsSelection = true;\n    this.vars = vars || {};\n    this._draggable = new DraggableSVG(this.element, {\n      callbackScope: this,\n      onDrag: this.onDrag,\n      snap: this.vars.snap,\n      onPress: this.onPress,\n      onRelease: this.onRelease,\n      onClick: this.onClick,\n      onDragEnd: this.onDragEnd\n    });\n  }\n  onPress() {\n    _callback("onPress", this);\n  }\n  onClick() {\n    _callback("onClick", this);\n  }\n  onDrag() {\n    let s = this.segment;\n    this.vars.onDrag.call(this.vars.callbackScope || this, this, this._draggable.x - s[this.i], this._draggable.y - s[this.i + 1]);\n  }\n  onDragEnd() {\n    _callback("onDragEnd", this);\n  }\n  onRelease() {\n    _callback("onRelease", this);\n  }\n  update(rawPath, j, i) {\n    if (rawPath) {\n      this.rawPath = rawPath;\n    }\n    if (arguments.length <= 1) {\n      j = this.j;\n      i = this.i;\n    } else {\n      this.j = j;\n      this.i = i;\n    }\n    let prevSmooth = this.smooth,\n      segment = this.rawPath[j],\n      pi = i === 0 && segment.closed ? segment.length - 4 : i - 2;\n    this.segment = segment;\n    this.smooth = i > 0 && i < segment.length - 2 && Math.abs(Math.atan2(segment[i + 1] - segment[pi + 1], segment[i] - segment[pi]) - Math.atan2(segment[i + 3] - segment[i + 1], segment[i + 2] - segment[i])) < 0.09 ? 2 : 0; //0: corner, 1: smooth but not mirrored, 2: smooth and mirrored.\n    if (this.smooth !== prevSmooth) {\n      this.element.setAttribute("d", this.smooth ? this.editor._circleHandle : this.editor._squareHandle);\n    }\n    this.element.setAttribute("transform", "translate(" + segment[i] + "," + segment[i + 1] + ")");\n  }\n}\nclass PathEditor {\n  constructor(target, vars) {\n    vars = vars || {};\n    if (!_coreInitted) {\n      _initCore();\n    }\n    this.vars = vars;\n    this.path = typeof target === "string" ? _doc.querySelectorAll(target)[0] : target;\n    this._g = _createSVG("g", this.path.ownerSVGElement, {\n      class: "path-editor-g path-editor"\n    });\n    this._selectionHittest = _createSVG("path", this._g, {\n      stroke: "transparent",\n      strokeWidth: 16,\n      fill: "none",\n      vectorEffect: "non-scaling-stroke"\n    });\n    this._selection = vars._selection || _createSVG("g", this._g, {\n      class: "path-editor-selection path-editor"\n    });\n    this._selectionPath = _createSVG("path", this._selection, {\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      fill: "none",\n      vectorEffect: "non-scaling-stroke"\n    });\n    this._selectedAnchors = [];\n    this._line1 = _createSVG("polyline", this._selection, {\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      vectorEffect: "non-scaling-stroke"\n    });\n    this._line2 = _createSVG("polyline", this._selection, {\n      stroke: _selectionColor,\n      strokeWidth: 2,\n      vectorEffect: "non-scaling-stroke"\n    });\n    this._line1.style.pointerEvents = this._line2.style.pointerEvents = this._selectionPath.style.pointerEvents = "none";\n    this._enabled = true;\n    let ctm = this.path.parentNode.getScreenCTM().inverse(),\n      size = (ctm.a + ctm.d) / 2 * (vars.handleSize || 5);\n    this._squareHandle = _getSquarePathData(size);\n    this._circleHandle = _getCirclePathData(size * 1.15);\n    this._handle1 = _createSVG("path", this._selection, {\n      d: this._squareHandle,\n      fill: _selectionColor,\n      stroke: "transparent",\n      strokeWidth: 6\n    });\n    this._handle2 = _createSVG("path", this._selection, {\n      d: this._squareHandle,\n      fill: _selectionColor,\n      stroke: "transparent",\n      strokeWidth: 6\n    });\n    this._handle1._draggable = new DraggableSVG(this._handle1, {\n      onDrag: this._onDragHandle1,\n      callbackScope: this,\n      onPress: this._onPressHandle1,\n      onRelease: this._onReleaseHandle,\n      onClick: this._onClickHandle1,\n      snap: vars.handleSnap\n    });\n    this._handle2._draggable = new DraggableSVG(this._handle2, {\n      onDrag: this._onDragHandle2,\n      callbackScope: this,\n      onPress: this._onPressHandle2,\n      onRelease: this._onReleaseHandle,\n      onClick: this._onClickHandle2,\n      snap: vars.handleSnap\n    });\n    this._handle1.style.visibility = this._handle2.style.visibility = "hidden";\n    let selectionItems = [this._handle1, this._handle2, this._line1, this._line2, this._selection, this._selectionPath, this._selectionHittest],\n      i = selectionItems.length;\n    while (--i > -1) {\n      selectionItems[i]._gsSelection = true; //just a flag we can check in the _checkDeselect() method to detect clicks on things that are selection-related.\n    }\n    if (vars.draggable !== false) {\n      this._draggable = new DraggableSVG(this._selectionHittest, {\n        callbackScope: this,\n        onPress: this.select,\n        onRelease: this._onRelease,\n        onDrag: this._onDragPath,\n        onDragEnd: this._saveState,\n        maxX: this.vars.maxX,\n        minX: this.vars.minX\n      });\n    }\n    this.init();\n    this._selection.style.visibility = vars.selected === false ? "hidden" : "visible";\n    if (vars.selected !== false) {\n      this.path._gsSelection = true;\n      _selectedPaths.push(this);\n    }\n    this._saveState();\n    if (!_supportsPointer) {\n      _addListener(this._selectionHittest, "mousedown", _bind(this._onClickSelectionPath, this));\n      _addListener(this._selectionHittest, "mouseup", _bind(this._onRelease, this));\n    }\n    _addListener(this._selectionHittest, "touchstart", _bind(this._onClickSelectionPath, this));\n    _addListener(this._selectionHittest, "touchend", _bind(this._onRelease, this));\n  }\n  _onRelease(e) {\n    let anchor = this._editingAnchor;\n    if (anchor) {\n      _editingAxis.x = anchor.segment[anchor.i];\n      _editingAxis.y = anchor.segment[anchor.i + 1];\n    }\n    _removeListener(_win, "touchforcechange", _preventDefault); //otherwise iOS will scroll when dragging.\n    _callback("onRelease", this, e);\n  }\n  init() {\n    let pathData = this.path.getAttribute("d"),\n      rawPath = (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(pathData),\n      transform = this.path.getAttribute("transform") || "translate(0,0)",\n      createAnchors = !this._rawPath || rawPath.totalPoints !== this._rawPath.totalPoints || rawPath.length !== this._rawPath.length,\n      anchorVars = {\n        callbackScope: this,\n        snap: this.vars.anchorSnap,\n        onDrag: this._onDragAnchor,\n        onPress: this._onPressAnchor,\n        onRelease: this._onRelease,\n        onClick: this._onClickAnchor,\n        onDragEnd: this._onDragEndAnchor,\n        maxX: this.vars.maxX,\n        minX: this.vars.minX\n      },\n      l,\n      i;\n    if (createAnchors && this._anchors && this._anchors.length) {\n      for (i = 0; i < this._anchors.length; i++) {\n        this._anchors[i].element.parentNode.removeChild(this._anchors[i].element);\n        this._anchors[i]._draggable.enabled(false);\n      }\n      this._selectedAnchors.length = 0;\n    }\n    this._rawPath = rawPath;\n    if (createAnchors) {\n      this._anchors = _createSegmentAnchors(rawPath, 0, this, anchorVars);\n      l = rawPath.length;\n      if (l > 1) {\n        for (i = 1; i < l; i++) {\n          this._anchors = this._anchors.concat(_createSegmentAnchors(rawPath, i, this, anchorVars));\n        }\n      }\n    } else {\n      i = this._anchors.length;\n      while (--i > -1) {\n        this._anchors[i].update(rawPath);\n      }\n    }\n    this._selection.appendChild(this._handle1); //for stacking order (handles should always be on top)\n    this._selection.appendChild(this._handle2);\n    //\t\tthis._selectedAnchors.length = 0;\n    this._selectionPath.setAttribute("d", pathData);\n    this._selectionHittest.setAttribute("d", pathData);\n    this._g.setAttribute("transform", _getConcatenatedTransforms(this.path.parentNode) || "translate(0,0)");\n    this._selection.setAttribute("transform", transform);\n    this._selectionHittest.setAttribute("transform", transform);\n    this._updateAnchors();\n    return this;\n  }\n  _saveState() {\n    _addHistory(this);\n  }\n  _onClickSelectionPath(e) {\n    if (this._selection.style.visibility === "hidden") {\n      this.select();\n    } else if (_ALT || e && e.altKey) {\n      let anchorVars = {\n          callbackScope: this,\n          snap: this.vars.anchorSnap,\n          onDrag: this._onDragAnchor,\n          onPress: this._onPressAnchor,\n          onRelease: this._onRelease,\n          onClick: this._onClickAnchor,\n          onDragEnd: this._onDragEndAnchor,\n          maxX: this.vars.maxX,\n          minX: this.vars.minX\n        },\n        ctm = this._selection.getScreenCTM().inverse(),\n        newIndex,\n        i,\n        anchor,\n        x,\n        y,\n        closestData;\n      if (this._draggable) {\n        this._draggable._onRelease(e); //otherwise, ALT-click/dragging on a path would create a new anchor AND drag the entire path.\n      }\n      if (ctm) {\n        x = e.clientX * ctm.a + e.clientY * ctm.c + ctm.e;\n        y = e.clientX * ctm.b + e.clientY * ctm.d + ctm.f;\n      }\n      //DEBUG: _createSVG("circle", this._selection, {fill:"red", r:5, cx:x, cy:y});\n      closestData = (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.getClosestData)(this._rawPath, x, y);\n      (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.subdivideSegment)(this._rawPath[closestData.j], closestData.i, closestData.t);\n      newIndex = closestData.i + 6;\n      for (i = 0; i < this._anchors.length; i++) {\n        if (this._anchors[i].i >= newIndex) {\n          this._anchors[i].i += 6;\n        }\n      }\n      anchor = new Anchor(this, this._rawPath, closestData.j, newIndex, anchorVars);\n      this._selection.appendChild(this._handle1); //for stacking order (handles should always be on top)\n      this._selection.appendChild(this._handle2);\n      anchor._draggable._onPress(e);\n      _recentlyAddedAnchor = anchor;\n      this._anchors.push(anchor);\n      this._selectedAnchors.length = 0;\n      this._selectedAnchors.push(anchor);\n      this._updateAnchors();\n      this.update();\n      this._saveState();\n    }\n    _resetSelection();\n    _addListener(_win, "touchforcechange", _preventDefault); //otherwise iOS will scroll when dragging.\n    _callback("onPress", this);\n  }\n  _onClickHandle1() {\n    let anchor = this._editingAnchor,\n      i = anchor.i,\n      s = anchor.segment,\n      pi = anchor.isClosedStart ? s.length - 4 : i - 2;\n    if (_ALT && Math.abs(s[i] - s[pi]) < 5 && Math.abs(s[i + 1] - s[pi + 1]) < 5) {\n      this._onClickAnchor(anchor);\n    }\n  }\n  _onClickHandle2() {\n    let anchor = this._editingAnchor,\n      i = anchor.i,\n      s = anchor.segment;\n    if (_ALT && Math.abs(s[i] - s[i + 2]) < 5 && Math.abs(s[i + 1] - s[i + 3]) < 5) {\n      this._onClickAnchor(anchor);\n    }\n  }\n  _onDragEndAnchor(e) {\n    _recentlyAddedAnchor = null;\n    this._saveState();\n  }\n  isSelected() {\n    return this._selectedAnchors.length > 0;\n  }\n  select(allAnchors) {\n    this._selection.style.visibility = "visible";\n    this._editingAnchor = null;\n    this.path._gsSelection = true;\n    if (allAnchors === true) {\n      let i = this._anchors.length;\n      while (--i > -1) {\n        this._selectedAnchors[i] = this._anchors[i];\n      }\n    }\n    if (_selectedPaths.indexOf(this) === -1) {\n      _selectedPaths.push(this);\n    }\n    this._updateAnchors();\n    return this;\n  }\n  deselect() {\n    this._selection.style.visibility = "hidden";\n    this._selectedAnchors.length = 0;\n    this._editingAnchor = null;\n    this.path._gsSelection = false;\n    _selectedPaths.splice(_selectedPaths.indexOf(this), 1);\n    this._updateAnchors();\n    return this;\n  }\n  _onDragPath(e) {\n    let transform = this._selectionHittest.getAttribute("transform") || "translate(0,0)";\n    this._selection.setAttribute("transform", transform);\n    this.path.setAttribute("transform", transform);\n  }\n  _onPressAnchor(anchor) {\n    if (this._selectedAnchors.indexOf(anchor) === -1) {\n      //if it isn\'t already selected...\n      if (!_SHIFT) {\n        this._selectedAnchors.length = 0;\n      }\n      this._selectedAnchors.push(anchor);\n    } else if (_SHIFT) {\n      this._selectedAnchors.splice(this._selectedAnchors.indexOf(anchor), 1);\n      anchor._draggable.endDrag();\n    }\n    _editingAxis.x = anchor.segment[anchor.i];\n    _editingAxis.y = anchor.segment[anchor.i + 1];\n    this._updateAnchors();\n    _callback("onPress", this);\n  }\n  _deleteSelectedAnchors() {\n    let anchors = this._selectedAnchors,\n      i = anchors.length,\n      anchor,\n      index,\n      j;\n    while (--i > -1) {\n      anchor = anchors[i];\n      anchor.element.parentNode.removeChild(anchor.element);\n      anchor._draggable.enabled(false);\n      index = anchor.i;\n      if (!index) {\n        //first\n        anchor.segment.splice(index, 6);\n      } else if (index < anchor.segment.length - 2) {\n        anchor.segment.splice(index - 2, 6);\n      } else {\n        //last\n        anchor.segment.splice(index - 4, 6);\n      }\n      anchors.splice(i, 1);\n      this._anchors.splice(this._anchors.indexOf(anchor), 1);\n      for (j = 0; j < this._anchors.length; j++) {\n        if (this._anchors[j].i >= index) {\n          this._anchors[j].i -= 6;\n        }\n      }\n    }\n    this._updateAnchors();\n    this.update();\n    this._saveState();\n    if (this.vars.onDeleteAnchor) {\n      this.vars.onDeleteAnchor.call(this.vars.callbackScope || this);\n    }\n  }\n  _onClickAnchor(anchor) {\n    let i = anchor.i,\n      segment = anchor.segment,\n      pi = anchor.isClosedStart ? segment.length - 4 : i - 2,\n      rnd = 1000,\n      isEnd = !i || i >= segment.length - 2,\n      angle1,\n      angle2,\n      length1,\n      length2,\n      sin,\n      cos;\n    if (_ALT && _recentlyAddedAnchor !== anchor && this._editingAnchor) {\n      anchor.smooth = !anchor.smooth;\n      if (isEnd && !anchor.isClosedStart) {\n        //the very ends can\'t be "smooth"\n        anchor.smooth = false;\n      }\n      anchor.element.setAttribute("d", anchor.smooth ? this._circleHandle : this._squareHandle);\n      if (anchor.smooth && (!isEnd || anchor.isClosedStart)) {\n        angle1 = Math.atan2(segment[i + 1] - segment[pi + 1], segment[i] - segment[pi]);\n        angle2 = Math.atan2(segment[i + 3] - segment[i + 1], segment[i + 2] - segment[i]);\n        angle1 = (angle1 + angle2) / 2;\n        length1 = _getLength(segment, pi, i);\n        length2 = _getLength(segment, i, i + 2);\n        if (length1 < 0.2) {\n          length1 = _getLength(segment, i, pi - 4) / 4;\n          angle1 = angle2 || Math.atan2(segment[i + 7] - segment[pi - 3], segment[i + 6] - segment[pi - 4]);\n        }\n        if (length2 < 0.2) {\n          length2 = _getLength(segment, i, i + 6) / 4;\n          angle2 = angle1 || Math.atan2(segment[i + 7] - segment[pi - 3], segment[i + 6] - segment[pi - 4]);\n        }\n        sin = Math.sin(angle1);\n        cos = Math.cos(angle1);\n        if (Math.abs(angle2 - angle1) < Math.PI / 2) {\n          sin = -sin;\n          cos = -cos;\n        }\n        segment[pi] = ((segment[i] + cos * length1) * rnd | 0) / rnd;\n        segment[pi + 1] = ((segment[i + 1] + sin * length1) * rnd | 0) / rnd;\n        segment[i + 2] = ((segment[i] - cos * length2) * rnd | 0) / rnd;\n        segment[i + 3] = ((segment[i + 1] - sin * length2) * rnd | 0) / rnd;\n        this._updateAnchors();\n        this.update();\n        this._saveState();\n      } else if (!anchor.smooth && (!isEnd || anchor.isClosedStart)) {\n        if (i || anchor.isClosedStart) {\n          segment[pi] = segment[i];\n          segment[pi + 1] = segment[i + 1];\n        }\n        if (i < segment.length - 2) {\n          segment[i + 2] = segment[i];\n          segment[i + 3] = segment[i + 1];\n        }\n        this._updateAnchors();\n        this.update();\n        this._saveState();\n      }\n    } else if (!_SHIFT) {\n      this._selectedAnchors.length = 0;\n      this._selectedAnchors.push(anchor);\n    }\n    _recentlyAddedAnchor = null;\n    this._updateAnchors();\n  }\n  _updateAnchors() {\n    let anchor = this._selectedAnchors.length === 1 ? this._selectedAnchors[0] : null,\n      segment = anchor ? anchor.segment : null,\n      i,\n      x,\n      y;\n    this._editingAnchor = anchor;\n    for (i = 0; i < this._anchors.length; i++) {\n      this._anchors[i].element.style.fill = this._selectedAnchors.indexOf(this._anchors[i]) !== -1 ? _selectionColor : "white";\n      //this._anchors[i].element.setAttribute("fill", (this._selectedAnchors.indexOf(this._anchors[i]) !== -1) ? _selectionColor : "white");\n    }\n    if (anchor) {\n      this._handle1.setAttribute("d", anchor.smooth ? this._circleHandle : this._squareHandle);\n      this._handle2.setAttribute("d", anchor.smooth ? this._circleHandle : this._squareHandle);\n    }\n    i = anchor ? anchor.i : 0;\n    if (anchor && (i || anchor.isClosedStart)) {\n      x = anchor.isClosedStart ? segment[segment.length - 4] : segment[i - 2];\n      y = anchor.isClosedStart ? segment[segment.length - 3] : segment[i - 1]; //TODO: if they equal the anchor coordinates, just hide it.\n      this._handle1.style.visibility = this._line1.style.visibility = !_ALT && x === segment[i] && y === segment[i + 1] ? "hidden" : "visible";\n      this._handle1.setAttribute("transform", "translate(" + x + _comma + y + ")");\n      this._line1.setAttribute("points", x + _comma + y + _comma + segment[i] + _comma + segment[i + 1]);\n    } else {\n      this._handle1.style.visibility = this._line1.style.visibility = "hidden";\n    }\n    if (anchor && i < segment.length - 2) {\n      x = segment[i + 2];\n      y = segment[i + 3];\n      this._handle2.style.visibility = this._line2.style.visibility = !_ALT && x === segment[i] && y === segment[i + 1] ? "hidden" : "visible";\n      this._handle2.setAttribute("transform", "translate(" + x + _comma + y + ")");\n      this._line2.setAttribute("points", segment[i] + _comma + segment[i + 1] + _comma + x + _comma + y);\n    } else {\n      this._handle2.style.visibility = this._line2.style.visibility = "hidden";\n    }\n  }\n  _onPressAlt() {\n    let anchor = this._editingAnchor;\n    if (anchor) {\n      if (anchor.i || anchor.isClosedStart) {\n        this._handle1.style.visibility = this._line1.style.visibility = "visible";\n      }\n      if (anchor.i < anchor.segment.length - 2) {\n        this._handle2.style.visibility = this._line2.style.visibility = "visible";\n      }\n    }\n  }\n  _onReleaseAlt() {\n    let anchor = this._editingAnchor,\n      s,\n      i,\n      pi;\n    if (anchor) {\n      s = anchor.segment;\n      i = anchor.i;\n      pi = anchor.isClosedStart ? s.length - 4 : i - 2;\n      if (s[i] === s[pi] && s[i + 1] === s[pi + 1]) {\n        this._handle1.style.visibility = this._line1.style.visibility = "hidden";\n      }\n      if (s[i] === s[i + 2] && s[i + 1] === s[i + 3]) {\n        this._handle2.style.visibility = this._line2.style.visibility = "hidden";\n      }\n    }\n  }\n  _onPressHandle1() {\n    if (this._editingAnchor.smooth) {\n      this._oppositeHandleLength = _getLength(this._editingAnchor.segment, this._editingAnchor.i, this._editingAnchor.i + 2);\n    }\n    _callback("onPress", this);\n  }\n  _onPressHandle2() {\n    if (this._editingAnchor.smooth) {\n      this._oppositeHandleLength = _getLength(this._editingAnchor.segment, this._editingAnchor.isClosedStart ? this._editingAnchor.segment.length - 4 : this._editingAnchor.i - 2, this._editingAnchor.i);\n    }\n    _callback("onPress", this);\n  }\n  _onReleaseHandle(e) {\n    this._onRelease(e);\n    this._saveState();\n  }\n  _onDragHandle1() {\n    let anchor = this._editingAnchor,\n      s = anchor.segment,\n      i = anchor.i,\n      pi = anchor.isClosedStart ? s.length - 4 : i - 2,\n      rnd = 1000,\n      x = this._handle1._draggable.x,\n      y = this._handle1._draggable.y,\n      angle;\n    s[pi] = x = (x * rnd | 0) / rnd;\n    s[pi + 1] = y = (y * rnd | 0) / rnd;\n    if (anchor.smooth) {\n      if (_ALT) {\n        anchor.smooth = false;\n        anchor.element.setAttribute("d", this._squareHandle);\n        this._handle1.setAttribute("d", this._squareHandle);\n        this._handle2.setAttribute("d", this._squareHandle);\n      } else {\n        angle = Math.atan2(s[i + 1] - y, s[i] - x);\n        x = this._oppositeHandleLength * Math.cos(angle);\n        y = this._oppositeHandleLength * Math.sin(angle);\n        s[i + 2] = ((s[i] + x) * rnd | 0) / rnd;\n        s[i + 3] = ((s[i + 1] + y) * rnd | 0) / rnd;\n      }\n    }\n    this.update();\n  }\n  _onDragHandle2() {\n    let anchor = this._editingAnchor,\n      s = anchor.segment,\n      i = anchor.i,\n      pi = anchor.isClosedStart ? s.length - 4 : i - 2,\n      rnd = 1000,\n      x = this._handle2._draggable.x,\n      y = this._handle2._draggable.y,\n      angle;\n    s[i + 2] = x = (x * rnd | 0) / rnd;\n    s[i + 3] = y = (y * rnd | 0) / rnd;\n    if (anchor.smooth) {\n      if (_ALT) {\n        anchor.smooth = false;\n        anchor.element.setAttribute("d", this._squareHandle);\n        this._handle1.setAttribute("d", this._squareHandle);\n        this._handle2.setAttribute("d", this._squareHandle);\n      } else {\n        angle = Math.atan2(s[i + 1] - y, s[i] - x);\n        x = this._oppositeHandleLength * Math.cos(angle);\n        y = this._oppositeHandleLength * Math.sin(angle);\n        s[pi] = ((s[i] + x) * rnd | 0) / rnd;\n        s[pi + 1] = ((s[i + 1] + y) * rnd | 0) / rnd;\n      }\n    }\n    this.update();\n  }\n  _onDragAnchor(anchor, changeX, changeY) {\n    let anchors = this._selectedAnchors,\n      l = anchors.length,\n      rnd = 1000,\n      i,\n      j,\n      s,\n      a,\n      pi;\n    for (j = 0; j < l; j++) {\n      a = anchors[j];\n      i = a.i;\n      s = a.segment;\n      if (i) {\n        s[i - 2] = ((s[i - 2] + changeX) * rnd | 0) / rnd;\n        s[i - 1] = ((s[i - 1] + changeY) * rnd | 0) / rnd;\n      } else if (a.isClosedStart) {\n        pi = s.length - 2;\n        s[pi] = _round(s[pi] + changeX);\n        s[pi + 1] = _round(s[pi + 1] + changeY);\n        s[pi - 2] = _round(s[pi - 2] + changeX);\n        s[pi - 1] = _round(s[pi - 1] + changeY);\n      }\n      s[i] = ((s[i] + changeX) * rnd | 0) / rnd;\n      s[i + 1] = ((s[i + 1] + changeY) * rnd | 0) / rnd;\n      if (i < s.length - 2) {\n        s[i + 2] = ((s[i + 2] + changeX) * rnd | 0) / rnd;\n        s[i + 3] = ((s[i + 3] + changeY) * rnd | 0) / rnd;\n      }\n      if (a !== anchor) {\n        a.element.setAttribute("transform", "translate(" + s[i] + _comma + s[i + 1] + ")");\n      }\n    }\n    this.update();\n  }\n  enabled(enabled) {\n    if (!arguments.length) {\n      return this._enabled;\n    }\n    let i = this._anchors.length;\n    while (--i > -1) {\n      this._anchors[i]._draggable.enabled(enabled);\n    }\n    this._enabled = enabled;\n    this._handle1._draggable.enabled(enabled);\n    this._handle2._draggable.enabled(enabled);\n    if (this._draggable) {\n      this._draggable.enabled(enabled);\n    }\n    if (!enabled) {\n      this.deselect();\n      this.path.ownerSVGElement.removeChild(this._selectionHittest);\n      this.path.ownerSVGElement.removeChild(this._selection);\n    } else if (!this._selection.parentNode) {\n      this.path.ownerSVGElement.appendChild(this._selectionHittest);\n      this.path.ownerSVGElement.appendChild(this._selection);\n      this.init();\n      this._saveState();\n    }\n    this._updateAnchors();\n    return this.update();\n  }\n  update(readPath) {\n    let d = "",\n      anchor = this._editingAnchor,\n      i,\n      s,\n      x,\n      y,\n      pi;\n    if (readPath) {\n      this.init();\n    }\n    if (anchor) {\n      i = anchor.i;\n      s = anchor.segment;\n      if (i || anchor.isClosedStart) {\n        pi = anchor.isClosedStart ? s.length - 4 : i - 2;\n        x = s[pi];\n        y = s[pi + 1];\n        this._handle1.setAttribute("transform", "translate(" + x + _comma + y + ")");\n        this._line1.setAttribute("points", x + _comma + y + _comma + s[i] + _comma + s[i + 1]);\n      }\n      if (i < s.length - 2) {\n        x = s[i + 2];\n        y = s[i + 3];\n        this._handle2.setAttribute("transform", "translate(" + x + _comma + y + ")");\n        this._line2.setAttribute("points", s[i] + _comma + s[i + 1] + _comma + x + _comma + y);\n      }\n    }\n    if (readPath) {\n      d = this.path.getAttribute("d");\n    } else {\n      for (i = 0; i < this._rawPath.length; i++) {\n        s = this._rawPath[i];\n        if (s.length > 7) {\n          d += "M" + s[0] + _comma + s[1] + "C" + s.slice(2).join(_comma);\n        }\n      }\n      this.path.setAttribute("d", d);\n      this._selectionPath.setAttribute("d", d);\n      this._selectionHittest.setAttribute("d", d);\n    }\n    if (this.vars.onUpdate && this._enabled) {\n      _callback("onUpdate", this, d);\n    }\n    return this;\n  }\n  getRawPath(applyTransforms, offsetX, offsetY) {\n    if (applyTransforms) {\n      let m = _getConsolidatedMatrix(this.path);\n      return (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)((0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.copyRawPath)(this._rawPath), 1, 0, 0, 1, m.e + (offsetX || 0), m.f + (offsetY || 0));\n    }\n    return this._rawPath;\n  }\n  getString(applyTransforms, offsetX, offsetY) {\n    if (applyTransforms) {\n      let m = _getConsolidatedMatrix(this.path);\n      return (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)((0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)((0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.copyRawPath)(this._rawPath), 1, 0, 0, 1, m.e + (offsetX || 0), m.f + (offsetY || 0)));\n    }\n    return this.path.getAttribute("d");\n  }\n  getNormalizedSVG(height, originY, shorten, onEaseError) {\n    let s = this._rawPath[0],\n      tx = s[0] * -1,\n      ty = originY === 0 ? 0 : -(originY || s[1]),\n      l = s.length,\n      sx = 1 / (s[l - 2] + tx),\n      sy = -height || s[l - 1] + ty,\n      rnd = 1000,\n      points,\n      i,\n      x1,\n      y1,\n      x2,\n      y2;\n    _temp.length = 0;\n    if (sy) {\n      //typically y ends at 1 (so that the end values are reached)\n      sy = 1 / sy;\n    } else {\n      //in case the ease returns to its beginning value, scale everything proportionally\n      sy = -sx;\n    }\n    sx *= rnd;\n    sy *= rnd;\n    for (i = 0; i < l; i += 2) {\n      _temp[i] = ((s[i] + tx) * sx | 0) / rnd;\n      _temp[i + 1] = ((s[i + 1] + ty) * sy | 0) / rnd;\n    }\n    if (onEaseError) {\n      points = [];\n      l = _temp.length;\n      for (i = 2; i < l; i += 6) {\n        x1 = _temp[i - 2];\n        y1 = _temp[i - 1];\n        x2 = _temp[i + 4];\n        y2 = _temp[i + 5];\n        points.push(x1, y1, x2, y2);\n        (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.bezierToPoints)(x1, y1, _temp[i], _temp[i + 1], _temp[i + 2], _temp[i + 3], x2, y2, 0.001, points, points.length - 2);\n      }\n      x1 = points[0];\n      l = points.length;\n      for (i = 2; i < l; i += 2) {\n        x2 = points[i];\n        if (x2 < x1 || x2 > 1 || x2 < 0) {\n          onEaseError();\n          break;\n        }\n        x1 = x2;\n      }\n    }\n    if (shorten && l === 8 && _temp[0] === 0 && _temp[1] === 0 && _temp[l - 2] === 1 && _temp[l - 1] === 1) {\n      return _temp.slice(2, 6).join(",");\n    }\n    _temp[2] = "C" + _temp[2];\n    return "M" + _temp.join(",");\n  }\n}\nPathEditor.simplifyPoints = _paths_js__WEBPACK_IMPORTED_MODULE_0__.simplifyPoints;\nPathEditor.pointsToSegment = _paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment;\nPathEditor.simplifySVG = (data, vars) => {\n  //takes a <path> element or data string and simplifies it according to whatever tolerance you set (default:1, the bigger the number the more variance there can be). vars: {tolerance:1, cornerThreshold:degrees, curved:true}\n  let element, points, i, x1, x2, y1, y2, bezier, precision, tolerance, l, cornerThreshold;\n  vars = vars || {};\n  tolerance = vars.tolerance || 1;\n  precision = vars.precision || 1 / tolerance;\n  cornerThreshold = (vars.cornerThreshold === undefined ? 18 : +vars.cornerThreshold) * _DEG2RAD;\n  if (typeof data !== "string") {\n    //element\n    element = data;\n    data = element.getAttribute("d");\n  }\n  if (data.charAt(0) === "#" || data.charAt(0) === ".") {\n    //selector text\n    element = _doc.querySelector(data);\n    if (element) {\n      data = element.getAttribute("d");\n    }\n  }\n  points = vars.curved === false && !/[achqstvz]/ig.test(data) ? data.match(_numbersExp) : (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(data)[0];\n  if (vars.curved !== false) {\n    bezier = points;\n    points = [];\n    l = bezier.length;\n    for (i = 2; i < l; i += 6) {\n      x1 = +bezier[i - 2];\n      y1 = +bezier[i - 1];\n      x2 = +bezier[i + 4];\n      y2 = +bezier[i + 5];\n      points.push(_round(x1), _round(y1), _round(x2), _round(y2));\n      (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.bezierToPoints)(x1, y1, +bezier[i], +bezier[i + 1], +bezier[i + 2], +bezier[i + 3], x2, y2, 1 / (precision * 200000), points, points.length - 2);\n    }\n    points = (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment)((0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.simplifyPoints)(points, tolerance), vars.curviness, cornerThreshold);\n    points[2] = "C" + points[2];\n  } else {\n    points = (0,_paths_js__WEBPACK_IMPORTED_MODULE_0__.simplifyPoints)(points, tolerance);\n  }\n  data = "M" + points.join(",");\n  if (element) {\n    element.setAttribute("d", data);\n  }\n  return data;\n};\nPathEditor.create = (target, vars) => new PathEditor(target, vars);\nPathEditor.editingAxis = _editingAxis;\nPathEditor.getSnapFunction = vars => {\n  //{gridSize, radius, x, y, width, height}\n  let r = vars.radius || 2,\n    big = 1e20,\n    minX = vars.x || vars.x === 0 ? vars.x : vars.width ? 0 : -big,\n    minY = vars.y || vars.y === 0 ? vars.y : vars.height ? 0 : -big,\n    maxX = minX + (vars.width || big * big),\n    maxY = minY + (vars.height || big * big),\n    containX = vars.containX !== false,\n    containY = vars.containY !== false,\n    axis = vars.axis,\n    grid = vars.gridSize;\n  r *= r;\n  return p => {\n    let x = p.x,\n      y = p.y,\n      gridX,\n      gridY,\n      dx,\n      dy;\n    if (containX && x < minX || (dx = x - minX) * dx < r) {\n      x = minX;\n    } else if (containX && x > maxX || (dx = maxX - x) * dx < r) {\n      x = maxX;\n    }\n    if (containY && y < minY || (dy = y - minY) * dy < r) {\n      y = minY;\n    } else if (containY && y > maxY || (dy = maxY - y) * dy < r) {\n      y = maxY;\n    }\n    if (axis) {\n      dx = x - axis.x;\n      dy = y - axis.y;\n      if (dx * dx < r) {\n        x = axis.x;\n      }\n      if (dy * dy < r) {\n        y = axis.y;\n      }\n    }\n    if (grid) {\n      gridX = minX + Math.round((x - minX) / grid) * grid; //closest grid slot on x-axis\n      dx = gridX - x;\n      gridY = minY + Math.round((y - minY) / grid) * grid; //closest grid slot on y-axis\n      dy = gridY - y;\n      if (dx * dx + dy * dy < r) {\n        x = gridX;\n        y = gridY;\n      }\n    }\n    p.x = x;\n    p.y = y;\n  };\n};\nPathEditor.version = "3.6.1";\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/utils/PathEditor.js?')},"./build/scripts/vendor/gsap/src/utils/VelocityTracker.js":
/*!****************************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/utils/VelocityTracker.js ***!
  \****************************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VelocityTracker: () => (/* binding */ VelocityTracker),\n/* harmony export */   "default": () => (/* binding */ VelocityTracker)\n/* harmony export */ });\n/*!\n * VelocityTracker: 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _toArray,\n  _getUnit,\n  _first,\n  _ticker,\n  _time1,\n  _time2,\n  _getCache,\n  _getGSAP = () => gsap || typeof window !== "undefined" && (gsap = window.gsap),\n  _lookup = {},\n  _round = value => Math.round(value * 10000) / 10000,\n  _getID = target => _getCache(target).id,\n  _getByTarget = target => _lookup[_getID(typeof target === "string" ? _toArray(target)[0] : target)],\n  _onTick = time => {\n    let pt = _first,\n      val;\n    //if the frame rate is too high, we won\'t be able to track the velocity as well, so only update the values about 20 times per second\n    if (time - _time1 >= 0.05) {\n      _time2 = _time1;\n      _time1 = time;\n      while (pt) {\n        val = pt.g(pt.t, pt.p);\n        if (val !== pt.v1 || time - pt.t1 > 0.2) {\n          //use a threshold of 0.2 seconds for zeroing-out velocity. If we only use 0.05 and things update slightly slower, like some Android devices dispatch "touchmove" events sluggishly so 2 or 3 ticks of the gsap.ticker may elapse inbetween, thus it may appear like the object is not moving but it actually is but it\'s not updating as frequently. A threshold of 0.2 seconds seems to be a good balance. We want to update things frequently (0.05 seconds) when they\'re moving so that we can respond to fast motions accurately, but we want to be more resistant to go back to a zero velocity.\n          pt.v2 = pt.v1;\n          pt.v1 = val;\n          pt.t2 = pt.t1;\n          pt.t1 = time;\n        }\n        pt = pt._next;\n      }\n    }\n  },\n  _types = {\n    deg: 360,\n    rad: Math.PI * 2\n  },\n  _initCore = () => {\n    gsap = _getGSAP();\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _getUnit = gsap.utils.getUnit;\n      _getCache = gsap.core.getCache;\n      _ticker = gsap.ticker;\n      _coreInitted = 1;\n    }\n  };\nclass PropTracker {\n  constructor(target, property, type, next) {\n    this.t = target;\n    this.p = property;\n    this.g = target._gsap.get;\n    this.rCap = _types[type || _getUnit(this.g(target, property))]; //rotational cap (for degrees, "deg", it\'s 360 and for radians, "rad", it\'s Math.PI * 2)\n    this.v1 = this.v2 = 0;\n    this.t1 = this.t2 = _ticker.time;\n    if (next) {\n      this._next = next;\n      next._prev = this;\n    }\n  }\n}\nclass VelocityTracker {\n  constructor(target, property) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n    this.target = _toArray(target)[0];\n    _lookup[_getID(this.target)] = this;\n    this._props = {};\n    property && this.add(property);\n  }\n  static register(core) {\n    gsap = core;\n    _initCore();\n  }\n  get(property, skipRecentTick) {\n    let pt = this._props[property] || console.warn("Not tracking " + property + " velocity."),\n      val,\n      dif,\n      rotationCap;\n    val = parseFloat(skipRecentTick ? pt.v1 : pt.g(pt.t, pt.p));\n    dif = val - parseFloat(pt.v2);\n    rotationCap = pt.rCap;\n    if (rotationCap) {\n      //rotational values need special interpretation so that if, for example, they go from 179 to -178 degrees it is interpreted as a change of 3 instead of -357.\n      dif = dif % rotationCap;\n      if (dif !== dif % (rotationCap / 2)) {\n        dif = dif < 0 ? dif + rotationCap : dif - rotationCap;\n      }\n    }\n    return _round(dif / ((skipRecentTick ? pt.t1 : _ticker.time) - pt.t2));\n  }\n  getAll() {\n    let result = {},\n      props = this._props,\n      p;\n    for (p in props) {\n      result[p] = this.get(p);\n    }\n    return result;\n  }\n  isTracking(property) {\n    return property in this._props;\n  }\n  add(property, type) {\n    if (!(property in this._props)) {\n      if (!_first) {\n        _ticker.add(_onTick);\n        _time1 = _time2 = _ticker.time;\n      }\n      _first = this._props[property] = new PropTracker(this.target, property, type, _first);\n    }\n  }\n  remove(property) {\n    let pt = this._props[property],\n      prev,\n      next;\n    if (pt) {\n      prev = pt._prev;\n      next = pt._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      } else if (_first === pt) {\n        _ticker.remove(_onTick);\n        _first = 0;\n      }\n      delete this._props[property];\n    }\n  }\n  kill(shallow) {\n    for (let p in this._props) {\n      this.remove(p);\n    }\n    if (!shallow) {\n      delete _lookup[_getID(this.target)];\n    }\n  }\n  static track(targets, properties, types) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n    let result = [],\n      targs = _toArray(targets),\n      a = properties.split(","),\n      t = (types || "").split(","),\n      i = targs.length,\n      tracker,\n      j;\n    while (i--) {\n      tracker = _getByTarget(targs[i]) || new VelocityTracker(targs[i]);\n      j = a.length;\n      while (j--) {\n        tracker.add(a[j], t[j] || t[0]);\n      }\n      result.push(tracker);\n    }\n    return result;\n  }\n  static untrack(targets, properties) {\n    let props = (properties || "").split(",");\n    _toArray(targets).forEach(target => {\n      let tracker = _getByTarget(target);\n      if (tracker) {\n        if (!props.length) {\n          tracker.kill(1);\n        } else {\n          props.forEach(p => tracker.remove(p));\n        }\n      }\n    });\n  }\n  static isTracking(target, property) {\n    let tracker = _getByTarget(target);\n    return tracker && tracker.isTracking(property);\n  }\n  static getVelocity(target, property) {\n    let tracker = _getByTarget(target);\n    return !tracker || !tracker.isTracking(property) ? console.warn("Not tracking velocity of " + property) : tracker.get(property);\n  }\n}\nVelocityTracker.getByTarget = _getByTarget;\n_getGSAP() && gsap.registerPlugin(VelocityTracker);\n\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/utils/VelocityTracker.js?')},"./build/scripts/vendor/gsap/src/utils/matrix.js":
/*!*******************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/utils/matrix.js ***!
  \*******************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Matrix2D: () => (/* binding */ Matrix2D),\n/* harmony export */   _getDocScrollLeft: () => (/* binding */ _getDocScrollLeft),\n/* harmony export */   _getDocScrollTop: () => (/* binding */ _getDocScrollTop),\n/* harmony export */   _setDoc: () => (/* binding */ _setDoc),\n/* harmony export */   getGlobalMatrix: () => (/* binding */ getGlobalMatrix)\n/* harmony export */ });\n/*!\n * matrix 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet _doc,\n  _win,\n  _docElement,\n  _body,\n  _divContainer,\n  _svgContainer,\n  _identityMatrix,\n  _transformProp = "transform",\n  _transformOriginProp = _transformProp + "Origin",\n  _hasOffsetBug,\n  _setDoc = element => {\n    let doc = element.ownerDocument || element;\n    if (!(_transformProp in element.style) && "msTransform" in element.style) {\n      //to improve compatibility with old Microsoft browsers\n      _transformProp = "msTransform";\n      _transformOriginProp = _transformProp + "Origin";\n    }\n    while (doc.parentNode && (doc = doc.parentNode)) {}\n    _win = window;\n    _identityMatrix = new Matrix2D();\n    if (doc) {\n      _doc = doc;\n      _docElement = doc.documentElement;\n      _body = doc.body;\n      // now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon but it\'s 2020 and it\'s still not fixed.\n      let d1 = doc.createElement("div"),\n        d2 = doc.createElement("div");\n      _body.appendChild(d1);\n      d1.appendChild(d2);\n      d1.style.position = "static";\n      d1.style[_transformProp] = "translate3d(0,0,1px)";\n      _hasOffsetBug = d2.offsetParent !== d1;\n      _body.removeChild(d1);\n    }\n    return doc;\n  },\n  _forceNonZeroScale = e => {\n    // walks up the element\'s ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.\n    let a, cache;\n    while (e && e !== _body) {\n      cache = e._gsap;\n      cache && cache.uncache && cache.get(e, "x"); // force re-parsing of transforms if necessary\n      if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {\n        cache.scaleX = cache.scaleY = 1e-4;\n        cache.renderTransform(1, cache);\n        a ? a.push(cache) : a = [cache];\n      }\n      e = e.parentNode;\n    }\n    return a;\n  },\n  // possible future addition: pass an element to _forceDisplay() and it\'ll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there\'s no parentNode, it\'ll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.\n  // _forceDisplay = e => {\n  // \tlet a = [],\n  // \t\tparent;\n  // \twhile (e && e !== _body) {\n  // \t\tparent = e.parentNode;\n  // \t\t(_win.getComputedStyle(e).display === "none" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = "block");\n  // \t\tparent || _body.appendChild(e);\n  // \t\te = parent;\n  // \t}\n  // \treturn a;\n  // },\n  // _revertDisplay = a => {\n  // \tfor (let i = 0; i < a.length; i+=3) {\n  // \t\ta[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty("display");\n  // \t\ta[i+2] || a[i].parentNode.removeChild(a[i]);\n  // \t}\n  // },\n  _svgTemps = [],\n  //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.\n  _divTemps = [],\n  _getDocScrollTop = () => _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0,\n  _getDocScrollLeft = () => _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0,\n  _svgOwner = element => element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null),\n  _isFixed = element => {\n    if (_win.getComputedStyle(element).position === "fixed") {\n      return true;\n    }\n    element = element.parentNode;\n    if (element && element.nodeType === 1) {\n      // avoid document fragments which will throw an error.\n      return _isFixed(element);\n    }\n  },\n  _createSibling = (element, i) => {\n    if (element.parentNode && (_doc || _setDoc(element))) {\n      let svg = _svgOwner(element),\n        ns = svg ? svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",\n        type = svg ? i ? "rect" : "g" : "div",\n        x = i !== 2 ? 0 : 100,\n        y = i === 3 ? 100 : 0,\n        css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",\n        e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, "http"), type) : _doc.createElement(type);\n      if (i) {\n        if (!svg) {\n          if (!_divContainer) {\n            _divContainer = _createSibling(element);\n            _divContainer.style.cssText = css;\n          }\n          e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";\n          _divContainer.appendChild(e);\n        } else {\n          _svgContainer || (_svgContainer = _createSibling(element));\n          e.setAttribute("width", 0.01);\n          e.setAttribute("height", 0.01);\n          e.setAttribute("transform", "translate(" + x + "," + y + ")");\n          _svgContainer.appendChild(e);\n        }\n      }\n      return e;\n    }\n    throw "Need document and parent.";\n  },\n  _consolidate = m => {\n    // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n    let c = new Matrix2D(),\n      i = 0;\n    for (; i < m.numberOfItems; i++) {\n      c.multiply(m.getItem(i).matrix);\n    }\n    return c;\n  },\n  _placeSiblings = (element, adjustGOffset) => {\n    let svg = _svgOwner(element),\n      isRootSVG = element === svg,\n      siblings = svg ? _svgTemps : _divTemps,\n      parent = element.parentNode,\n      container,\n      m,\n      b,\n      x,\n      y,\n      cs;\n    if (element === _win) {\n      return element;\n    }\n    siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));\n    container = svg ? _svgContainer : _divContainer;\n    if (svg) {\n      b = isRootSVG ? {\n        x: 0,\n        y: 0\n      } : element.getBBox();\n      m = element.transform ? element.transform.baseVal : {}; // IE11 doesn\'t follow the spec.\n      if (m.numberOfItems) {\n        m = m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don\'t call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800\n        x = m.a * b.x + m.c * b.y;\n        y = m.b * b.x + m.d * b.y;\n      } else {\n        m = _identityMatrix;\n        x = b.x;\n        y = b.y;\n      }\n      if (adjustGOffset && element.tagName.toLowerCase() === "g") {\n        x = y = 0;\n      }\n      (isRootSVG ? svg : parent).appendChild(container);\n      container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");\n    } else {\n      x = y = 0;\n      if (_hasOffsetBug) {\n        // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it\'s supposed to treat it as if it\'s position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.\n        m = element.offsetParent;\n        b = element;\n        while (b && (b = b.parentNode) && b !== m && b.parentNode) {\n          if ((_win.getComputedStyle(b)[_transformProp] + "").length > 4) {\n            x = b.offsetLeft;\n            y = b.offsetTop;\n            b = 0;\n          }\n        }\n      }\n      cs = _win.getComputedStyle(element);\n      if (cs.position !== "absolute") {\n        m = element.offsetParent;\n        while (parent && parent !== m) {\n          // if there\'s an ancestor element between the element and its offsetParent that\'s scrolled, we must factor that in.\n          x += parent.scrollLeft || 0;\n          y += parent.scrollTop || 0;\n          parent = parent.parentNode;\n        }\n      }\n      b = container.style;\n      b.top = element.offsetTop - y + "px";\n      b.left = element.offsetLeft - x + "px";\n      b[_transformProp] = cs[_transformProp];\n      b[_transformOriginProp] = cs[_transformOriginProp];\n      // b.border = m.border;\n      // b.borderLeftStyle = m.borderLeftStyle;\n      // b.borderTopStyle = m.borderTopStyle;\n      // b.borderLeftWidth = m.borderLeftWidth;\n      // b.borderTopWidth = m.borderTopWidth;\n      b.position = cs.position === "fixed" ? "fixed" : "absolute";\n      element.parentNode.appendChild(container);\n    }\n    return container;\n  },\n  _setMatrix = (m, a, b, c, d, e, f) => {\n    m.a = a;\n    m.b = b;\n    m.c = c;\n    m.d = d;\n    m.e = e;\n    m.f = f;\n    return m;\n  };\nclass Matrix2D {\n  constructor() {\n    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    let e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    _setMatrix(this, a, b, c, d, e, f);\n  }\n  inverse() {\n    let {\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n      } = this,\n      determinant = a * d - b * c || 1e-10;\n    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);\n  }\n  multiply(matrix) {\n    let {\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n      } = this,\n      a2 = matrix.a,\n      b2 = matrix.c,\n      c2 = matrix.b,\n      d2 = matrix.d,\n      e2 = matrix.e,\n      f2 = matrix.f;\n    return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);\n  }\n  clone() {\n    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);\n  }\n  equals(matrix) {\n    let {\n      a,\n      b,\n      c,\n      d,\n      e,\n      f\n    } = this;\n    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;\n  }\n  apply(point) {\n    let decoratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let {\n        x,\n        y\n      } = point,\n      {\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n      } = this;\n    decoratee.x = x * a + y * c + e || 0;\n    decoratee.y = x * b + y * d + f || 0;\n    return decoratee;\n  }\n}\n\n// Feed in an element and it\'ll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.\n// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.\n// We needed this to work around various browser bugs, like Firefox doesn\'t accurately report getScreenCTM() when there\n// are transforms applied to ancestor elements.\n// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:\n//     tx = m.a * x + m.c * y + m.e\n//     ty = m.b * x + m.d * y + m.f\nfunction getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {\n  // adjustGOffset is typically used only when grabbing an element\'s PARENT\'s global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.\n  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {\n    return new Matrix2D();\n  }\n  let zeroScales = _forceNonZeroScale(element),\n    svg = _svgOwner(element),\n    temps = svg ? _svgTemps : _divTemps,\n    container = _placeSiblings(element, adjustGOffset),\n    b1 = temps[0].getBoundingClientRect(),\n    b2 = temps[1].getBoundingClientRect(),\n    b3 = temps[2].getBoundingClientRect(),\n    parent = container.parentNode,\n    isFixed = !includeScrollInFixed && _isFixed(element),\n    m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));\n  parent.removeChild(container);\n  if (zeroScales) {\n    b1 = zeroScales.length;\n    while (b1--) {\n      b2 = zeroScales[b1];\n      b2.scaleX = b2.scaleY = 0;\n      b2.renderTransform(1, b2);\n    }\n  }\n  return inverse ? m.inverse() : m;\n}\n\n\n// export function getMatrix(element) {\n// \t_doc || _setDoc(element);\n// \tlet m = (_win.getComputedStyle(element)[_transformProp] + "").substr(7).match(/[-.]*\\d+[.e\\-+]*\\d*[e\\-\\+]*\\d*/g),\n// \t\tis2D = m && m.length === 6;\n// \treturn !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);\n// }\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/utils/matrix.js?')},"./build/scripts/vendor/gsap/src/utils/paths.js":
/*!******************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/utils/paths.js ***!
  \******************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezierToPoints: () => (/* binding */ bezierToPoints),\n/* harmony export */   cacheRawPathMeasurements: () => (/* binding */ cacheRawPathMeasurements),\n/* harmony export */   convertToPath: () => (/* binding */ convertToPath),\n/* harmony export */   copyRawPath: () => (/* binding */ copyRawPath),\n/* harmony export */   flatPointsToSegment: () => (/* binding */ flatPointsToSegment),\n/* harmony export */   getClosestData: () => (/* binding */ getClosestData),\n/* harmony export */   getPositionOnPath: () => (/* binding */ getPositionOnPath),\n/* harmony export */   getRawPath: () => (/* binding */ getRawPath),\n/* harmony export */   getRotationAtProgress: () => (/* binding */ getRotationAtProgress),\n/* harmony export */   pointsToSegment: () => (/* binding */ pointsToSegment),\n/* harmony export */   rawPathToString: () => (/* binding */ rawPathToString),\n/* harmony export */   reverseSegment: () => (/* binding */ reverseSegment),\n/* harmony export */   simplifyPoints: () => (/* binding */ simplifyPoints),\n/* harmony export */   sliceRawPath: () => (/* binding */ sliceRawPath),\n/* harmony export */   stringToRawPath: () => (/* binding */ stringToRawPath),\n/* harmony export */   subdivideSegment: () => (/* binding */ subdivideSegment),\n/* harmony export */   subdivideSegmentNear: () => (/* binding */ subdivideSegmentNear),\n/* harmony export */   transformRawPath: () => (/* binding */ transformRawPath)\n/* harmony export */ });\n/*!\n * paths 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet _svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n  _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n  _scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\n  _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n  _DEG2RAD = Math.PI / 180,\n  _RAD2DEG = 180 / Math.PI,\n  _sin = Math.sin,\n  _cos = Math.cos,\n  _abs = Math.abs,\n  _sqrt = Math.sqrt,\n  _atan2 = Math.atan2,\n  _largeNum = 1e8,\n  _isString = value => typeof value === "string",\n  _isNumber = value => typeof value === "number",\n  _isUndefined = value => typeof value === "undefined",\n  _temp = {},\n  _temp2 = {},\n  _roundingNum = 1e5,\n  _wrapProgress = progress => Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1),\n  //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it\'s negative because it makes more sense for motion to end at 0 in that case.\n  _round = value => Math.round(value * _roundingNum) / _roundingNum || 0,\n  _roundPrecise = value => Math.round(value * 1e10) / 1e10 || 0,\n  _splitSegment = (rawPath, segIndex, i, t) => {\n    let segment = rawPath[segIndex],\n      shift = t === 1 ? 6 : subdivideSegment(segment, i, t);\n    if (shift && shift + i + 2 < segment.length) {\n      rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));\n      segment.splice(0, i + shift);\n      return 1;\n    }\n  },\n  _reverseRawPath = (rawPath, skipOuter) => {\n    let i = rawPath.length;\n    skipOuter || rawPath.reverse();\n    while (i--) {\n      rawPath[i].reversed || reverseSegment(rawPath[i]);\n    }\n  },\n  _copyMetaData = (source, copy) => {\n    copy.totalLength = source.totalLength;\n    if (source.samples) {\n      //segment\n      copy.samples = source.samples.slice(0);\n      copy.lookup = source.lookup.slice(0);\n      copy.minLength = source.minLength;\n      copy.resolution = source.resolution;\n    } else if (source.totalPoints) {\n      //rawPath\n      copy.totalPoints = source.totalPoints;\n    }\n    return copy;\n  },\n  //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it\'ll merge it into that same segment (to reduce the number of segments)\n  _appendOrMerge = (rawPath, segment) => {\n    let index = rawPath.length,\n      prevSeg = rawPath[index - 1] || [],\n      l = prevSeg.length;\n    if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {\n      segment = prevSeg.concat(segment.slice(2));\n      index--;\n    }\n    rawPath[index] = segment;\n  },\n  _bestDistance;\n\n/* TERMINOLOGY\n - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren\'t always connected).\n - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.\n - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.\n - the variable "t" is typically the position along an individual Bezier path (time) and it\'s NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn\'t really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.\n */\n\n//accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it\'ll also cache the value so that if it\'s queried again, it\'ll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn\'t changed - it\'ll check).\nfunction getRawPath(value) {\n  value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;\n  let e = value.getAttribute ? value : 0,\n    rawPath;\n  if (e && (value = value.getAttribute("d"))) {\n    //implements caching\n    if (!e._gsPath) {\n      e._gsPath = {};\n    }\n    rawPath = e._gsPath[value];\n    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);\n  }\n  return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [value] : value;\n}\n\n//copies a RawPath WITHOUT the length meta data (for speed)\nfunction copyRawPath(rawPath) {\n  let a = [],\n    i = 0;\n  for (; i < rawPath.length; i++) {\n    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));\n  }\n  return _copyMetaData(rawPath, a);\n}\nfunction reverseSegment(segment) {\n  let i = 0,\n    y;\n  segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.\n  for (; i < segment.length; i += 2) {\n    y = segment[i];\n    segment[i] = segment[i + 1];\n    segment[i + 1] = y;\n  }\n  segment.reversed = !segment.reversed;\n}\nlet _createPath = (e, ignore) => {\n    let path = document.createElementNS("http://www.w3.org/2000/svg", "path"),\n      attr = [].slice.call(e.attributes),\n      i = attr.length,\n      name;\n    ignore = "," + ignore + ",";\n    while (--i > -1) {\n      name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don\'t set the attribute with a lowercase name, it doesn\'t render correctly! Super weird.\n      if (ignore.indexOf("," + name + ",") < 0) {\n        path.setAttributeNS(null, name, attr[i].nodeValue);\n      }\n    }\n    return path;\n  },\n  _typeAttrs = {\n    rect: "rx,ry,x,y,width,height",\n    circle: "r,cx,cy",\n    ellipse: "rx,ry,cx,cy",\n    line: "x1,x2,y1,y2"\n  },\n  _attrToObj = (e, attrs) => {\n    let props = attrs ? attrs.split(",") : [],\n      obj = {},\n      i = props.length;\n    while (--i > -1) {\n      obj[props[i]] = +e.getAttribute(props[i]) || 0;\n    }\n    return obj;\n  };\n\n//converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.\nfunction convertToPath(element, swap) {\n  let type = element.tagName.toLowerCase(),\n    circ = 0.552284749831,\n    data,\n    x,\n    y,\n    r,\n    ry,\n    path,\n    rcirc,\n    rycirc,\n    points,\n    w,\n    h,\n    x2,\n    x3,\n    x4,\n    x5,\n    x6,\n    y2,\n    y3,\n    y4,\n    y5,\n    y6,\n    attr;\n  if (type === "path" || !element.getBBox) {\n    return element;\n  }\n  path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");\n  attr = _attrToObj(element, _typeAttrs[type]);\n  if (type === "rect") {\n    r = attr.rx;\n    ry = attr.ry || r;\n    x = attr.x;\n    y = attr.y;\n    w = attr.width - r * 2;\n    h = attr.height - ry * 2;\n    if (r || ry) {\n      //if there are rounded corners, render cubic beziers\n      x2 = x + r * (1 - circ);\n      x3 = x + r;\n      x4 = x3 + w;\n      x5 = x4 + r * circ;\n      x6 = x4 + r;\n      y2 = y + ry * (1 - circ);\n      y3 = y + ry;\n      y4 = y3 + h;\n      y5 = y4 + ry * circ;\n      y6 = y4 + ry;\n      data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";\n    } else {\n      data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";\n    }\n  } else if (type === "circle" || type === "ellipse") {\n    if (type === "circle") {\n      r = ry = attr.r;\n      rycirc = r * circ;\n    } else {\n      r = attr.rx;\n      ry = attr.ry;\n      rycirc = ry * circ;\n    }\n    x = attr.cx;\n    y = attr.cy;\n    rcirc = r * circ;\n    data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";\n  } else if (type === "line") {\n    data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that\'s not fully visible! Using a cubic bezier fixes that issue.\n  } else if (type === "polyline" || type === "polygon") {\n    points = (element.getAttribute("points") + "").match(_numbersExp) || [];\n    x = points.shift();\n    y = points.shift();\n    data = "M" + x + "," + y + " L" + points.join(",");\n    if (type === "polygon") {\n      data += "," + x + "," + y + "z";\n    }\n  }\n  path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));\n  if (swap && element.parentNode) {\n    element.parentNode.insertBefore(path, element);\n    element.parentNode.removeChild(element);\n  }\n  return path;\n}\n\n//returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)\nfunction getRotationAtProgress(rawPath, progress) {\n  let d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);\n  return getRotationAtBezierT(d.segment, d.i, d.t);\n}\nfunction getRotationAtBezierT(segment, i, t) {\n  let a = segment[i],\n    b = segment[i + 2],\n    c = segment[i + 4],\n    x;\n  a += (b - a) * t;\n  b += (c - b) * t;\n  a += (b - a) * t;\n  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;\n  a = segment[i + 1];\n  b = segment[i + 3];\n  c = segment[i + 5];\n  a += (b - a) * t;\n  b += (c - b) * t;\n  a += (b - a) * t;\n  return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);\n}\nfunction sliceRawPath(rawPath, start, end) {\n  end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.\n  start = _roundPrecise(start) || 0;\n  let loops = Math.max(0, ~~(_abs(end - start) - 1e-8)),\n    path = copyRawPath(rawPath);\n  if (start > end) {\n    start = 1 - start;\n    end = 1 - end;\n    _reverseRawPath(path);\n    path.totalLength = 0;\n  }\n  if (start < 0 || end < 0) {\n    let offset = Math.abs(~~Math.min(start, end)) + 1;\n    start += offset;\n    end += offset;\n  }\n  path.totalLength || cacheRawPathMeasurements(path);\n  let wrap = end > 1,\n    s = getProgressData(path, start, _temp, true),\n    e = getProgressData(path, end, _temp2),\n    eSeg = e.segment,\n    sSeg = s.segment,\n    eSegIndex = e.segIndex,\n    sSegIndex = s.segIndex,\n    ei = e.i,\n    si = s.i,\n    sameSegment = sSegIndex === eSegIndex,\n    sameBezier = ei === si && sameSegment,\n    wrapsBehind,\n    sShift,\n    eShift,\n    i,\n    copy,\n    totalSegments,\n    l,\n    j;\n  if (wrap || loops) {\n    wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;\n    if (_splitSegment(path, sSegIndex, si, s.t)) {\n      sSegIndex++;\n      if (!wrapsBehind) {\n        eSegIndex++;\n        if (sameBezier) {\n          e.t = (e.t - s.t) / (1 - s.t);\n          ei = 0;\n        } else if (sameSegment) {\n          ei -= si;\n        }\n      }\n    }\n    if (1 - (end - start) < 1e-5) {\n      eSegIndex = sSegIndex - 1;\n    } else if (!e.t && eSegIndex) {\n      eSegIndex--;\n    } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {\n      sSegIndex++;\n    }\n    if (s.t === 1) {\n      sSegIndex = (sSegIndex + 1) % path.length;\n    }\n    copy = [];\n    totalSegments = path.length;\n    l = 1 + totalSegments * loops;\n    j = sSegIndex;\n    l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;\n    for (i = 0; i < l; i++) {\n      _appendOrMerge(copy, path[j++ % totalSegments]);\n    }\n    path = copy;\n  } else {\n    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);\n    if (start !== end) {\n      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);\n      sameSegment && (eShift += sShift);\n      eSeg.splice(ei + eShift + 2);\n      (sShift || si) && sSeg.splice(0, si + sShift);\n      i = path.length;\n      while (i--) {\n        //chop off any extra segments\n        (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);\n      }\n    } else {\n      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it\'ll be impossible to determine the angle after its length is 0!\n      ei += eShift;\n      s = eSeg[ei];\n      e = eSeg[ei + 1];\n      eSeg.length = eSeg.totalLength = 0;\n      eSeg.totalPoints = path.totalPoints = 8;\n      eSeg.push(s, e, s, e, s, e, s, e);\n    }\n  }\n  path.totalLength = 0;\n  return path;\n}\n\n//measures a Segment according to its resolution (so if segment.resolution is 6, for example, it\'ll take 6 samples equally across each Bezier) and create/populate a "samples" Array that has the length up to each of those sample points (always increasing from the start) as well as a "lookup" array that\'s broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a "totalLength" property, but that\'s not generally super accurate because by default it\'ll only take 6 samples per Bezier. But for performance reasons, it\'s perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don\'t deviate by more than a certain precision value.\nfunction measureSegment(segment, startIndex, bezierQty) {\n  startIndex = startIndex || 0;\n  if (!segment.samples) {\n    segment.samples = [];\n    segment.lookup = [];\n  }\n  let resolution = ~~segment.resolution || 12,\n    inc = 1 / resolution,\n    endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,\n    x1 = segment[startIndex],\n    y1 = segment[startIndex + 1],\n    samplesIndex = startIndex ? startIndex / 6 * resolution : 0,\n    samples = segment.samples,\n    lookup = segment.lookup,\n    min = (startIndex ? segment.minLength : _largeNum) || _largeNum,\n    prevLength = samples[samplesIndex + bezierQty * resolution - 1],\n    length = startIndex ? samples[samplesIndex - 1] : 0,\n    i,\n    j,\n    x4,\n    x3,\n    x2,\n    xd,\n    xd1,\n    y4,\n    y3,\n    y2,\n    yd,\n    yd1,\n    inv,\n    t,\n    lengthIndex,\n    l,\n    segLength;\n  samples.length = lookup.length = 0;\n  for (j = startIndex + 2; j < endIndex; j += 6) {\n    x4 = segment[j + 4] - x1;\n    x3 = segment[j + 2] - x1;\n    x2 = segment[j] - x1;\n    y4 = segment[j + 5] - y1;\n    y3 = segment[j + 3] - y1;\n    y2 = segment[j + 1] - y1;\n    xd = xd1 = yd = yd1 = 0;\n    if (_abs(x4) < 1e-5 && _abs(y4) < 1e-5 && _abs(x2) + _abs(y2) < 1e-5) {\n      //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)\n      if (segment.length > 8) {\n        segment.splice(j, 6);\n        j -= 6;\n        endIndex -= 6;\n      }\n    } else {\n      for (i = 1; i <= resolution; i++) {\n        t = inc * i;\n        inv = 1 - t;\n        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);\n        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);\n        l = _sqrt(yd * yd + xd * xd);\n        if (l < min) {\n          min = l;\n        }\n        length += l;\n        samples[samplesIndex++] = length;\n      }\n    }\n    x1 += x4;\n    y1 += y4;\n  }\n  if (prevLength) {\n    prevLength -= length;\n    for (; samplesIndex < samples.length; samplesIndex++) {\n      samples[samplesIndex] += prevLength;\n    }\n  }\n  if (samples.length && min) {\n    segment.totalLength = segLength = samples[samples.length - 1] || 0;\n    segment.minLength = min;\n    l = lengthIndex = 0;\n    for (i = 0; i < segLength; i += min) {\n      lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;\n    }\n  } else {\n    segment.totalLength = samples[0] = 0;\n  }\n  return startIndex ? length - samples[startIndex / 2 - 1] : length;\n}\nfunction cacheRawPathMeasurements(rawPath, resolution) {\n  let pathLength, points, i;\n  for (i = pathLength = points = 0; i < rawPath.length; i++) {\n    rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)\n    points += rawPath[i].length;\n    pathLength += measureSegment(rawPath[i]);\n  }\n  rawPath.totalPoints = points;\n  rawPath.totalLength = pathLength;\n  return rawPath;\n}\n\n//divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)\nfunction subdivideSegment(segment, i, t) {\n  if (t <= 0 || t >= 1) {\n    return 0;\n  }\n  let ax = segment[i],\n    ay = segment[i + 1],\n    cp1x = segment[i + 2],\n    cp1y = segment[i + 3],\n    cp2x = segment[i + 4],\n    cp2y = segment[i + 5],\n    bx = segment[i + 6],\n    by = segment[i + 7],\n    x1a = ax + (cp1x - ax) * t,\n    x2 = cp1x + (cp2x - cp1x) * t,\n    y1a = ay + (cp1y - ay) * t,\n    y2 = cp1y + (cp2y - cp1y) * t,\n    x1 = x1a + (x2 - x1a) * t,\n    y1 = y1a + (y2 - y1a) * t,\n    x2a = cp2x + (bx - cp2x) * t,\n    y2a = cp2y + (by - cp2y) * t;\n  x2 += (x2a - x2) * t;\n  y2 += (y2a - y2) * t;\n  segment.splice(i + 2, 4, _round(x1a),\n  //first control point\n  _round(y1a), _round(x1),\n  //second control point\n  _round(y1), _round(x1 + (x2 - x1) * t),\n  //new fabricated anchor on line\n  _round(y1 + (y2 - y1) * t), _round(x2),\n  //third control point\n  _round(y2), _round(x2a),\n  //fourth control point\n  _round(y2a));\n  segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);\n  return 6;\n}\n\n// returns an object {path, segment, segIndex, i, t}\nfunction getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {\n  decoratee = decoratee || {};\n  rawPath.totalLength || cacheRawPathMeasurements(rawPath);\n  if (progress < 0 || progress > 1) {\n    progress = _wrapProgress(progress);\n  }\n  let segIndex = 0,\n    segment = rawPath[0],\n    samples,\n    resolution,\n    length,\n    min,\n    max,\n    i,\n    t;\n  if (!progress) {\n    t = i = segIndex = 0;\n    segment = rawPath[0];\n  } else if (progress === 1) {\n    t = 1;\n    segIndex = rawPath.length - 1;\n    segment = rawPath[segIndex];\n    i = segment.length - 8;\n  } else {\n    if (rawPath.length > 1) {\n      //speed optimization: most of the time, there\'s only one segment so skip the recursion.\n      length = rawPath.totalLength * progress;\n      max = i = 0;\n      while ((max += rawPath[i++].totalLength) < length) {\n        segIndex = i;\n      }\n      segment = rawPath[segIndex];\n      min = max - segment.totalLength;\n      progress = (length - min) / (max - min) || 0;\n    }\n    samples = segment.samples;\n    resolution = segment.resolution; //how many samples per cubic bezier chunk\n    length = segment.totalLength * progress;\n    i = segment.lookup[~~(length / segment.minLength)] || 0;\n    min = i ? samples[i - 1] : 0;\n    max = samples[i];\n    if (max < length) {\n      min = max;\n      max = samples[++i];\n    }\n    t = 1 / resolution * ((length - min) / (max - min) + i % resolution);\n    i = ~~(i / resolution) * 6;\n    if (pushToNextIfAtEnd && t === 1) {\n      if (i + 6 < segment.length) {\n        i += 6;\n        t = 0;\n      } else if (segIndex + 1 < rawPath.length) {\n        i = t = 0;\n        segment = rawPath[++segIndex];\n      }\n    }\n  }\n  decoratee.t = t;\n  decoratee.i = i;\n  decoratee.path = rawPath;\n  decoratee.segment = segment;\n  decoratee.segIndex = segIndex;\n  return decoratee;\n}\nfunction getPositionOnPath(rawPath, progress, includeAngle, point) {\n  let segment = rawPath[0],\n    result = point || {},\n    samples,\n    resolution,\n    length,\n    min,\n    max,\n    i,\n    t,\n    a,\n    inv;\n  if (progress < 0 || progress > 1) {\n    progress = _wrapProgress(progress);\n  }\n  if (rawPath.length > 1) {\n    //speed optimization: most of the time, there\'s only one segment so skip the recursion.\n    length = rawPath.totalLength * progress;\n    max = i = 0;\n    while ((max += rawPath[i++].totalLength) < length) {\n      segment = rawPath[i];\n    }\n    min = max - segment.totalLength;\n    progress = (length - min) / (max - min) || 0;\n  }\n  samples = segment.samples;\n  resolution = segment.resolution;\n  length = segment.totalLength * progress;\n  i = segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;\n  min = i ? samples[i - 1] : 0;\n  max = samples[i];\n  if (max < length) {\n    min = max;\n    max = samples[++i];\n  }\n  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;\n  inv = 1 - t;\n  i = ~~(i / resolution) * 6;\n  a = segment[i];\n  result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);\n  result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);\n  if (includeAngle) {\n    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;\n  }\n  return result;\n}\n\n//applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).\nfunction transformRawPath(rawPath, a, b, c, d, tx, ty) {\n  let j = rawPath.length,\n    segment,\n    l,\n    i,\n    x,\n    y;\n  while (--j > -1) {\n    segment = rawPath[j];\n    l = segment.length;\n    for (i = 0; i < l; i += 2) {\n      x = segment[i];\n      y = segment[i + 1];\n      segment[i] = x * a + y * c + tx;\n      segment[i + 1] = x * b + y * d + ty;\n    }\n  }\n  rawPath._dirty = 1;\n  return rawPath;\n}\n\n// translates SVG arc data into a segment (cubic beziers). Angle is in degrees.\nfunction arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n  if (lastX === x && lastY === y) {\n    return;\n  }\n  rx = _abs(rx);\n  ry = _abs(ry);\n  let angleRad = angle % 360 * _DEG2RAD,\n    cosAngle = _cos(angleRad),\n    sinAngle = _sin(angleRad),\n    PI = Math.PI,\n    TWOPI = PI * 2,\n    dx2 = (lastX - x) / 2,\n    dy2 = (lastY - y) / 2,\n    x1 = cosAngle * dx2 + sinAngle * dy2,\n    y1 = -sinAngle * dx2 + cosAngle * dy2,\n    x1_sq = x1 * x1,\n    y1_sq = y1 * y1,\n    radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n  if (radiiCheck > 1) {\n    rx = _sqrt(radiiCheck) * rx;\n    ry = _sqrt(radiiCheck) * ry;\n  }\n  let rx_sq = rx * rx,\n    ry_sq = ry * ry,\n    sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);\n  if (sq < 0) {\n    sq = 0;\n  }\n  let coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),\n    cx1 = coef * (rx * y1 / ry),\n    cy1 = coef * -(ry * x1 / rx),\n    sx2 = (lastX + x) / 2,\n    sy2 = (lastY + y) / 2,\n    cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),\n    cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),\n    ux = (x1 - cx1) / rx,\n    uy = (y1 - cy1) / ry,\n    vx = (-x1 - cx1) / rx,\n    vy = (-y1 - cy1) / ry,\n    temp = ux * ux + uy * uy,\n    angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),\n    angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n  isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.\n  if (!sweepFlag && angleExtent > 0) {\n    angleExtent -= TWOPI;\n  } else if (sweepFlag && angleExtent < 0) {\n    angleExtent += TWOPI;\n  }\n  angleStart %= TWOPI;\n  angleExtent %= TWOPI;\n  let segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),\n    rawPath = [],\n    angleIncrement = angleExtent / segments,\n    controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),\n    ma = cosAngle * rx,\n    mb = sinAngle * rx,\n    mc = sinAngle * -ry,\n    md = cosAngle * ry,\n    i;\n  for (i = 0; i < segments; i++) {\n    angle = angleStart + i * angleIncrement;\n    x1 = _cos(angle);\n    y1 = _sin(angle);\n    ux = _cos(angle += angleIncrement);\n    uy = _sin(angle);\n    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n  }\n  //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).\n  for (i = 0; i < rawPath.length; i += 2) {\n    x1 = rawPath[i];\n    y1 = rawPath[i + 1];\n    rawPath[i] = x1 * ma + y1 * mc + cx;\n    rawPath[i + 1] = x1 * mb + y1 * md + cy;\n  }\n  rawPath[i - 2] = x; //always set the end to exactly where it\'s supposed to be\n  rawPath[i - 1] = y;\n  return rawPath;\n}\n\n//Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.\nfunction stringToRawPath(d) {\n  let a = (d + "").replace(_scientific, m => {\n      let n = +m;\n      return n < 0.0001 && n > -0.0001 ? 0 : n;\n    }).match(_svgPathExp) || [],\n    //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.\n    path = [],\n    relativeX = 0,\n    relativeY = 0,\n    twoThirds = 2 / 3,\n    elements = a.length,\n    points = 0,\n    errorMessage = "ERROR: malformed path: " + d,\n    i,\n    j,\n    x,\n    y,\n    command,\n    isRelative,\n    segment,\n    startX,\n    startY,\n    difX,\n    difY,\n    beziers,\n    prevCommand,\n    flag1,\n    flag2,\n    line = function (sx, sy, ex, ey) {\n      difX = (ex - sx) / 3;\n      difY = (ey - sy) / 3;\n      segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n    };\n  if (!d || !isNaN(a[0]) || isNaN(a[1])) {\n    console.log(errorMessage);\n    return path;\n  }\n  for (i = 0; i < elements; i++) {\n    prevCommand = command;\n    if (isNaN(a[i])) {\n      command = a[i].toUpperCase();\n      isRelative = command !== a[i]; //lower case means relative\n    } else {\n      //commands like "C" can be strung together without any new command characters between.\n      i--;\n    }\n    x = +a[i + 1];\n    y = +a[i + 2];\n    if (isRelative) {\n      x += relativeX;\n      y += relativeY;\n    }\n    if (!i) {\n      startX = x;\n      startY = y;\n    }\n\n    // "M" (move)\n    if (command === "M") {\n      if (segment) {\n        if (segment.length < 8) {\n          //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n          path.length -= 1;\n        } else {\n          points += segment.length;\n        }\n      }\n      relativeX = startX = x;\n      relativeY = startY = y;\n      segment = [x, y];\n      path.push(segment);\n      i += 2;\n      command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").\n\n      // "C" (cubic bezier)\n    } else if (command === "C") {\n      if (!segment) {\n        segment = [0, 0];\n      }\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      }\n      //note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);\n      i += 6;\n\n      // "S" (continuation of cubic bezier)\n    } else if (command === "S") {\n      difX = relativeX;\n      difY = relativeY;\n      if (prevCommand === "C" || prevCommand === "S") {\n        difX += relativeX - segment[segment.length - 4];\n        difY += relativeY - segment[segment.length - 3];\n      }\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      }\n      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);\n      i += 4;\n\n      // "Q" (quadratic bezier)\n    } else if (command === "Q") {\n      difX = relativeX + (x - relativeX) * twoThirds;\n      difY = relativeY + (y - relativeY) * twoThirds;\n      if (!isRelative) {\n        relativeX = relativeY = 0;\n      }\n      relativeX += a[i + 3] * 1;\n      relativeY += a[i + 4] * 1;\n      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n      i += 4;\n\n      // "T" (continuation of quadratic bezier)\n    } else if (command === "T") {\n      difX = relativeX - segment[segment.length - 4];\n      difY = relativeY - segment[segment.length - 3];\n      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);\n      i += 2;\n\n      // "H" (horizontal line)\n    } else if (command === "H") {\n      line(relativeX, relativeY, relativeX = x, relativeY);\n      i += 1;\n\n      // "V" (vertical line)\n    } else if (command === "V") {\n      //adjust values because the first (and only one) isn\'t x in this case, it\'s y.\n      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));\n      i += 1;\n\n      // "L" (line) or "Z" (close)\n    } else if (command === "L" || command === "Z") {\n      if (command === "Z") {\n        x = startX;\n        y = startY;\n        segment.closed = true;\n      }\n      if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {\n        line(relativeX, relativeY, x, y);\n        if (command === "L") {\n          i += 2;\n        }\n      }\n      relativeX = x;\n      relativeY = y;\n\n      // "A" (arc)\n    } else if (command === "A") {\n      flag1 = a[i + 4];\n      flag2 = a[i + 5];\n      difX = a[i + 6];\n      difY = a[i + 7];\n      j = 7;\n      if (flag1.length > 1) {\n        // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)\n        if (flag1.length < 3) {\n          difY = difX;\n          difX = flag2;\n          j--;\n        } else {\n          difY = flag2;\n          difX = flag1.substr(2);\n          j -= 2;\n        }\n        flag2 = flag1.charAt(1);\n        flag1 = flag1.charAt(0);\n      }\n      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);\n      i += j;\n      if (beziers) {\n        for (j = 0; j < beziers.length; j++) {\n          segment.push(beziers[j]);\n        }\n      }\n      relativeX = segment[segment.length - 2];\n      relativeY = segment[segment.length - 1];\n    } else {\n      console.log(errorMessage);\n    }\n  }\n  i = segment.length;\n  if (i < 6) {\n    //in case there\'s odd SVG like a M0,0 command at the very end.\n    path.pop();\n    i = 0;\n  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {\n    segment.closed = true;\n  }\n  path.totalPoints = points + i;\n  return path;\n}\n\n//populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we\'re handling segment arrays\nfunction bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n  let x12 = (x1 + x2) / 2,\n    y12 = (y1 + y2) / 2,\n    x23 = (x2 + x3) / 2,\n    y23 = (y2 + y3) / 2,\n    x34 = (x3 + x4) / 2,\n    y34 = (y3 + y4) / 2,\n    x123 = (x12 + x23) / 2,\n    y123 = (y12 + y23) / 2,\n    x234 = (x23 + x34) / 2,\n    y234 = (y23 + y34) / 2,\n    x1234 = (x123 + x234) / 2,\n    y1234 = (y123 + y234) / 2,\n    dx = x4 - x1,\n    dy = y4 - y1,\n    d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx),\n    d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx),\n    length;\n  if (!points) {\n    points = [x1, y1, x4, y4];\n    index = 2;\n  }\n  points.splice(index || points.length - 2, 0, x1234, y1234);\n  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n    length = points.length;\n    bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n    bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));\n  }\n  return points;\n}\n\n/*\nfunction getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians\n\tvar dx1 = x1 - x0,\n\t\tdy1 = y1 - y0,\n\t\tdx2 = x2 - x1,\n\t\tdy2 = y2 - y1,\n\t\tdx3 = x2 - x0,\n\t\tdy3 = y2 - y0,\n\t\ta = dx1 * dx1 + dy1 * dy1,\n\t\tb = dx2 * dx2 + dy2 * dy2,\n\t\tc = dx3 * dx3 + dy3 * dy3;\n\treturn Math.acos( (a + b - c) / _sqrt(4 * a * b) );\n},\n*/\n\n//pointsToSegment() doesn\'t handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)\nfunction flatPointsToSegment(points) {\n  let curviness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let x = points[0],\n    y = 0,\n    segment = [x, y],\n    i = 2;\n  for (; i < points.length; i += 2) {\n    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);\n  }\n  return segment;\n}\n\n//points is an array of x/y points, like [x, y, x, y, x, y]\nfunction pointsToSegment(points, curviness, cornerThreshold) {\n  //points = simplifyPoints(points, tolerance);\n  _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.\n  let l = points.length - 2,\n    x = +points[0],\n    y = +points[1],\n    nextX = +points[2],\n    nextY = +points[3],\n    segment = [x, y, x, y],\n    dx2 = nextX - x,\n    dy2 = nextY - y,\n    closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001,\n    prevX,\n    prevY,\n    angle,\n    slope,\n    i,\n    dx1,\n    dx3,\n    dy1,\n    dy3,\n    d1,\n    d2,\n    a,\n    b,\n    c;\n  if (isNaN(cornerThreshold)) {\n    cornerThreshold = Math.PI / 10;\n  }\n  if (closed) {\n    // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we\'ll remove them at the end, but this allows the curvature to look perfect)\n    points.push(nextX, nextY);\n    nextX = x;\n    nextY = y;\n    x = points[l - 2];\n    y = points[l - 1];\n    points.unshift(x, y);\n    l += 4;\n  }\n  curviness = curviness || curviness === 0 ? +curviness : 1;\n  for (i = 2; i < l; i += 2) {\n    prevX = x;\n    prevY = y;\n    x = nextX;\n    y = nextY;\n    nextX = +points[i + 2];\n    nextY = +points[i + 3];\n    if (x === nextX && y === nextY) {\n      continue;\n    }\n    dx1 = dx2;\n    dy1 = dy2;\n    dx2 = nextX - x;\n    dy2 = nextY - y;\n    dx3 = nextX - prevX;\n    dy3 = nextY - prevY;\n    a = dx1 * dx1 + dy1 * dy1;\n    b = dx2 * dx2 + dy2 * dy2;\n    c = dx3 * dx3 + dy3 * dy3;\n    angle = Math.acos((a + b - c) / _sqrt(4 * a * b)); //angle between the 3 points\n    d2 = angle / Math.PI * curviness; //temporary precalculation for speed (reusing d2 variable)\n    d1 = _sqrt(a) * d2; //the tighter the angle, the shorter we make the handles in proportion.\n    d2 *= _sqrt(b);\n    if (x !== prevX || y !== prevY) {\n      if (angle > cornerThreshold) {\n        slope = _atan2(dy3, dx3);\n        segment.push(_round(x - _cos(slope) * d1),\n        //first control point\n        _round(y - _sin(slope) * d1), _round(x),\n        //anchor\n        _round(y), _round(x + _cos(slope) * d2),\n        //second control point\n        _round(y + _sin(slope) * d2));\n      } else {\n        slope = _atan2(dy1, dx1);\n        segment.push(_round(x - _cos(slope) * d1),\n        //first control point\n        _round(y - _sin(slope) * d1));\n        slope = _atan2(dy2, dx2);\n        segment.push(_round(x),\n        //anchor\n        _round(y), _round(x + _cos(slope) * d2),\n        //second control point\n        _round(y + _sin(slope) * d2));\n      }\n    }\n  }\n  x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;\n  if (closed) {\n    segment.splice(0, 6);\n    segment.length = segment.length - 6;\n  }\n  return segment;\n}\n\n//returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2\nfunction pointToSegDist(x, y, x1, y1, x2, y2) {\n  let dx = x2 - x1,\n    dy = y2 - y1,\n    t;\n  if (dx || dy) {\n    t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n  return (x - x1) ** 2 + (y - y1) ** 2;\n}\nfunction simplifyStep(points, first, last, tolerance, simplified) {\n  let maxSqDist = tolerance,\n    firstX = points[first],\n    firstY = points[first + 1],\n    lastX = points[last],\n    lastY = points[last + 1],\n    index,\n    i,\n    d;\n  for (i = first + 2; i < last; i += 2) {\n    d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);\n    if (d > maxSqDist) {\n      index = i;\n      maxSqDist = d;\n    }\n  }\n  if (maxSqDist > tolerance) {\n    index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);\n    simplified.push(points[index], points[index + 1]);\n    last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);\n  }\n}\n\n//points is an array of x/y values like [x, y, x, y, x, y]\nfunction simplifyPoints(points, tolerance) {\n  let prevX = parseFloat(points[0]),\n    prevY = parseFloat(points[1]),\n    temp = [prevX, prevY],\n    l = points.length - 2,\n    i,\n    x,\n    y,\n    dx,\n    dy,\n    result,\n    last;\n  tolerance = (tolerance || 1) ** 2;\n  for (i = 2; i < l; i += 2) {\n    x = parseFloat(points[i]);\n    y = parseFloat(points[i + 1]);\n    dx = prevX - x;\n    dy = prevY - y;\n    if (dx * dx + dy * dy > tolerance) {\n      temp.push(x, y);\n      prevX = x;\n      prevY = y;\n    }\n  }\n  temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));\n  last = temp.length - 2;\n  result = [temp[0], temp[1]];\n  simplifyStep(temp, 0, last, tolerance, result);\n  result.push(temp[last], temp[last + 1]);\n  return result;\n}\nfunction getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {\n  let inc = (end - start) / slices,\n    best = 0,\n    t = start,\n    x,\n    y,\n    d,\n    dx,\n    dy,\n    inv;\n  _bestDistance = _largeNum;\n  while (t <= end) {\n    inv = 1 - t;\n    x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;\n    y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;\n    dx = x - px;\n    dy = y - py;\n    d = dx * dx + dy * dy;\n    if (d < _bestDistance) {\n      _bestDistance = d;\n      best = t;\n    }\n    t += inc;\n  }\n  return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;\n}\nfunction getClosestData(rawPath, x, y, slices) {\n  //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)\n  let closest = {\n      j: 0,\n      i: 0,\n      t: 0\n    },\n    bestDistance = _largeNum,\n    i,\n    j,\n    t,\n    segment;\n  for (j = 0; j < rawPath.length; j++) {\n    segment = rawPath[j];\n    for (i = 0; i < segment.length; i += 6) {\n      t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n      if (bestDistance > _bestDistance) {\n        bestDistance = _bestDistance;\n        closest.j = j;\n        closest.i = i;\n        closest.t = t;\n      }\n    }\n  }\n  return closest;\n}\n\n//subdivide a Segment closest to a specific x,y coordinate\nfunction subdivideSegmentNear(x, y, segment, slices, iterations) {\n  let l = segment.length,\n    bestDistance = _largeNum,\n    bestT = 0,\n    bestSegmentIndex = 0,\n    t,\n    i;\n  slices = slices || 20;\n  iterations = iterations || 3;\n  for (i = 0; i < l; i += 6) {\n    t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);\n    if (bestDistance > _bestDistance) {\n      bestDistance = _bestDistance;\n      bestT = t;\n      bestSegmentIndex = i;\n    }\n  }\n  t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);\n  subdivideSegment(segment, bestSegmentIndex, t);\n  return bestSegmentIndex + 6;\n}\n\n/*\nTakes any of the following and converts it to an all Cubic Bezier SVG data string:\n- A <path> data string like "M0,0 L2,4 v20,15 H100"\n- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]\n- A Segment, like [x, y, x, y, x, y, x, y]\n\nNote: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13\n*/\nfunction rawPathToString(rawPath) {\n  if (_isNumber(rawPath[0])) {\n    //in case a segment is passed in instead\n    rawPath = [rawPath];\n  }\n  let result = "",\n    l = rawPath.length,\n    sl,\n    s,\n    i,\n    segment;\n  for (s = 0; s < l; s++) {\n    segment = rawPath[s];\n    result += "M" + _round(segment[0]) + "," + _round(segment[1]) + " C";\n    sl = segment.length;\n    for (i = 2; i < sl; i++) {\n      result += _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i]) + " ";\n    }\n    if (segment.closed) {\n      result += "z";\n    }\n  }\n  return result;\n}\n\n/*\n// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o\'clock to 6 o\'clock, it\'d just go directly/linearly rather than around. So the length would be very short in the middle of the tween.\nexport function cpCoordsToAngles(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tx, y, i;\n\tfor (i = 0; i < segment.length; i+=6) {\n\t\tx = segment[i+2] - segment[i];\n\t\ty = segment[i+3] - segment[i+1];\n\t\tresult[i+2] = Math.atan2(y, x);\n\t\tresult[i+3] = Math.sqrt(x * x + y * y);\n\t\tx = segment[i+6] - segment[i+4];\n\t\ty = segment[i+7] - segment[i+5];\n\t\tresult[i+4] = Math.atan2(y, x);\n\t\tresult[i+5] = Math.sqrt(x * x + y * y);\n\t}\n\treturn result;\n}\n\n// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.\nexport function cpAnglesToCoords(segment, copy) {\n\tvar result = copy ? segment.slice(0) : segment,\n\t\tlength = segment.length,\n\t\trnd = 1000,\n\t\tangle, l, i, j;\n\tfor (i = 0; i < length; i+=6) {\n\t\tangle = segment[i+2];\n\t\tl = segment[i+3]; //length\n\t\tresult[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t\tangle = segment[i+4];\n\t\tl = segment[i+5]; //length\n\t\tresult[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;\n\t\tresult[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;\n\t}\n\treturn result;\n}\n\n//adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it\'s smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\nexport function populateSmoothData(rawPath) {\n\tlet j = rawPath.length,\n\t\tsmooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;\n\twhile (--j > -1) {\n\t\tsegment = rawPath[j];\n\t\tisSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n\t\tsmoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n\t\tisSmooth.length = 4;\n\t\tl = segment.length - 2;\n\t\tfor (i = 6; i < l; i += 6) {\n\t\t\tx = segment[i] - segment[i - 2];\n\t\t\ty = segment[i + 1] - segment[i - 1];\n\t\t\tx2 = segment[i + 2] - segment[i];\n\t\t\ty2 = segment[i + 3] - segment[i + 1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tsmooth = (Math.abs(a - a2) < 0.09);\n\t\t\tif (smooth) {\n\t\t\t\tsmoothData[i - 2] = a;\n\t\t\t\tsmoothData[i + 2] = a2;\n\t\t\t\tsmoothData[i - 1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t}\n\t\t\tisSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n\t\t}\n\t\t//if the first and last points are identical, check to see if there\'s a smooth transition. We must handle this a bit differently due to their positions in the array.\n\t\tif (segment[l] === segment[0] && segment[l+1] === segment[1]) {\n\t\t\tx = segment[0] - segment[l-2];\n\t\t\ty = segment[1] - segment[l-1];\n\t\t\tx2 = segment[2] - segment[0];\n\t\t\ty2 = segment[3] - segment[1];\n\t\t\ta = _atan2(y, x);\n\t\t\ta2 = _atan2(y2, x2);\n\t\t\tif (Math.abs(a - a2) < 0.09) {\n\t\t\t\tsmoothData[l-2] = a;\n\t\t\t\tsmoothData[2] = a2;\n\t\t\t\tsmoothData[l-1] = _sqrt(x * x + y * y);\n\t\t\t\tsmoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\tisSmooth[l-2] = isSmooth[l-1] = true; //don\'t change indexes 2 and 3 because we\'ll trigger everything from the END, and this will optimize file size a bit.\n\t\t\t}\n\t\t}\n\t}\n\treturn rawPath;\n}\nexport function pointToScreen(svgElement, point) {\n\tif (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point\n\t\tlet rawPath = getRawPath(svgElement);\n\t\tpoint = svgElement.ownerSVGElement.createSVGPoint();\n\t\tpoint.x = rawPath[0][0];\n\t\tpoint.y = rawPath[0][1];\n\t}\n\treturn point.matrixTransform(svgElement.getScreenCTM());\n}\n\n*/\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/utils/paths.js?')},"./build/scripts/vendor/gsap/src/utils/strings.js":
/*!********************************************************!*\
  !*** ./build/scripts/vendor/gsap/src/utils/strings.js ***!
  \********************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   emojiExp: () => (/* binding */ emojiExp),\n/* harmony export */   emojiSafeSplit: () => (/* binding */ emojiSafeSplit),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   splitInnerHTML: () => (/* binding */ splitInnerHTML)\n/* harmony export */ });\n/*!\n * strings: 3.6.1\n * https://greensock.com\n *\n * Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet _trimExp = /(^\\s+|\\s+$)/g;\nconst emojiExp = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF](?:[\\u200D\\uFE0F][\\uD800-\\uDBFF][\\uDC00-\\uDFFF]){2,}|\\uD83D\\uDC69(?:\\u200D(?:(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67|(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC6F\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDD6-\\uDDDF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642])\\uFE0F|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708]))\\uFE0F|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83D\\uDC69\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\u200D(?:(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F)/;\nfunction getText(e) {\n  let type = e.nodeType,\n    result = "";\n  if (type === 1 || type === 9 || type === 11) {\n    if (typeof e.textContent === "string") {\n      return e.textContent;\n    } else {\n      for (e = e.firstChild; e; e = e.nextSibling) {\n        result += getText(e);\n      }\n    }\n  } else if (type === 3 || type === 4) {\n    return e.nodeValue;\n  }\n  return result;\n}\nfunction splitInnerHTML(element, delimiter, trim) {\n  let node = element.firstChild,\n    result = [];\n  while (node) {\n    if (node.nodeType === 3) {\n      result.push(...emojiSafeSplit((node.nodeValue + "").replace(/^\\n+/g, "").replace(/\\s+/g, " "), delimiter, trim));\n    } else if ((node.nodeName + "").toLowerCase() === "br") {\n      result[result.length - 1] += "<br>";\n    } else {\n      result.push(node.outerHTML);\n    }\n    node = node.nextSibling;\n  }\n  return result;\n}\n\n/*\n//smaller kb version that only handles the simpler emoji\'s, which is often perfectly adequate.\n\nlet _emoji = "[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]",\n\t_emojiExp = new RegExp(_emoji),\n\t_emojiAndCharsExp = new RegExp(_emoji + "|.", "g"),\n\t_emojiSafeSplit = (text, delimiter, trim) => {\n\t\tif (trim) {\n\t\t\ttext = text.replace(_trimExp, "");\n\t\t}\n\t\treturn ((delimiter === "" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || "");\n\t};\n */\nfunction emojiSafeSplit(text, delimiter, trim) {\n  text += ""; // make sure it\'s cast as a string. Someone may pass in a number.\n  if (trim) {\n    text = text.replace(_trimExp, "");\n  }\n  if (delimiter && delimiter !== "") {\n    return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);\n  }\n  let result = [],\n    l = text.length,\n    i = 0,\n    j,\n    character;\n  for (; i < l; i++) {\n    character = text.charAt(i);\n    if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n      //special emoji characters use 2 or 4 unicode characters that we must keep together.\n      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;\n      character = text.substr(i, j);\n      result.emoji = 1;\n      i += j - 1;\n    }\n    result.push(character === ">" ? "&gt;" : character === "<" ? "&lt;" : character);\n  }\n  return result;\n}\n\n//# sourceURL=webpack://saasymail/./build/scripts/vendor/gsap/src/utils/strings.js?')},"./node_modules/bootstrap/dist/js/bootstrap.js":
/*!*****************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \*****************************************************/function(__unused_webpack_module,exports,__webpack_require__){eval('/*!\n  * Bootstrap v4.6.2 (https://getbootstrap.com/)\n  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! jquery */ "jquery"), __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js")) :\n  0;\n})(this, (function (exports, $, Popper) { \'use strict\';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === \'object\' && \'default\' in e ? e : { \'default\': e }; }\n\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n  var Popper__default = /*#__PURE__*/_interopDefaultLegacy(Popper);\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, "prototype", {\n      writable: false\n    });\n    return Constructor;\n  }\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n\n    _setPrototypeOf(subClass, superClass);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.2): util.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Private TransitionEnd Helpers\n   */\n\n  var TRANSITION_END = \'transitionend\';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    if (obj === null || typeof obj === \'undefined\') {\n      return "" + obj;\n    }\n\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($__default["default"](event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined;\n      }\n    };\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n    $__default["default"](this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    $__default["default"].fn.emulateTransitionEnd = transitionEndEmulator;\n    $__default["default"].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * Public Util API\n   */\n\n\n  var Util = {\n    TRANSITION_END: \'bsTransitionEnd\',\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute(\'data-target\');\n\n      if (!selector || selector === \'#\') {\n        var hrefAttr = element.getAttribute(\'href\');\n        selector = hrefAttr && hrefAttr !== \'#\' ? hrefAttr.trim() : \'\';\n      }\n\n      try {\n        return document.querySelector(selector) ? selector : null;\n      } catch (_) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n\n      var transitionDuration = $__default["default"](element).css(\'transition-duration\');\n      var transitionDelay = $__default["default"](element).css(\'transition-delay\');\n      var floatTransitionDuration = parseFloat(transitionDuration);\n      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration && !floatTransitionDelay) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n\n      transitionDuration = transitionDuration.split(\',\')[0];\n      transitionDelay = transitionDelay.split(\',\')[0];\n      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $__default["default"](element).trigger(TRANSITION_END);\n    },\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? \'element\' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + ": " + ("Option \\"" + property + "\\" provided type \\"" + valueType + "\\" ") + ("but expected type \\"" + expectedTypes + "\\"."));\n          }\n        }\n      }\n    },\n    findShadowRoot: function findShadowRoot(element) {\n      if (!document.documentElement.attachShadow) {\n        return null;\n      } // Can find the shadow root otherwise it\'ll return the document\n\n\n      if (typeof element.getRootNode === \'function\') {\n        var root = element.getRootNode();\n        return root instanceof ShadowRoot ? root : null;\n      }\n\n      if (element instanceof ShadowRoot) {\n        return element;\n      } // when we don\'t find a shadow root\n\n\n      if (!element.parentNode) {\n        return null;\n      }\n\n      return Util.findShadowRoot(element.parentNode);\n    },\n    jQueryDetection: function jQueryDetection() {\n      if (typeof $__default["default"] === \'undefined\') {\n        throw new TypeError(\'Bootstrap\\\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\\\'s JavaScript.\');\n      }\n\n      var version = $__default["default"].fn.jquery.split(\' \')[0].split(\'.\');\n      var minMajor = 1;\n      var ltMajor = 2;\n      var minMinor = 9;\n      var minPatch = 1;\n      var maxMajor = 4;\n\n      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {\n        throw new Error(\'Bootstrap\\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0\');\n      }\n    }\n  };\n  Util.jQueryDetection();\n  setTransitionEndSupport();\n\n  /**\n   * Constants\n   */\n\n  var NAME$a = \'alert\';\n  var VERSION$a = \'4.6.2\';\n  var DATA_KEY$a = \'bs.alert\';\n  var EVENT_KEY$a = "." + DATA_KEY$a;\n  var DATA_API_KEY$7 = \'.data-api\';\n  var JQUERY_NO_CONFLICT$a = $__default["default"].fn[NAME$a];\n  var CLASS_NAME_ALERT = \'alert\';\n  var CLASS_NAME_FADE$5 = \'fade\';\n  var CLASS_NAME_SHOW$7 = \'show\';\n  var EVENT_CLOSE = "close" + EVENT_KEY$a;\n  var EVENT_CLOSED = "closed" + EVENT_KEY$a;\n  var EVENT_CLICK_DATA_API$6 = "click" + EVENT_KEY$a + DATA_API_KEY$7;\n  var SELECTOR_DISMISS = \'[data-dismiss="alert"]\';\n  /**\n   * Class definition\n   */\n\n  var Alert = /*#__PURE__*/function () {\n    function Alert(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Alert.prototype;\n\n    // Public\n    _proto.close = function close(element) {\n      var rootElement = this._element;\n\n      if (element) {\n        rootElement = this._getRootElement(element);\n      }\n\n      var customEvent = this._triggerCloseEvent(rootElement);\n\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._removeElement(rootElement);\n    };\n\n    _proto.dispose = function dispose() {\n      $__default["default"].removeData(this._element, DATA_KEY$a);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._getRootElement = function _getRootElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      var parent = false;\n\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n\n      if (!parent) {\n        parent = $__default["default"](element).closest("." + CLASS_NAME_ALERT)[0];\n      }\n\n      return parent;\n    };\n\n    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {\n      var closeEvent = $__default["default"].Event(EVENT_CLOSE);\n      $__default["default"](element).trigger(closeEvent);\n      return closeEvent;\n    };\n\n    _proto._removeElement = function _removeElement(element) {\n      var _this = this;\n\n      $__default["default"](element).removeClass(CLASS_NAME_SHOW$7);\n\n      if (!$__default["default"](element).hasClass(CLASS_NAME_FADE$5)) {\n        this._destroyElement(element);\n\n        return;\n      }\n\n      var transitionDuration = Util.getTransitionDurationFromElement(element);\n      $__default["default"](element).one(Util.TRANSITION_END, function (event) {\n        return _this._destroyElement(element, event);\n      }).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto._destroyElement = function _destroyElement(element) {\n      $__default["default"](element).detach().trigger(EVENT_CLOSED).remove();\n    } // Static\n    ;\n\n    Alert._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default["default"](this);\n        var data = $element.data(DATA_KEY$a);\n\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY$a, data);\n        }\n\n        if (config === \'close\') {\n          data[config](this);\n        }\n      });\n    };\n\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n\n        alertInstance.close(this);\n      };\n    };\n\n    _createClass(Alert, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$a;\n      }\n    }]);\n\n    return Alert;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$a] = Alert._jQueryInterface;\n  $__default["default"].fn[NAME$a].Constructor = Alert;\n\n  $__default["default"].fn[NAME$a].noConflict = function () {\n    $__default["default"].fn[NAME$a] = JQUERY_NO_CONFLICT$a;\n    return Alert._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$9 = \'button\';\n  var VERSION$9 = \'4.6.2\';\n  var DATA_KEY$9 = \'bs.button\';\n  var EVENT_KEY$9 = "." + DATA_KEY$9;\n  var DATA_API_KEY$6 = \'.data-api\';\n  var JQUERY_NO_CONFLICT$9 = $__default["default"].fn[NAME$9];\n  var CLASS_NAME_ACTIVE$3 = \'active\';\n  var CLASS_NAME_BUTTON = \'btn\';\n  var CLASS_NAME_FOCUS = \'focus\';\n  var EVENT_CLICK_DATA_API$5 = "click" + EVENT_KEY$9 + DATA_API_KEY$6;\n  var EVENT_FOCUS_BLUR_DATA_API = "focus" + EVENT_KEY$9 + DATA_API_KEY$6 + " " + ("blur" + EVENT_KEY$9 + DATA_API_KEY$6);\n  var EVENT_LOAD_DATA_API$2 = "load" + EVENT_KEY$9 + DATA_API_KEY$6;\n  var SELECTOR_DATA_TOGGLE_CARROT = \'[data-toggle^="button"]\';\n  var SELECTOR_DATA_TOGGLES = \'[data-toggle="buttons"]\';\n  var SELECTOR_DATA_TOGGLE$4 = \'[data-toggle="button"]\';\n  var SELECTOR_DATA_TOGGLES_BUTTONS = \'[data-toggle="buttons"] .btn\';\n  var SELECTOR_INPUT = \'input:not([type="hidden"])\';\n  var SELECTOR_ACTIVE$2 = \'.active\';\n  var SELECTOR_BUTTON = \'.btn\';\n  /**\n   * Class definition\n   */\n\n  var Button = /*#__PURE__*/function () {\n    function Button(element) {\n      this._element = element;\n      this.shouldAvoidTriggerChange = false;\n    } // Getters\n\n\n    var _proto = Button.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      var triggerChangeEvent = true;\n      var addAriaPressed = true;\n      var rootElement = $__default["default"](this._element).closest(SELECTOR_DATA_TOGGLES)[0];\n\n      if (rootElement) {\n        var input = this._element.querySelector(SELECTOR_INPUT);\n\n        if (input) {\n          if (input.type === \'radio\') {\n            if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE$3)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = rootElement.querySelector(SELECTOR_ACTIVE$2);\n\n              if (activeElement) {\n                $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$3);\n              }\n            }\n          }\n\n          if (triggerChangeEvent) {\n            // if it\'s not a radio button or checkbox don\'t add a pointless/invalid checked property to the input\n            if (input.type === \'checkbox\' || input.type === \'radio\') {\n              input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE$3);\n            }\n\n            if (!this.shouldAvoidTriggerChange) {\n              $__default["default"](input).trigger(\'change\');\n            }\n          }\n\n          input.focus();\n          addAriaPressed = false;\n        }\n      }\n\n      if (!(this._element.hasAttribute(\'disabled\') || this._element.classList.contains(\'disabled\'))) {\n        if (addAriaPressed) {\n          this._element.setAttribute(\'aria-pressed\', !this._element.classList.contains(CLASS_NAME_ACTIVE$3));\n        }\n\n        if (triggerChangeEvent) {\n          $__default["default"](this._element).toggleClass(CLASS_NAME_ACTIVE$3);\n        }\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $__default["default"].removeData(this._element, DATA_KEY$9);\n      this._element = null;\n    } // Static\n    ;\n\n    Button._jQueryInterface = function _jQueryInterface(config, avoidTriggerChange) {\n      return this.each(function () {\n        var $element = $__default["default"](this);\n        var data = $element.data(DATA_KEY$9);\n\n        if (!data) {\n          data = new Button(this);\n          $element.data(DATA_KEY$9, data);\n        }\n\n        data.shouldAvoidTriggerChange = avoidTriggerChange;\n\n        if (config === \'toggle\') {\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Button, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$9;\n      }\n    }]);\n\n    return Button;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = event.target;\n    var initialButton = button;\n\n    if (!$__default["default"](button).hasClass(CLASS_NAME_BUTTON)) {\n      button = $__default["default"](button).closest(SELECTOR_BUTTON)[0];\n    }\n\n    if (!button || button.hasAttribute(\'disabled\') || button.classList.contains(\'disabled\')) {\n      event.preventDefault(); // work around Firefox bug #1540995\n    } else {\n      var inputBtn = button.querySelector(SELECTOR_INPUT);\n\n      if (inputBtn && (inputBtn.hasAttribute(\'disabled\') || inputBtn.classList.contains(\'disabled\'))) {\n        event.preventDefault(); // work around Firefox bug #1540995\n\n        return;\n      }\n\n      if (initialButton.tagName === \'INPUT\' || button.tagName !== \'LABEL\') {\n        Button._jQueryInterface.call($__default["default"](button), \'toggle\', initialButton.tagName === \'INPUT\');\n      }\n    }\n  }).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = $__default["default"](event.target).closest(SELECTOR_BUTTON)[0];\n    $__default["default"](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));\n  });\n  $__default["default"](window).on(EVENT_LOAD_DATA_API$2, function () {\n    // ensure correct active class is set to match the controls\' actual values/states\n    // find all checkboxes/readio buttons inside data-toggle groups\n    var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));\n\n    for (var i = 0, len = buttons.length; i < len; i++) {\n      var button = buttons[i];\n      var input = button.querySelector(SELECTOR_INPUT);\n\n      if (input.checked || input.hasAttribute(\'checked\')) {\n        button.classList.add(CLASS_NAME_ACTIVE$3);\n      } else {\n        button.classList.remove(CLASS_NAME_ACTIVE$3);\n      }\n    } // find all button toggles\n\n\n    buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$4));\n\n    for (var _i = 0, _len = buttons.length; _i < _len; _i++) {\n      var _button = buttons[_i];\n\n      if (_button.getAttribute(\'aria-pressed\') === \'true\') {\n        _button.classList.add(CLASS_NAME_ACTIVE$3);\n      } else {\n        _button.classList.remove(CLASS_NAME_ACTIVE$3);\n      }\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$9] = Button._jQueryInterface;\n  $__default["default"].fn[NAME$9].Constructor = Button;\n\n  $__default["default"].fn[NAME$9].noConflict = function () {\n    $__default["default"].fn[NAME$9] = JQUERY_NO_CONFLICT$9;\n    return Button._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$8 = \'carousel\';\n  var VERSION$8 = \'4.6.2\';\n  var DATA_KEY$8 = \'bs.carousel\';\n  var EVENT_KEY$8 = "." + DATA_KEY$8;\n  var DATA_API_KEY$5 = \'.data-api\';\n  var JQUERY_NO_CONFLICT$8 = $__default["default"].fn[NAME$8];\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\n\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\n\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var SWIPE_THRESHOLD = 40;\n  var CLASS_NAME_CAROUSEL = \'carousel\';\n  var CLASS_NAME_ACTIVE$2 = \'active\';\n  var CLASS_NAME_SLIDE = \'slide\';\n  var CLASS_NAME_RIGHT = \'carousel-item-right\';\n  var CLASS_NAME_LEFT = \'carousel-item-left\';\n  var CLASS_NAME_NEXT = \'carousel-item-next\';\n  var CLASS_NAME_PREV = \'carousel-item-prev\';\n  var CLASS_NAME_POINTER_EVENT = \'pointer-event\';\n  var DIRECTION_NEXT = \'next\';\n  var DIRECTION_PREV = \'prev\';\n  var DIRECTION_LEFT = \'left\';\n  var DIRECTION_RIGHT = \'right\';\n  var EVENT_SLIDE = "slide" + EVENT_KEY$8;\n  var EVENT_SLID = "slid" + EVENT_KEY$8;\n  var EVENT_KEYDOWN = "keydown" + EVENT_KEY$8;\n  var EVENT_MOUSEENTER = "mouseenter" + EVENT_KEY$8;\n  var EVENT_MOUSELEAVE = "mouseleave" + EVENT_KEY$8;\n  var EVENT_TOUCHSTART = "touchstart" + EVENT_KEY$8;\n  var EVENT_TOUCHMOVE = "touchmove" + EVENT_KEY$8;\n  var EVENT_TOUCHEND = "touchend" + EVENT_KEY$8;\n  var EVENT_POINTERDOWN = "pointerdown" + EVENT_KEY$8;\n  var EVENT_POINTERUP = "pointerup" + EVENT_KEY$8;\n  var EVENT_DRAG_START = "dragstart" + EVENT_KEY$8;\n  var EVENT_LOAD_DATA_API$1 = "load" + EVENT_KEY$8 + DATA_API_KEY$5;\n  var EVENT_CLICK_DATA_API$4 = "click" + EVENT_KEY$8 + DATA_API_KEY$5;\n  var SELECTOR_ACTIVE$1 = \'.active\';\n  var SELECTOR_ACTIVE_ITEM = \'.active.carousel-item\';\n  var SELECTOR_ITEM = \'.carousel-item\';\n  var SELECTOR_ITEM_IMG = \'.carousel-item img\';\n  var SELECTOR_NEXT_PREV = \'.carousel-item-next, .carousel-item-prev\';\n  var SELECTOR_INDICATORS = \'.carousel-indicators\';\n  var SELECTOR_DATA_SLIDE = \'[data-slide], [data-slide-to]\';\n  var SELECTOR_DATA_RIDE = \'[data-ride="carousel"]\';\n  var Default$7 = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: \'hover\',\n    wrap: true,\n    touch: true\n  };\n  var DefaultType$7 = {\n    interval: \'(number|boolean)\',\n    keyboard: \'boolean\',\n    slide: \'(boolean|string)\',\n    pause: \'(string|boolean)\',\n    wrap: \'boolean\',\n    touch: \'boolean\'\n  };\n  var PointerType = {\n    TOUCH: \'touch\',\n    PEN: \'pen\'\n  };\n  /**\n   * Class definition\n   */\n\n  var Carousel = /*#__PURE__*/function () {\n    function Carousel(element, config) {\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n      this._isPaused = false;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this.touchStartX = 0;\n      this.touchDeltaX = 0;\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);\n      this._touchSupported = \'ontouchstart\' in document.documentElement || navigator.maxTouchPoints > 0;\n      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Carousel.prototype;\n\n    // Public\n    _proto.next = function next() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_NEXT);\n      }\n    };\n\n    _proto.nextWhenVisible = function nextWhenVisible() {\n      var $element = $__default["default"](this._element); // Don\'t call next when the page isn\'t visible\n      // or the carousel or its parent isn\'t visible\n\n      if (!document.hidden && $element.is(\':visible\') && $element.css(\'visibility\') !== \'hidden\') {\n        this.next();\n      }\n    };\n\n    _proto.prev = function prev() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_PREV);\n      }\n    };\n\n    _proto.pause = function pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n\n      if (this._element.querySelector(SELECTOR_NEXT_PREV)) {\n        Util.triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n\n      clearInterval(this._interval);\n      this._interval = null;\n    };\n\n    _proto.cycle = function cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n\n      if (this._config.interval && !this._isPaused) {\n        this._updateInterval();\n\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    };\n\n    _proto.to = function to(index) {\n      var _this = this;\n\n      this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n\n      var activeIndex = this._getItemIndex(this._activeElement);\n\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        $__default["default"](this._element).one(EVENT_SLID, function () {\n          return _this.to(index);\n        });\n        return;\n      }\n\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n\n      var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;\n\n      this._slide(direction, this._items[index]);\n    };\n\n    _proto.dispose = function dispose() {\n      $__default["default"](this._element).off(EVENT_KEY$8);\n      $__default["default"].removeData(this._element, DATA_KEY$8);\n      this._items = null;\n      this._config = null;\n      this._element = null;\n      this._interval = null;\n      this._isPaused = null;\n      this._isSliding = null;\n      this._activeElement = null;\n      this._indicatorsElement = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$7, config);\n      Util.typeCheckConfig(NAME$8, config, DefaultType$7);\n      return config;\n    };\n\n    _proto._handleSwipe = function _handleSwipe() {\n      var absDeltax = Math.abs(this.touchDeltaX);\n\n      if (absDeltax <= SWIPE_THRESHOLD) {\n        return;\n      }\n\n      var direction = absDeltax / this.touchDeltaX;\n      this.touchDeltaX = 0; // swipe left\n\n      if (direction > 0) {\n        this.prev();\n      } // swipe right\n\n\n      if (direction < 0) {\n        this.next();\n      }\n    };\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this2 = this;\n\n      if (this._config.keyboard) {\n        $__default["default"](this._element).on(EVENT_KEYDOWN, function (event) {\n          return _this2._keydown(event);\n        });\n      }\n\n      if (this._config.pause === \'hover\') {\n        $__default["default"](this._element).on(EVENT_MOUSEENTER, function (event) {\n          return _this2.pause(event);\n        }).on(EVENT_MOUSELEAVE, function (event) {\n          return _this2.cycle(event);\n        });\n      }\n\n      if (this._config.touch) {\n        this._addTouchEventListeners();\n      }\n    };\n\n    _proto._addTouchEventListeners = function _addTouchEventListeners() {\n      var _this3 = this;\n\n      if (!this._touchSupported) {\n        return;\n      }\n\n      var start = function start(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchStartX = event.originalEvent.clientX;\n        } else if (!_this3._pointerEvent) {\n          _this3.touchStartX = event.originalEvent.touches[0].clientX;\n        }\n      };\n\n      var move = function move(event) {\n        // ensure swiping with one touch and not pinching\n        _this3.touchDeltaX = event.originalEvent.touches && event.originalEvent.touches.length > 1 ? 0 : event.originalEvent.touches[0].clientX - _this3.touchStartX;\n      };\n\n      var end = function end(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;\n        }\n\n        _this3._handleSwipe();\n\n        if (_this3._config.pause === \'hover\') {\n          // If it\'s a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it\'s the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n          _this3.pause();\n\n          if (_this3.touchTimeout) {\n            clearTimeout(_this3.touchTimeout);\n          }\n\n          _this3.touchTimeout = setTimeout(function (event) {\n            return _this3.cycle(event);\n          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);\n        }\n      };\n\n      $__default["default"](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function (e) {\n        return e.preventDefault();\n      });\n\n      if (this._pointerEvent) {\n        $__default["default"](this._element).on(EVENT_POINTERDOWN, function (event) {\n          return start(event);\n        });\n        $__default["default"](this._element).on(EVENT_POINTERUP, function (event) {\n          return end(event);\n        });\n\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n      } else {\n        $__default["default"](this._element).on(EVENT_TOUCHSTART, function (event) {\n          return start(event);\n        });\n        $__default["default"](this._element).on(EVENT_TOUCHMOVE, function (event) {\n          return move(event);\n        });\n        $__default["default"](this._element).on(EVENT_TOUCHEND, function (event) {\n          return end(event);\n        });\n      }\n    };\n\n    _proto._keydown = function _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      switch (event.which) {\n        case ARROW_LEFT_KEYCODE:\n          event.preventDefault();\n          this.prev();\n          break;\n\n        case ARROW_RIGHT_KEYCODE:\n          event.preventDefault();\n          this.next();\n          break;\n      }\n    };\n\n    _proto._getItemIndex = function _getItemIndex(element) {\n      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];\n      return this._items.indexOf(element);\n    };\n\n    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {\n      var isNextDirection = direction === DIRECTION_NEXT;\n      var isPrevDirection = direction === DIRECTION_PREV;\n\n      var activeIndex = this._getItemIndex(activeElement);\n\n      var lastItemIndex = this._items.length - 1;\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\n\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n\n      var delta = direction === DIRECTION_PREV ? -1 : 1;\n      var itemIndex = (activeIndex + delta) % this._items.length;\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    };\n\n    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      var targetIndex = this._getItemIndex(relatedTarget);\n\n      var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));\n\n      var slideEvent = $__default["default"].Event(EVENT_SLIDE, {\n        relatedTarget: relatedTarget,\n        direction: eventDirectionName,\n        from: fromIndex,\n        to: targetIndex\n      });\n      $__default["default"](this._element).trigger(slideEvent);\n      return slideEvent;\n    };\n\n    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));\n        $__default["default"](indicators).removeClass(CLASS_NAME_ACTIVE$2);\n\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\n\n        if (nextIndicator) {\n          $__default["default"](nextIndicator).addClass(CLASS_NAME_ACTIVE$2);\n        }\n      }\n    };\n\n    _proto._updateInterval = function _updateInterval() {\n      var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n\n      if (!element) {\n        return;\n      }\n\n      var elementInterval = parseInt(element.getAttribute(\'data-interval\'), 10);\n\n      if (elementInterval) {\n        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n        this._config.interval = elementInterval;\n      } else {\n        this._config.interval = this._config.defaultInterval || this._config.interval;\n      }\n    };\n\n    _proto._slide = function _slide(direction, element) {\n      var _this4 = this;\n\n      var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n\n      var activeElementIndex = this._getItemIndex(activeElement);\n\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\n\n      var nextElementIndex = this._getItemIndex(nextElement);\n\n      var isCycling = Boolean(this._interval);\n      var directionalClassName;\n      var orderClassName;\n      var eventDirectionName;\n\n      if (direction === DIRECTION_NEXT) {\n        directionalClassName = CLASS_NAME_LEFT;\n        orderClassName = CLASS_NAME_NEXT;\n        eventDirectionName = DIRECTION_LEFT;\n      } else {\n        directionalClassName = CLASS_NAME_RIGHT;\n        orderClassName = CLASS_NAME_PREV;\n        eventDirectionName = DIRECTION_RIGHT;\n      }\n\n      if (nextElement && $__default["default"](nextElement).hasClass(CLASS_NAME_ACTIVE$2)) {\n        this._isSliding = false;\n        return;\n      }\n\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n      if (slideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        return;\n      }\n\n      this._isSliding = true;\n\n      if (isCycling) {\n        this.pause();\n      }\n\n      this._setActiveIndicatorElement(nextElement);\n\n      this._activeElement = nextElement;\n      var slidEvent = $__default["default"].Event(EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n\n      if ($__default["default"](this._element).hasClass(CLASS_NAME_SLIDE)) {\n        $__default["default"](nextElement).addClass(orderClassName);\n        Util.reflow(nextElement);\n        $__default["default"](activeElement).addClass(directionalClassName);\n        $__default["default"](nextElement).addClass(directionalClassName);\n        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);\n        $__default["default"](activeElement).one(Util.TRANSITION_END, function () {\n          $__default["default"](nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(CLASS_NAME_ACTIVE$2);\n          $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2 + " " + orderClassName + " " + directionalClassName);\n          _this4._isSliding = false;\n          setTimeout(function () {\n            return $__default["default"](_this4._element).trigger(slidEvent);\n          }, 0);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2);\n        $__default["default"](nextElement).addClass(CLASS_NAME_ACTIVE$2);\n        this._isSliding = false;\n        $__default["default"](this._element).trigger(slidEvent);\n      }\n\n      if (isCycling) {\n        this.cycle();\n      }\n    } // Static\n    ;\n\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default["default"](this).data(DATA_KEY$8);\n\n        var _config = _extends({}, Default$7, $__default["default"](this).data());\n\n        if (typeof config === \'object\') {\n          _config = _extends({}, _config, config);\n        }\n\n        var action = typeof config === \'string\' ? config : _config.slide;\n\n        if (!data) {\n          data = new Carousel(this, _config);\n          $__default["default"](this).data(DATA_KEY$8, data);\n        }\n\n        if (typeof config === \'number\') {\n          data.to(config);\n        } else if (typeof action === \'string\') {\n          if (typeof data[action] === \'undefined\') {\n            throw new TypeError("No method named \\"" + action + "\\"");\n          }\n\n          data[action]();\n        } else if (_config.interval && _config.ride) {\n          data.pause();\n          data.cycle();\n        }\n      });\n    };\n\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\n      var selector = Util.getSelectorFromElement(this);\n\n      if (!selector) {\n        return;\n      }\n\n      var target = $__default["default"](selector)[0];\n\n      if (!target || !$__default["default"](target).hasClass(CLASS_NAME_CAROUSEL)) {\n        return;\n      }\n\n      var config = _extends({}, $__default["default"](target).data(), $__default["default"](this).data());\n\n      var slideIndex = this.getAttribute(\'data-slide-to\');\n\n      if (slideIndex) {\n        config.interval = false;\n      }\n\n      Carousel._jQueryInterface.call($__default["default"](target), config);\n\n      if (slideIndex) {\n        $__default["default"](target).data(DATA_KEY$8).to(slideIndex);\n      }\n\n      event.preventDefault();\n    };\n\n    _createClass(Carousel, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$8;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default$7;\n      }\n    }]);\n\n    return Carousel;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](document).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);\n  $__default["default"](window).on(EVENT_LOAD_DATA_API$1, function () {\n    var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));\n\n    for (var i = 0, len = carousels.length; i < len; i++) {\n      var $carousel = $__default["default"](carousels[i]);\n\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$8] = Carousel._jQueryInterface;\n  $__default["default"].fn[NAME$8].Constructor = Carousel;\n\n  $__default["default"].fn[NAME$8].noConflict = function () {\n    $__default["default"].fn[NAME$8] = JQUERY_NO_CONFLICT$8;\n    return Carousel._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$7 = \'collapse\';\n  var VERSION$7 = \'4.6.2\';\n  var DATA_KEY$7 = \'bs.collapse\';\n  var EVENT_KEY$7 = "." + DATA_KEY$7;\n  var DATA_API_KEY$4 = \'.data-api\';\n  var JQUERY_NO_CONFLICT$7 = $__default["default"].fn[NAME$7];\n  var CLASS_NAME_SHOW$6 = \'show\';\n  var CLASS_NAME_COLLAPSE = \'collapse\';\n  var CLASS_NAME_COLLAPSING = \'collapsing\';\n  var CLASS_NAME_COLLAPSED = \'collapsed\';\n  var DIMENSION_WIDTH = \'width\';\n  var DIMENSION_HEIGHT = \'height\';\n  var EVENT_SHOW$4 = "show" + EVENT_KEY$7;\n  var EVENT_SHOWN$4 = "shown" + EVENT_KEY$7;\n  var EVENT_HIDE$4 = "hide" + EVENT_KEY$7;\n  var EVENT_HIDDEN$4 = "hidden" + EVENT_KEY$7;\n  var EVENT_CLICK_DATA_API$3 = "click" + EVENT_KEY$7 + DATA_API_KEY$4;\n  var SELECTOR_ACTIVES = \'.show, .collapsing\';\n  var SELECTOR_DATA_TOGGLE$3 = \'[data-toggle="collapse"]\';\n  var Default$6 = {\n    toggle: true,\n    parent: \'\'\n  };\n  var DefaultType$6 = {\n    toggle: \'boolean\',\n    parent: \'(string|element)\'\n  };\n  /**\n   * Class definition\n   */\n\n  var Collapse = /*#__PURE__*/function () {\n    function Collapse(element, config) {\n      this._isTransitioning = false;\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\\"collapse\\"][href=\\"#" + element.id + "\\"]," + ("[data-toggle=\\"collapse\\"][data-target=\\"#" + element.id + "\\"]")));\n      var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$3));\n\n      for (var i = 0, len = toggleList.length; i < len; i++) {\n        var elem = toggleList[i];\n        var selector = Util.getSelectorFromElement(elem);\n        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {\n          return foundElem === element;\n        });\n\n        if (selector !== null && filterElement.length > 0) {\n          this._selector = selector;\n\n          this._triggerArray.push(elem);\n        }\n      }\n\n      this._parent = this._config.parent ? this._getParent() : null;\n\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n      }\n\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n\n    var _proto = Collapse.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if ($__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._isTransitioning || $__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {\n        return;\n      }\n\n      var actives;\n      var activesData;\n\n      if (this._parent) {\n        actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {\n          if (typeof _this._config.parent === \'string\') {\n            return elem.getAttribute(\'data-parent\') === _this._config.parent;\n          }\n\n          return elem.classList.contains(CLASS_NAME_COLLAPSE);\n        });\n\n        if (actives.length === 0) {\n          actives = null;\n        }\n      }\n\n      if (actives) {\n        activesData = $__default["default"](actives).not(this._selector).data(DATA_KEY$7);\n\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n\n      var startEvent = $__default["default"].Event(EVENT_SHOW$4);\n      $__default["default"](this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (actives) {\n        Collapse._jQueryInterface.call($__default["default"](actives).not(this._selector), \'hide\');\n\n        if (!activesData) {\n          $__default["default"](actives).data(DATA_KEY$7, null);\n        }\n      }\n\n      var dimension = this._getDimension();\n\n      $__default["default"](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);\n      this._element.style[dimension] = 0;\n\n      if (this._triggerArray.length) {\n        $__default["default"](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr(\'aria-expanded\', true);\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        $__default["default"](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);\n        _this._element.style[dimension] = \'\';\n\n        _this.setTransitioning(false);\n\n        $__default["default"](_this._element).trigger(EVENT_SHOWN$4);\n      };\n\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = "scroll" + capitalizedDimension;\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      this._element.style[dimension] = this._element[scrollSize] + "px";\n    };\n\n    _proto.hide = function hide() {\n      var _this2 = this;\n\n      if (this._isTransitioning || !$__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) {\n        return;\n      }\n\n      var startEvent = $__default["default"].Event(EVENT_HIDE$4);\n      $__default["default"](this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      var dimension = this._getDimension();\n\n      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";\n      Util.reflow(this._element);\n      $__default["default"](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);\n      var triggerArrayLength = this._triggerArray.length;\n\n      if (triggerArrayLength > 0) {\n        for (var i = 0; i < triggerArrayLength; i++) {\n          var trigger = this._triggerArray[i];\n          var selector = Util.getSelectorFromElement(trigger);\n\n          if (selector !== null) {\n            var $elem = $__default["default"]([].slice.call(document.querySelectorAll(selector)));\n\n            if (!$elem.hasClass(CLASS_NAME_SHOW$6)) {\n              $__default["default"](trigger).addClass(CLASS_NAME_COLLAPSED).attr(\'aria-expanded\', false);\n            }\n          }\n        }\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        _this2.setTransitioning(false);\n\n        $__default["default"](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN$4);\n      };\n\n      this._element.style[dimension] = \'\';\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto.setTransitioning = function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    };\n\n    _proto.dispose = function dispose() {\n      $__default["default"].removeData(this._element, DATA_KEY$7);\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$6, config);\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      Util.typeCheckConfig(NAME$7, config, DefaultType$6);\n      return config;\n    };\n\n    _proto._getDimension = function _getDimension() {\n      var hasWidth = $__default["default"](this._element).hasClass(DIMENSION_WIDTH);\n      return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;\n    };\n\n    _proto._getParent = function _getParent() {\n      var _this3 = this;\n\n      var parent;\n\n      if (Util.isElement(this._config.parent)) {\n        parent = this._config.parent; // It\'s a jQuery object\n\n        if (typeof this._config.parent.jquery !== \'undefined\') {\n          parent = this._config.parent[0];\n        }\n      } else {\n        parent = document.querySelector(this._config.parent);\n      }\n\n      var selector = "[data-toggle=\\"collapse\\"][data-parent=\\"" + this._config.parent + "\\"]";\n      var children = [].slice.call(parent.querySelectorAll(selector));\n      $__default["default"](children).each(function (i, element) {\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n      return parent;\n    };\n\n    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\n      var isOpen = $__default["default"](element).hasClass(CLASS_NAME_SHOW$6);\n\n      if (triggerArray.length) {\n        $__default["default"](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr(\'aria-expanded\', isOpen);\n      }\n    } // Static\n    ;\n\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      return selector ? document.querySelector(selector) : null;\n    };\n\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default["default"](this);\n        var data = $element.data(DATA_KEY$7);\n\n        var _config = _extends({}, Default$6, $element.data(), typeof config === \'object\' && config ? config : {});\n\n        if (!data && _config.toggle && typeof config === \'string\' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n\n        if (!data) {\n          data = new Collapse(this, _config);\n          $element.data(DATA_KEY$7, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Collapse, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$7;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default$6;\n      }\n    }]);\n\n    return Collapse;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.currentTarget.tagName === \'A\') {\n      event.preventDefault();\n    }\n\n    var $trigger = $__default["default"](this);\n    var selector = Util.getSelectorFromElement(this);\n    var selectors = [].slice.call(document.querySelectorAll(selector));\n    $__default["default"](selectors).each(function () {\n      var $target = $__default["default"](this);\n      var data = $target.data(DATA_KEY$7);\n      var config = data ? \'toggle\' : $trigger.data();\n\n      Collapse._jQueryInterface.call($target, config);\n    });\n  });\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$7] = Collapse._jQueryInterface;\n  $__default["default"].fn[NAME$7].Constructor = Collapse;\n\n  $__default["default"].fn[NAME$7].noConflict = function () {\n    $__default["default"].fn[NAME$7] = JQUERY_NO_CONFLICT$7;\n    return Collapse._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$6 = \'dropdown\';\n  var VERSION$6 = \'4.6.2\';\n  var DATA_KEY$6 = \'bs.dropdown\';\n  var EVENT_KEY$6 = "." + DATA_KEY$6;\n  var DATA_API_KEY$3 = \'.data-api\';\n  var JQUERY_NO_CONFLICT$6 = $__default["default"].fn[NAME$6];\n  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\n\n  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\n\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\n\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\n\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\n\n  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE$1);\n  var CLASS_NAME_DISABLED$1 = \'disabled\';\n  var CLASS_NAME_SHOW$5 = \'show\';\n  var CLASS_NAME_DROPUP = \'dropup\';\n  var CLASS_NAME_DROPRIGHT = \'dropright\';\n  var CLASS_NAME_DROPLEFT = \'dropleft\';\n  var CLASS_NAME_MENURIGHT = \'dropdown-menu-right\';\n  var CLASS_NAME_POSITION_STATIC = \'position-static\';\n  var EVENT_HIDE$3 = "hide" + EVENT_KEY$6;\n  var EVENT_HIDDEN$3 = "hidden" + EVENT_KEY$6;\n  var EVENT_SHOW$3 = "show" + EVENT_KEY$6;\n  var EVENT_SHOWN$3 = "shown" + EVENT_KEY$6;\n  var EVENT_CLICK = "click" + EVENT_KEY$6;\n  var EVENT_CLICK_DATA_API$2 = "click" + EVENT_KEY$6 + DATA_API_KEY$3;\n  var EVENT_KEYDOWN_DATA_API = "keydown" + EVENT_KEY$6 + DATA_API_KEY$3;\n  var EVENT_KEYUP_DATA_API = "keyup" + EVENT_KEY$6 + DATA_API_KEY$3;\n  var SELECTOR_DATA_TOGGLE$2 = \'[data-toggle="dropdown"]\';\n  var SELECTOR_FORM_CHILD = \'.dropdown form\';\n  var SELECTOR_MENU = \'.dropdown-menu\';\n  var SELECTOR_NAVBAR_NAV = \'.navbar-nav\';\n  var SELECTOR_VISIBLE_ITEMS = \'.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\';\n  var PLACEMENT_TOP = \'top-start\';\n  var PLACEMENT_TOPEND = \'top-end\';\n  var PLACEMENT_BOTTOM = \'bottom-start\';\n  var PLACEMENT_BOTTOMEND = \'bottom-end\';\n  var PLACEMENT_RIGHT = \'right-start\';\n  var PLACEMENT_LEFT = \'left-start\';\n  var Default$5 = {\n    offset: 0,\n    flip: true,\n    boundary: \'scrollParent\',\n    reference: \'toggle\',\n    display: \'dynamic\',\n    popperConfig: null\n  };\n  var DefaultType$5 = {\n    offset: \'(number|string|function)\',\n    flip: \'boolean\',\n    boundary: \'(string|element)\',\n    reference: \'(string|element)\',\n    display: \'string\',\n    popperConfig: \'(null|object)\'\n  };\n  /**\n   * Class definition\n   */\n\n  var Dropdown = /*#__PURE__*/function () {\n    function Dropdown(element, config) {\n      this._element = element;\n      this._popper = null;\n      this._config = this._getConfig(config);\n      this._menu = this._getMenuElement();\n      this._inNavbar = this._detectNavbar();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Dropdown.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1)) {\n        return;\n      }\n\n      var isActive = $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5);\n\n      Dropdown._clearMenus();\n\n      if (isActive) {\n        return;\n      }\n\n      this.show(true);\n    };\n\n    _proto.show = function show(usePopper) {\n      if (usePopper === void 0) {\n        usePopper = false;\n      }\n\n      if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {\n        return;\n      }\n\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var showEvent = $__default["default"].Event(EVENT_SHOW$3, relatedTarget);\n\n      var parent = Dropdown._getParentFromElement(this._element);\n\n      $__default["default"](parent).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      } // Totally disable Popper for Dropdowns in Navbar\n\n\n      if (!this._inNavbar && usePopper) {\n        // Check for Popper dependency\n        if (typeof Popper__default["default"] === \'undefined\') {\n          throw new TypeError(\'Bootstrap\\\'s dropdowns require Popper (https://popper.js.org)\');\n        }\n\n        var referenceElement = this._element;\n\n        if (this._config.reference === \'parent\') {\n          referenceElement = parent;\n        } else if (Util.isElement(this._config.reference)) {\n          referenceElement = this._config.reference; // Check if it\'s jQuery element\n\n          if (typeof this._config.reference.jquery !== \'undefined\') {\n            referenceElement = this._config.reference[0];\n          }\n        } // If boundary is not `scrollParent`, then set position to `static`\n        // to allow the menu to "escape" the scroll parent\'s boundaries\n        // https://github.com/twbs/bootstrap/issues/24251\n\n\n        if (this._config.boundary !== \'scrollParent\') {\n          $__default["default"](parent).addClass(CLASS_NAME_POSITION_STATIC);\n        }\n\n        this._popper = new Popper__default["default"](referenceElement, this._menu, this._getPopperConfig());\n      } // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body\'s immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n      if (\'ontouchstart\' in document.documentElement && $__default["default"](parent).closest(SELECTOR_NAVBAR_NAV).length === 0) {\n        $__default["default"](document.body).children().on(\'mouseover\', null, $__default["default"].noop);\n      }\n\n      this._element.focus();\n\n      this._element.setAttribute(\'aria-expanded\', true);\n\n      $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);\n      $__default["default"](parent).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_SHOWN$3, relatedTarget));\n    };\n\n    _proto.hide = function hide() {\n      if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || !$__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {\n        return;\n      }\n\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);\n\n      var parent = Dropdown._getParentFromElement(this._element);\n\n      $__default["default"](parent).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);\n      $__default["default"](parent).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));\n    };\n\n    _proto.dispose = function dispose() {\n      $__default["default"].removeData(this._element, DATA_KEY$6);\n      $__default["default"](this._element).off(EVENT_KEY$6);\n      this._element = null;\n      this._menu = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    };\n\n    _proto.update = function update() {\n      this._inNavbar = this._detectNavbar();\n\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Private\n    ;\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this = this;\n\n      $__default["default"](this._element).on(EVENT_CLICK, function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this.toggle();\n      });\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, this.constructor.Default, $__default["default"](this._element).data(), config);\n      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getMenuElement = function _getMenuElement() {\n      if (!this._menu) {\n        var parent = Dropdown._getParentFromElement(this._element);\n\n        if (parent) {\n          this._menu = parent.querySelector(SELECTOR_MENU);\n        }\n      }\n\n      return this._menu;\n    };\n\n    _proto._getPlacement = function _getPlacement() {\n      var $parentDropdown = $__default["default"](this._element.parentNode);\n      var placement = PLACEMENT_BOTTOM; // Handle dropup\n\n      if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {\n        placement = $__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {\n        placement = PLACEMENT_RIGHT;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {\n        placement = PLACEMENT_LEFT;\n      } else if ($__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT)) {\n        placement = PLACEMENT_BOTTOMEND;\n      }\n\n      return placement;\n    };\n\n    _proto._detectNavbar = function _detectNavbar() {\n      return $__default["default"](this._element).closest(\'.navbar\').length > 0;\n    };\n\n    _proto._getOffset = function _getOffset() {\n      var _this2 = this;\n\n      var offset = {};\n\n      if (typeof this._config.offset === \'function\') {\n        offset.fn = function (data) {\n          data.offsets = _extends({}, data.offsets, _this2._config.offset(data.offsets, _this2._element));\n          return data;\n        };\n      } else {\n        offset.offset = this._config.offset;\n      }\n\n      return offset;\n    };\n\n    _proto._getPopperConfig = function _getPopperConfig() {\n      var popperConfig = {\n        placement: this._getPlacement(),\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            enabled: this._config.flip\n          },\n          preventOverflow: {\n            boundariesElement: this._config.boundary\n          }\n        }\n      }; // Disable Popper if we have a static display\n\n      if (this._config.display === \'static\') {\n        popperConfig.modifiers.applyStyle = {\n          enabled: false\n        };\n      }\n\n      return _extends({}, popperConfig, this._config.popperConfig);\n    } // Static\n    ;\n\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default["default"](this).data(DATA_KEY$6);\n\n        var _config = typeof config === \'object\' ? config : null;\n\n        if (!data) {\n          data = new Dropdown(this, _config);\n          $__default["default"](this).data(DATA_KEY$6, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    Dropdown._clearMenus = function _clearMenus(event) {\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === \'keyup\' && event.which !== TAB_KEYCODE)) {\n        return;\n      }\n\n      var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));\n\n      for (var i = 0, len = toggles.length; i < len; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n\n        var context = $__default["default"](toggles[i]).data(DATA_KEY$6);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n\n        if (event && event.type === \'click\') {\n          relatedTarget.clickEvent = event;\n        }\n\n        if (!context) {\n          continue;\n        }\n\n        var dropdownMenu = context._menu;\n\n        if (!$__default["default"](parent).hasClass(CLASS_NAME_SHOW$5)) {\n          continue;\n        }\n\n        if (event && (event.type === \'click\' && /input|textarea/i.test(event.target.tagName) || event.type === \'keyup\' && event.which === TAB_KEYCODE) && $__default["default"].contains(parent, event.target)) {\n          continue;\n        }\n\n        var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);\n        $__default["default"](parent).trigger(hideEvent);\n\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n\n        if (\'ontouchstart\' in document.documentElement) {\n          $__default["default"](document.body).children().off(\'mouseover\', null, $__default["default"].noop);\n        }\n\n        toggles[i].setAttribute(\'aria-expanded\', \'false\');\n\n        if (context._popper) {\n          context._popper.destroy();\n        }\n\n        $__default["default"](dropdownMenu).removeClass(CLASS_NAME_SHOW$5);\n        $__default["default"](parent).removeClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));\n      }\n    };\n\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\n      var parent;\n      var selector = Util.getSelectorFromElement(element);\n\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n\n      return parent || element.parentNode;\n    } // eslint-disable-next-line complexity\n    ;\n\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\n      // If not input/textarea:\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n      // If input/textarea:\n      //  - If space key => not a dropdown command\n      //  - If key is other than escape\n      //    - If key is not up or down => not a dropdown command\n      //    - If trigger inside the menu => not a dropdown command\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE$1 && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default["default"](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\n        return;\n      }\n\n      if (this.disabled || $__default["default"](this).hasClass(CLASS_NAME_DISABLED$1)) {\n        return;\n      }\n\n      var parent = Dropdown._getParentFromElement(this);\n\n      var isActive = $__default["default"](parent).hasClass(CLASS_NAME_SHOW$5);\n\n      if (!isActive && event.which === ESCAPE_KEYCODE$1) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (!isActive || event.which === ESCAPE_KEYCODE$1 || event.which === SPACE_KEYCODE) {\n        if (event.which === ESCAPE_KEYCODE$1) {\n          $__default["default"](parent.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger(\'focus\');\n        }\n\n        $__default["default"](this).trigger(\'click\');\n        return;\n      }\n\n      var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function (item) {\n        return $__default["default"](item).is(\':visible\');\n      });\n\n      if (items.length === 0) {\n        return;\n      }\n\n      var index = items.indexOf(event.target);\n\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // Up\n        index--;\n      }\n\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // Down\n        index++;\n      }\n\n      if (index < 0) {\n        index = 0;\n      }\n\n      items[index].focus();\n    };\n\n    _createClass(Dropdown, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$6;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default$5;\n      }\n    }, {\n      key: "DefaultType",\n      get: function get() {\n        return DefaultType$5;\n      }\n    }]);\n\n    return Dropdown;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$2 + " " + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    Dropdown._jQueryInterface.call($__default["default"](this), \'toggle\');\n  }).on(EVENT_CLICK_DATA_API$2, SELECTOR_FORM_CHILD, function (e) {\n    e.stopPropagation();\n  });\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$6] = Dropdown._jQueryInterface;\n  $__default["default"].fn[NAME$6].Constructor = Dropdown;\n\n  $__default["default"].fn[NAME$6].noConflict = function () {\n    $__default["default"].fn[NAME$6] = JQUERY_NO_CONFLICT$6;\n    return Dropdown._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$5 = \'modal\';\n  var VERSION$5 = \'4.6.2\';\n  var DATA_KEY$5 = \'bs.modal\';\n  var EVENT_KEY$5 = "." + DATA_KEY$5;\n  var DATA_API_KEY$2 = \'.data-api\';\n  var JQUERY_NO_CONFLICT$5 = $__default["default"].fn[NAME$5];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var CLASS_NAME_SCROLLABLE = \'modal-dialog-scrollable\';\n  var CLASS_NAME_SCROLLBAR_MEASURER = \'modal-scrollbar-measure\';\n  var CLASS_NAME_BACKDROP = \'modal-backdrop\';\n  var CLASS_NAME_OPEN = \'modal-open\';\n  var CLASS_NAME_FADE$4 = \'fade\';\n  var CLASS_NAME_SHOW$4 = \'show\';\n  var CLASS_NAME_STATIC = \'modal-static\';\n  var EVENT_HIDE$2 = "hide" + EVENT_KEY$5;\n  var EVENT_HIDE_PREVENTED = "hidePrevented" + EVENT_KEY$5;\n  var EVENT_HIDDEN$2 = "hidden" + EVENT_KEY$5;\n  var EVENT_SHOW$2 = "show" + EVENT_KEY$5;\n  var EVENT_SHOWN$2 = "shown" + EVENT_KEY$5;\n  var EVENT_FOCUSIN = "focusin" + EVENT_KEY$5;\n  var EVENT_RESIZE = "resize" + EVENT_KEY$5;\n  var EVENT_CLICK_DISMISS$1 = "click.dismiss" + EVENT_KEY$5;\n  var EVENT_KEYDOWN_DISMISS = "keydown.dismiss" + EVENT_KEY$5;\n  var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss" + EVENT_KEY$5;\n  var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss" + EVENT_KEY$5;\n  var EVENT_CLICK_DATA_API$1 = "click" + EVENT_KEY$5 + DATA_API_KEY$2;\n  var SELECTOR_DIALOG = \'.modal-dialog\';\n  var SELECTOR_MODAL_BODY = \'.modal-body\';\n  var SELECTOR_DATA_TOGGLE$1 = \'[data-toggle="modal"]\';\n  var SELECTOR_DATA_DISMISS$1 = \'[data-dismiss="modal"]\';\n  var SELECTOR_FIXED_CONTENT = \'.fixed-top, .fixed-bottom, .is-fixed, .sticky-top\';\n  var SELECTOR_STICKY_CONTENT = \'.sticky-top\';\n  var Default$4 = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: true\n  };\n  var DefaultType$4 = {\n    backdrop: \'(boolean|string)\',\n    keyboard: \'boolean\',\n    focus: \'boolean\',\n    show: \'boolean\'\n  };\n  /**\n   * Class definition\n   */\n\n  var Modal = /*#__PURE__*/function () {\n    function Modal(element, config) {\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._dialog = element.querySelector(SELECTOR_DIALOG);\n      this._backdrop = null;\n      this._isShown = false;\n      this._isBodyOverflowing = false;\n      this._ignoreBackdropClick = false;\n      this._isTransitioning = false;\n      this._scrollbarWidth = 0;\n    } // Getters\n\n\n    var _proto = Modal.prototype;\n\n    // Public\n    _proto.toggle = function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    };\n\n    _proto.show = function show(relatedTarget) {\n      var _this = this;\n\n      if (this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      var showEvent = $__default["default"].Event(EVENT_SHOW$2, {\n        relatedTarget: relatedTarget\n      });\n      $__default["default"](this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = true;\n\n      if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) {\n        this._isTransitioning = true;\n      }\n\n      this._checkScrollbar();\n\n      this._setScrollbar();\n\n      this._adjustDialog();\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function (event) {\n        return _this.hide(event);\n      });\n      $__default["default"](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {\n        $__default["default"](_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {\n          if ($__default["default"](event.target).is(_this._element)) {\n            _this._ignoreBackdropClick = true;\n          }\n        });\n      });\n\n      this._showBackdrop(function () {\n        return _this._showElement(relatedTarget);\n      });\n    };\n\n    _proto.hide = function hide(event) {\n      var _this2 = this;\n\n      if (event) {\n        event.preventDefault();\n      }\n\n      if (!this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      var hideEvent = $__default["default"].Event(EVENT_HIDE$2);\n      $__default["default"](this._element).trigger(hideEvent);\n\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = false;\n      var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);\n\n      if (transition) {\n        this._isTransitioning = true;\n      }\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $__default["default"](document).off(EVENT_FOCUSIN);\n      $__default["default"](this._element).removeClass(CLASS_NAME_SHOW$4);\n      $__default["default"](this._element).off(EVENT_CLICK_DISMISS$1);\n      $__default["default"](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default["default"](this._element).one(Util.TRANSITION_END, function (event) {\n          return _this2._hideModal(event);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        this._hideModal();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      [window, this._element, this._dialog].forEach(function (htmlElement) {\n        return $__default["default"](htmlElement).off(EVENT_KEY$5);\n      });\n      /**\n       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n       * Do not move `document` in `htmlElements` array\n       * It will remove `EVENT_CLICK_DATA_API` event that should remain\n       */\n\n      $__default["default"](document).off(EVENT_FOCUSIN);\n      $__default["default"].removeData(this._element, DATA_KEY$5);\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._isTransitioning = null;\n      this._scrollbarWidth = null;\n    };\n\n    _proto.handleUpdate = function handleUpdate() {\n      this._adjustDialog();\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$4, config);\n      Util.typeCheckConfig(NAME$5, config, DefaultType$4);\n      return config;\n    };\n\n    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {\n      var _this3 = this;\n\n      var hideEventPrevented = $__default["default"].Event(EVENT_HIDE_PREVENTED);\n      $__default["default"](this._element).trigger(hideEventPrevented);\n\n      if (hideEventPrevented.isDefaultPrevented()) {\n        return;\n      }\n\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      if (!isModalOverflowing) {\n        this._element.style.overflowY = \'hidden\';\n      }\n\n      this._element.classList.add(CLASS_NAME_STATIC);\n\n      var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n      $__default["default"](this._element).off(Util.TRANSITION_END);\n      $__default["default"](this._element).one(Util.TRANSITION_END, function () {\n        _this3._element.classList.remove(CLASS_NAME_STATIC);\n\n        if (!isModalOverflowing) {\n          $__default["default"](_this3._element).one(Util.TRANSITION_END, function () {\n            _this3._element.style.overflowY = \'\';\n          }).emulateTransitionEnd(_this3._element, modalTransitionDuration);\n        }\n      }).emulateTransitionEnd(modalTransitionDuration);\n\n      this._element.focus();\n    };\n\n    _proto._showElement = function _showElement(relatedTarget) {\n      var _this4 = this;\n\n      var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);\n      var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;\n\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // Don\'t move modal\'s DOM position\n        document.body.appendChild(this._element);\n      }\n\n      this._element.style.display = \'block\';\n\n      this._element.removeAttribute(\'aria-hidden\');\n\n      this._element.setAttribute(\'aria-modal\', true);\n\n      this._element.setAttribute(\'role\', \'dialog\');\n\n      if ($__default["default"](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {\n        modalBody.scrollTop = 0;\n      } else {\n        this._element.scrollTop = 0;\n      }\n\n      if (transition) {\n        Util.reflow(this._element);\n      }\n\n      $__default["default"](this._element).addClass(CLASS_NAME_SHOW$4);\n\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n\n      var shownEvent = $__default["default"].Event(EVENT_SHOWN$2, {\n        relatedTarget: relatedTarget\n      });\n\n      var transitionComplete = function transitionComplete() {\n        if (_this4._config.focus) {\n          _this4._element.focus();\n        }\n\n        _this4._isTransitioning = false;\n        $__default["default"](_this4._element).trigger(shownEvent);\n      };\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n        $__default["default"](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\n      } else {\n        transitionComplete();\n      }\n    };\n\n    _proto._enforceFocus = function _enforceFocus() {\n      var _this5 = this;\n\n      $__default["default"](document).off(EVENT_FOCUSIN) // Guard against infinite focus loop\n      .on(EVENT_FOCUSIN, function (event) {\n        if (document !== event.target && _this5._element !== event.target && $__default["default"](_this5._element).has(event.target).length === 0) {\n          _this5._element.focus();\n        }\n      });\n    };\n\n    _proto._setEscapeEvent = function _setEscapeEvent() {\n      var _this6 = this;\n\n      if (this._isShown) {\n        $__default["default"](this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {\n          if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {\n            event.preventDefault();\n\n            _this6.hide();\n          } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {\n            _this6._triggerBackdropTransition();\n          }\n        });\n      } else if (!this._isShown) {\n        $__default["default"](this._element).off(EVENT_KEYDOWN_DISMISS);\n      }\n    };\n\n    _proto._setResizeEvent = function _setResizeEvent() {\n      var _this7 = this;\n\n      if (this._isShown) {\n        $__default["default"](window).on(EVENT_RESIZE, function (event) {\n          return _this7.handleUpdate(event);\n        });\n      } else {\n        $__default["default"](window).off(EVENT_RESIZE);\n      }\n    };\n\n    _proto._hideModal = function _hideModal() {\n      var _this8 = this;\n\n      this._element.style.display = \'none\';\n\n      this._element.setAttribute(\'aria-hidden\', true);\n\n      this._element.removeAttribute(\'aria-modal\');\n\n      this._element.removeAttribute(\'role\');\n\n      this._isTransitioning = false;\n\n      this._showBackdrop(function () {\n        $__default["default"](document.body).removeClass(CLASS_NAME_OPEN);\n\n        _this8._resetAdjustments();\n\n        _this8._resetScrollbar();\n\n        $__default["default"](_this8._element).trigger(EVENT_HIDDEN$2);\n      });\n    };\n\n    _proto._removeBackdrop = function _removeBackdrop() {\n      if (this._backdrop) {\n        $__default["default"](this._backdrop).remove();\n        this._backdrop = null;\n      }\n    };\n\n    _proto._showBackdrop = function _showBackdrop(callback) {\n      var _this9 = this;\n\n      var animate = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4) ? CLASS_NAME_FADE$4 : \'\';\n\n      if (this._isShown && this._config.backdrop) {\n        this._backdrop = document.createElement(\'div\');\n        this._backdrop.className = CLASS_NAME_BACKDROP;\n\n        if (animate) {\n          this._backdrop.classList.add(animate);\n        }\n\n        $__default["default"](this._backdrop).appendTo(document.body);\n        $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, function (event) {\n          if (_this9._ignoreBackdropClick) {\n            _this9._ignoreBackdropClick = false;\n            return;\n          }\n\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n\n          if (_this9._config.backdrop === \'static\') {\n            _this9._triggerBackdropTransition();\n          } else {\n            _this9.hide();\n          }\n        });\n\n        if (animate) {\n          Util.reflow(this._backdrop);\n        }\n\n        $__default["default"](this._backdrop).addClass(CLASS_NAME_SHOW$4);\n\n        if (!callback) {\n          return;\n        }\n\n        if (!animate) {\n          callback();\n          return;\n        }\n\n        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n        $__default["default"](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\n      } else if (!this._isShown && this._backdrop) {\n        $__default["default"](this._backdrop).removeClass(CLASS_NAME_SHOW$4);\n\n        var callbackRemove = function callbackRemove() {\n          _this9._removeBackdrop();\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) {\n          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n\n          $__default["default"](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    } // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n    ;\n\n    _proto._adjustDialog = function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = this._scrollbarWidth + "px";\n      }\n\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = this._scrollbarWidth + "px";\n      }\n    };\n\n    _proto._resetAdjustments = function _resetAdjustments() {\n      this._element.style.paddingLeft = \'\';\n      this._element.style.paddingRight = \'\';\n    };\n\n    _proto._checkScrollbar = function _checkScrollbar() {\n      var rect = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    };\n\n    _proto._setScrollbar = function _setScrollbar() {\n      var _this10 = this;\n\n      if (this._isBodyOverflowing) {\n        // Note: DOMNode.style.paddingRight returns the actual value or \'\' if not set\n        //   while $(DOMNode).css(\'padding-right\') returns the calculated value or 0 if not set\n        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n        var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding\n\n        $__default["default"](fixedContent).each(function (index, element) {\n          var actualPadding = element.style.paddingRight;\n          var calculatedPadding = $__default["default"](element).css(\'padding-right\');\n          $__default["default"](element).data(\'padding-right\', actualPadding).css(\'padding-right\', parseFloat(calculatedPadding) + _this10._scrollbarWidth + "px");\n        }); // Adjust sticky content margin\n\n        $__default["default"](stickyContent).each(function (index, element) {\n          var actualMargin = element.style.marginRight;\n          var calculatedMargin = $__default["default"](element).css(\'margin-right\');\n          $__default["default"](element).data(\'margin-right\', actualMargin).css(\'margin-right\', parseFloat(calculatedMargin) - _this10._scrollbarWidth + "px");\n        }); // Adjust body padding\n\n        var actualPadding = document.body.style.paddingRight;\n        var calculatedPadding = $__default["default"](document.body).css(\'padding-right\');\n        $__default["default"](document.body).data(\'padding-right\', actualPadding).css(\'padding-right\', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");\n      }\n\n      $__default["default"](document.body).addClass(CLASS_NAME_OPEN);\n    };\n\n    _proto._resetScrollbar = function _resetScrollbar() {\n      // Restore fixed content padding\n      var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n      $__default["default"](fixedContent).each(function (index, element) {\n        var padding = $__default["default"](element).data(\'padding-right\');\n        $__default["default"](element).removeData(\'padding-right\');\n        element.style.paddingRight = padding ? padding : \'\';\n      }); // Restore sticky content\n\n      var elements = [].slice.call(document.querySelectorAll("" + SELECTOR_STICKY_CONTENT));\n      $__default["default"](elements).each(function (index, element) {\n        var margin = $__default["default"](element).data(\'margin-right\');\n\n        if (typeof margin !== \'undefined\') {\n          $__default["default"](element).css(\'margin-right\', margin).removeData(\'margin-right\');\n        }\n      }); // Restore body padding\n\n      var padding = $__default["default"](document.body).data(\'padding-right\');\n      $__default["default"](document.body).removeData(\'padding-right\');\n      document.body.style.paddingRight = padding ? padding : \'\';\n    };\n\n    _proto._getScrollbarWidth = function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement(\'div\');\n      scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    } // Static\n    ;\n\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = $__default["default"](this).data(DATA_KEY$5);\n\n        var _config = _extends({}, Default$4, $__default["default"](this).data(), typeof config === \'object\' && config ? config : {});\n\n        if (!data) {\n          data = new Modal(this, _config);\n          $__default["default"](this).data(DATA_KEY$5, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    };\n\n    _createClass(Modal, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$5;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default$4;\n      }\n    }]);\n\n    return Modal;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n    var _this11 = this;\n\n    var target;\n    var selector = Util.getSelectorFromElement(this);\n\n    if (selector) {\n      target = document.querySelector(selector);\n    }\n\n    var config = $__default["default"](target).data(DATA_KEY$5) ? \'toggle\' : _extends({}, $__default["default"](target).data(), $__default["default"](this).data());\n\n    if (this.tagName === \'A\' || this.tagName === \'AREA\') {\n      event.preventDefault();\n    }\n\n    var $target = $__default["default"](target).one(EVENT_SHOW$2, function (showEvent) {\n      if (showEvent.isDefaultPrevented()) {\n        // Only register focus restorer if modal will actually get shown\n        return;\n      }\n\n      $target.one(EVENT_HIDDEN$2, function () {\n        if ($__default["default"](_this11).is(\':visible\')) {\n          _this11.focus();\n        }\n      });\n    });\n\n    Modal._jQueryInterface.call($__default["default"](target), config, this);\n  });\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$5] = Modal._jQueryInterface;\n  $__default["default"].fn[NAME$5].Constructor = Modal;\n\n  $__default["default"].fn[NAME$5].noConflict = function () {\n    $__default["default"].fn[NAME$5] = JQUERY_NO_CONFLICT$5;\n    return Modal._jQueryInterface;\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.2): tools/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var uriAttrs = [\'background\', \'cite\', \'href\', \'itemtype\', \'longdesc\', \'poster\', \'src\', \'xlink:href\'];\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  var DefaultWhitelist = {\n    // Global attributes allowed on any supplied element below.\n    \'*\': [\'class\', \'dir\', \'id\', \'lang\', \'role\', ARIA_ATTRIBUTE_PATTERN],\n    a: [\'target\', \'href\', \'title\', \'rel\'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: [\'src\', \'srcset\', \'alt\', \'title\', \'width\', \'height\'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n\n  function allowedAttribute(attr, allowedAttributeList) {\n    var attrName = attr.nodeName.toLowerCase();\n\n    if (allowedAttributeList.indexOf(attrName) !== -1) {\n      if (uriAttrs.indexOf(attrName) !== -1) {\n        return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));\n      }\n\n      return true;\n    }\n\n    var regExp = allowedAttributeList.filter(function (attrRegex) {\n      return attrRegex instanceof RegExp;\n    }); // Check if a regular expression validates the attribute.\n\n    for (var i = 0, len = regExp.length; i < len; i++) {\n      if (regExp[i].test(attrName)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {\n    if (unsafeHtml.length === 0) {\n      return unsafeHtml;\n    }\n\n    if (sanitizeFn && typeof sanitizeFn === \'function\') {\n      return sanitizeFn(unsafeHtml);\n    }\n\n    var domParser = new window.DOMParser();\n    var createdDocument = domParser.parseFromString(unsafeHtml, \'text/html\');\n    var whitelistKeys = Object.keys(whiteList);\n    var elements = [].slice.call(createdDocument.body.querySelectorAll(\'*\'));\n\n    var _loop = function _loop(i, len) {\n      var el = elements[i];\n      var elName = el.nodeName.toLowerCase();\n\n      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {\n        el.parentNode.removeChild(el);\n        return "continue";\n      }\n\n      var attributeList = [].slice.call(el.attributes); // eslint-disable-next-line unicorn/prefer-spread\n\n      var whitelistedAttributes = [].concat(whiteList[\'*\'] || [], whiteList[elName] || []);\n      attributeList.forEach(function (attr) {\n        if (!allowedAttribute(attr, whitelistedAttributes)) {\n          el.removeAttribute(attr.nodeName);\n        }\n      });\n    };\n\n    for (var i = 0, len = elements.length; i < len; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === "continue") continue;\n    }\n\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * Constants\n   */\n\n  var NAME$4 = \'tooltip\';\n  var VERSION$4 = \'4.6.2\';\n  var DATA_KEY$4 = \'bs.tooltip\';\n  var EVENT_KEY$4 = "." + DATA_KEY$4;\n  var JQUERY_NO_CONFLICT$4 = $__default["default"].fn[NAME$4];\n  var CLASS_PREFIX$1 = \'bs-tooltip\';\n  var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\\\s)" + CLASS_PREFIX$1 + "\\\\S+", \'g\');\n  var DISALLOWED_ATTRIBUTES = [\'sanitize\', \'whiteList\', \'sanitizeFn\'];\n  var CLASS_NAME_FADE$3 = \'fade\';\n  var CLASS_NAME_SHOW$3 = \'show\';\n  var HOVER_STATE_SHOW = \'show\';\n  var HOVER_STATE_OUT = \'out\';\n  var SELECTOR_TOOLTIP_INNER = \'.tooltip-inner\';\n  var SELECTOR_ARROW = \'.arrow\';\n  var TRIGGER_HOVER = \'hover\';\n  var TRIGGER_FOCUS = \'focus\';\n  var TRIGGER_CLICK = \'click\';\n  var TRIGGER_MANUAL = \'manual\';\n  var AttachmentMap = {\n    AUTO: \'auto\',\n    TOP: \'top\',\n    RIGHT: \'right\',\n    BOTTOM: \'bottom\',\n    LEFT: \'left\'\n  };\n  var Default$3 = {\n    animation: true,\n    template: \'<div class="tooltip" role="tooltip">\' + \'<div class="arrow"></div>\' + \'<div class="tooltip-inner"></div></div>\',\n    trigger: \'hover focus\',\n    title: \'\',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: \'top\',\n    offset: 0,\n    container: false,\n    fallbackPlacement: \'flip\',\n    boundary: \'scrollParent\',\n    customClass: \'\',\n    sanitize: true,\n    sanitizeFn: null,\n    whiteList: DefaultWhitelist,\n    popperConfig: null\n  };\n  var DefaultType$3 = {\n    animation: \'boolean\',\n    template: \'string\',\n    title: \'(string|element|function)\',\n    trigger: \'string\',\n    delay: \'(number|object)\',\n    html: \'boolean\',\n    selector: \'(string|boolean)\',\n    placement: \'(string|function)\',\n    offset: \'(number|string|function)\',\n    container: \'(string|element|boolean)\',\n    fallbackPlacement: \'(string|array)\',\n    boundary: \'(string|element)\',\n    customClass: \'(string|function)\',\n    sanitize: \'boolean\',\n    sanitizeFn: \'(null|function)\',\n    whiteList: \'object\',\n    popperConfig: \'(null|object)\'\n  };\n  var Event$1 = {\n    HIDE: "hide" + EVENT_KEY$4,\n    HIDDEN: "hidden" + EVENT_KEY$4,\n    SHOW: "show" + EVENT_KEY$4,\n    SHOWN: "shown" + EVENT_KEY$4,\n    INSERTED: "inserted" + EVENT_KEY$4,\n    CLICK: "click" + EVENT_KEY$4,\n    FOCUSIN: "focusin" + EVENT_KEY$4,\n    FOCUSOUT: "focusout" + EVENT_KEY$4,\n    MOUSEENTER: "mouseenter" + EVENT_KEY$4,\n    MOUSELEAVE: "mouseleave" + EVENT_KEY$4\n  };\n  /**\n   * Class definition\n   */\n\n  var Tooltip = /*#__PURE__*/function () {\n    function Tooltip(element, config) {\n      if (typeof Popper__default["default"] === \'undefined\') {\n        throw new TypeError(\'Bootstrap\\\'s tooltips require Popper (https://popper.js.org)\');\n      } // Private\n\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = \'\';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $__default["default"](event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $__default["default"](event.currentTarget).data(dataKey, context);\n        }\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($__default["default"](this.getTipElement()).hasClass(CLASS_NAME_SHOW$3)) {\n          this._leave(null, this);\n\n          return;\n        }\n\n        this._enter(null, this);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $__default["default"].removeData(this.element, this.constructor.DATA_KEY);\n      $__default["default"](this.element).off(this.constructor.EVENT_KEY);\n      $__default["default"](this.element).closest(\'.modal\').off(\'hide.bs.modal\', this._hideModalHandler);\n\n      if (this.tip) {\n        $__default["default"](this.tip).remove();\n      }\n\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if ($__default["default"](this.element).css(\'display\') === \'none\') {\n        throw new Error(\'Please use show on visible elements\');\n      }\n\n      var showEvent = $__default["default"].Event(this.constructor.Event.SHOW);\n\n      if (this.isWithContent() && this._isEnabled) {\n        $__default["default"](this.element).trigger(showEvent);\n        var shadowRoot = Util.findShadowRoot(this.element);\n        var isInTheDom = $__default["default"].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);\n\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute(\'id\', tipId);\n        this.element.setAttribute(\'aria-describedby\', tipId);\n        this.setContent();\n\n        if (this.config.animation) {\n          $__default["default"](tip).addClass(CLASS_NAME_FADE$3);\n        }\n\n        var placement = typeof this.config.placement === \'function\' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n        var attachment = this._getAttachment(placement);\n\n        this.addAttachmentClass(attachment);\n\n        var container = this._getContainer();\n\n        $__default["default"](tip).data(this.constructor.DATA_KEY, this);\n\n        if (!$__default["default"].contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $__default["default"](tip).appendTo(container);\n        }\n\n        $__default["default"](this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper__default["default"](this.element, tip, this._getPopperConfig(attachment));\n        $__default["default"](tip).addClass(CLASS_NAME_SHOW$3);\n        $__default["default"](tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body\'s immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if (\'ontouchstart\' in document.documentElement) {\n          $__default["default"](document.body).children().on(\'mouseover\', null, $__default["default"].noop);\n        }\n\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $__default["default"](_this.element).trigger(_this.constructor.Event.SHOWN);\n\n          if (prevHoverState === HOVER_STATE_OUT) {\n            _this._leave(null, _this);\n          }\n        };\n\n        if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $__default["default"](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n\n      var tip = this.getTipElement();\n      var hideEvent = $__default["default"].Event(this.constructor.Event.HIDE);\n\n      var complete = function complete() {\n        if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n\n        _this2._cleanTipClass();\n\n        _this2.element.removeAttribute(\'aria-describedby\');\n\n        $__default["default"](_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      $__default["default"](this.element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      $__default["default"](tip).removeClass(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if (\'ontouchstart\' in document.documentElement) {\n        $__default["default"](document.body).children().off(\'mouseover\', null, $__default["default"].noop);\n      }\n\n      this._activeTrigger[TRIGGER_CLICK] = false;\n      this._activeTrigger[TRIGGER_FOCUS] = false;\n      this._activeTrigger[TRIGGER_HOVER] = false;\n\n      if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $__default["default"](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n\n      this._hoverState = \'\';\n    };\n\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Protected\n    ;\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default["default"](this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var tip = this.getTipElement();\n      this.setElementContent($__default["default"](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());\n      $__default["default"](tip).removeClass(CLASS_NAME_FADE$3 + " " + CLASS_NAME_SHOW$3);\n    };\n\n    _proto.setElementContent = function setElementContent($element, content) {\n      if (typeof content === \'object\' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (this.config.html) {\n          if (!$__default["default"](content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($__default["default"](content).text());\n        }\n\n        return;\n      }\n\n      if (this.config.html) {\n        if (this.config.sanitize) {\n          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);\n        }\n\n        $element.html(content);\n      } else {\n        $element.text(content);\n      }\n    };\n\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute(\'data-original-title\');\n\n      if (!title) {\n        title = typeof this.config.title === \'function\' ? this.config.title.call(this.element) : this.config.title;\n      }\n\n      return title;\n    } // Private\n    ;\n\n    _proto._getPopperConfig = function _getPopperConfig(attachment) {\n      var _this3 = this;\n\n      var defaultBsConfig = {\n        placement: attachment,\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            behavior: this.config.fallbackPlacement\n          },\n          arrow: {\n            element: SELECTOR_ARROW\n          },\n          preventOverflow: {\n            boundariesElement: this.config.boundary\n          }\n        },\n        onCreate: function onCreate(data) {\n          if (data.originalPlacement !== data.placement) {\n            _this3._handlePopperPlacementChange(data);\n          }\n        },\n        onUpdate: function onUpdate(data) {\n          return _this3._handlePopperPlacementChange(data);\n        }\n      };\n      return _extends({}, defaultBsConfig, this.config.popperConfig);\n    };\n\n    _proto._getOffset = function _getOffset() {\n      var _this4 = this;\n\n      var offset = {};\n\n      if (typeof this.config.offset === \'function\') {\n        offset.fn = function (data) {\n          data.offsets = _extends({}, data.offsets, _this4.config.offset(data.offsets, _this4.element));\n          return data;\n        };\n      } else {\n        offset.offset = this.config.offset;\n      }\n\n      return offset;\n    };\n\n    _proto._getContainer = function _getContainer() {\n      if (this.config.container === false) {\n        return document.body;\n      }\n\n      if (Util.isElement(this.config.container)) {\n        return $__default["default"](this.config.container);\n      }\n\n      return $__default["default"](document).find(this.config.container);\n    };\n\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this5 = this;\n\n      var triggers = this.config.trigger.split(\' \');\n      triggers.forEach(function (trigger) {\n        if (trigger === \'click\') {\n          $__default["default"](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {\n            return _this5.toggle(event);\n          });\n        } else if (trigger !== TRIGGER_MANUAL) {\n          var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;\n          var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;\n          $__default["default"](_this5.element).on(eventIn, _this5.config.selector, function (event) {\n            return _this5._enter(event);\n          }).on(eventOut, _this5.config.selector, function (event) {\n            return _this5._leave(event);\n          });\n        }\n      });\n\n      this._hideModalHandler = function () {\n        if (_this5.element) {\n          _this5.hide();\n        }\n      };\n\n      $__default["default"](this.element).closest(\'.modal\').on(\'hide.bs.modal\', this._hideModalHandler);\n\n      if (this.config.selector) {\n        this.config = _extends({}, this.config, {\n          trigger: \'manual\',\n          selector: \'\'\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = typeof this.element.getAttribute(\'data-original-title\');\n\n      if (this.element.getAttribute(\'title\') || titleType !== \'string\') {\n        this.element.setAttribute(\'data-original-title\', this.element.getAttribute(\'title\') || \'\');\n        this.element.setAttribute(\'title\', \'\');\n      }\n    };\n\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default["default"](event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default["default"](event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === \'focusin\' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n      }\n\n      if ($__default["default"](context.getTipElement()).hasClass(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {\n        context._hoverState = HOVER_STATE_SHOW;\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_SHOW;\n\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default["default"](event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default["default"](event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === \'focusout\' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;\n      }\n\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_OUT;\n\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      var dataAttributes = $__default["default"](this.element).data();\n      Object.keys(dataAttributes).forEach(function (dataAttr) {\n        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {\n          delete dataAttributes[dataAttr];\n        }\n      });\n      config = _extends({}, this.constructor.Default, dataAttributes, typeof config === \'object\' && config ? config : {});\n\n      if (typeof config.delay === \'number\') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      if (typeof config.title === \'number\') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === \'number\') {\n        config.content = config.content.toString();\n      }\n\n      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\n\n      if (config.sanitize) {\n        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);\n      }\n\n      return config;\n    };\n\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n\n      return config;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default["default"](this.getTipElement());\n      var tabClass = $tip.attr(\'class\').match(BSCLS_PREFIX_REGEX$1);\n\n      if (tabClass !== null && tabClass.length) {\n        $tip.removeClass(tabClass.join(\'\'));\n      }\n    };\n\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {\n      this.tip = popperData.instance.popper;\n\n      this._cleanTipClass();\n\n      this.addAttachmentClass(this._getAttachment(popperData.placement));\n    };\n\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n\n      if (tip.getAttribute(\'x-placement\') !== null) {\n        return;\n      }\n\n      $__default["default"](tip).removeClass(CLASS_NAME_FADE$3);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    } // Static\n    ;\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default["default"](this);\n        var data = $element.data(DATA_KEY$4);\n\n        var _config = typeof config === \'object\' && config;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $element.data(DATA_KEY$4, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tooltip, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$4;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default$3;\n      }\n    }, {\n      key: "NAME",\n      get: function get() {\n        return NAME$4;\n      }\n    }, {\n      key: "DATA_KEY",\n      get: function get() {\n        return DATA_KEY$4;\n      }\n    }, {\n      key: "Event",\n      get: function get() {\n        return Event$1;\n      }\n    }, {\n      key: "EVENT_KEY",\n      get: function get() {\n        return EVENT_KEY$4;\n      }\n    }, {\n      key: "DefaultType",\n      get: function get() {\n        return DefaultType$3;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n  /**\n   * jQuery\n   */\n\n\n  $__default["default"].fn[NAME$4] = Tooltip._jQueryInterface;\n  $__default["default"].fn[NAME$4].Constructor = Tooltip;\n\n  $__default["default"].fn[NAME$4].noConflict = function () {\n    $__default["default"].fn[NAME$4] = JQUERY_NO_CONFLICT$4;\n    return Tooltip._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$3 = \'popover\';\n  var VERSION$3 = \'4.6.2\';\n  var DATA_KEY$3 = \'bs.popover\';\n  var EVENT_KEY$3 = "." + DATA_KEY$3;\n  var JQUERY_NO_CONFLICT$3 = $__default["default"].fn[NAME$3];\n  var CLASS_PREFIX = \'bs-popover\';\n  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\\\s)" + CLASS_PREFIX + "\\\\S+", \'g\');\n  var CLASS_NAME_FADE$2 = \'fade\';\n  var CLASS_NAME_SHOW$2 = \'show\';\n  var SELECTOR_TITLE = \'.popover-header\';\n  var SELECTOR_CONTENT = \'.popover-body\';\n\n  var Default$2 = _extends({}, Tooltip.Default, {\n    placement: \'right\',\n    trigger: \'click\',\n    content: \'\',\n    template: \'<div class="popover" role="tooltip">\' + \'<div class="arrow"></div>\' + \'<h3 class="popover-header"></h3>\' + \'<div class="popover-body"></div></div>\'\n  });\n\n  var DefaultType$2 = _extends({}, Tooltip.DefaultType, {\n    content: \'(string|element|function)\'\n  });\n\n  var Event = {\n    HIDE: "hide" + EVENT_KEY$3,\n    HIDDEN: "hidden" + EVENT_KEY$3,\n    SHOW: "show" + EVENT_KEY$3,\n    SHOWN: "shown" + EVENT_KEY$3,\n    INSERTED: "inserted" + EVENT_KEY$3,\n    CLICK: "click" + EVENT_KEY$3,\n    FOCUSIN: "focusin" + EVENT_KEY$3,\n    FOCUSOUT: "focusout" + EVENT_KEY$3,\n    MOUSEENTER: "mouseenter" + EVENT_KEY$3,\n    MOUSELEAVE: "mouseleave" + EVENT_KEY$3\n  };\n  /**\n   * Class definition\n   */\n\n  var Popover = /*#__PURE__*/function (_Tooltip) {\n    _inheritsLoose(Popover, _Tooltip);\n\n    function Popover() {\n      return _Tooltip.apply(this, arguments) || this;\n    }\n\n    var _proto = Popover.prototype;\n\n    // Overrides\n    _proto.isWithContent = function isWithContent() {\n      return this.getTitle() || this._getContent();\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default["default"](this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $__default["default"](this.getTipElement()); // We use append for html objects to maintain js events\n\n      this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());\n\n      var content = this._getContent();\n\n      if (typeof content === \'function\') {\n        content = content.call(this.element);\n      }\n\n      this.setElementContent($tip.find(SELECTOR_CONTENT), content);\n      $tip.removeClass(CLASS_NAME_FADE$2 + " " + CLASS_NAME_SHOW$2);\n    } // Private\n    ;\n\n    _proto._getContent = function _getContent() {\n      return this.element.getAttribute(\'data-content\') || this.config.content;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default["default"](this.getTipElement());\n      var tabClass = $tip.attr(\'class\').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(\'\'));\n      }\n    } // Static\n    ;\n\n    Popover._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default["default"](this).data(DATA_KEY$3);\n\n        var _config = typeof config === \'object\' ? config : null;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Popover(this, _config);\n          $__default["default"](this).data(DATA_KEY$3, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Popover, null, [{\n      key: "VERSION",\n      get: // Getters\n      function get() {\n        return VERSION$3;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default$2;\n      }\n    }, {\n      key: "NAME",\n      get: function get() {\n        return NAME$3;\n      }\n    }, {\n      key: "DATA_KEY",\n      get: function get() {\n        return DATA_KEY$3;\n      }\n    }, {\n      key: "Event",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: "EVENT_KEY",\n      get: function get() {\n        return EVENT_KEY$3;\n      }\n    }, {\n      key: "DefaultType",\n      get: function get() {\n        return DefaultType$2;\n      }\n    }]);\n\n    return Popover;\n  }(Tooltip);\n  /**\n   * jQuery\n   */\n\n\n  $__default["default"].fn[NAME$3] = Popover._jQueryInterface;\n  $__default["default"].fn[NAME$3].Constructor = Popover;\n\n  $__default["default"].fn[NAME$3].noConflict = function () {\n    $__default["default"].fn[NAME$3] = JQUERY_NO_CONFLICT$3;\n    return Popover._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$2 = \'scrollspy\';\n  var VERSION$2 = \'4.6.2\';\n  var DATA_KEY$2 = \'bs.scrollspy\';\n  var EVENT_KEY$2 = "." + DATA_KEY$2;\n  var DATA_API_KEY$1 = \'.data-api\';\n  var JQUERY_NO_CONFLICT$2 = $__default["default"].fn[NAME$2];\n  var CLASS_NAME_DROPDOWN_ITEM = \'dropdown-item\';\n  var CLASS_NAME_ACTIVE$1 = \'active\';\n  var EVENT_ACTIVATE = "activate" + EVENT_KEY$2;\n  var EVENT_SCROLL = "scroll" + EVENT_KEY$2;\n  var EVENT_LOAD_DATA_API = "load" + EVENT_KEY$2 + DATA_API_KEY$1;\n  var METHOD_OFFSET = \'offset\';\n  var METHOD_POSITION = \'position\';\n  var SELECTOR_DATA_SPY = \'[data-spy="scroll"]\';\n  var SELECTOR_NAV_LIST_GROUP$1 = \'.nav, .list-group\';\n  var SELECTOR_NAV_LINKS = \'.nav-link\';\n  var SELECTOR_NAV_ITEMS = \'.nav-item\';\n  var SELECTOR_LIST_ITEMS = \'.list-group-item\';\n  var SELECTOR_DROPDOWN$1 = \'.dropdown\';\n  var SELECTOR_DROPDOWN_ITEMS = \'.dropdown-item\';\n  var SELECTOR_DROPDOWN_TOGGLE$1 = \'.dropdown-toggle\';\n  var Default$1 = {\n    offset: 10,\n    method: \'auto\',\n    target: \'\'\n  };\n  var DefaultType$1 = {\n    offset: \'number\',\n    method: \'string\',\n    target: \'(string|element)\'\n  };\n  /**\n   * Class definition\n   */\n\n  var ScrollSpy = /*#__PURE__*/function () {\n    function ScrollSpy(element, config) {\n      var _this = this;\n\n      this._element = element;\n      this._scrollElement = element.tagName === \'BODY\' ? window : element;\n      this._config = this._getConfig(config);\n      this._selector = this._config.target + " " + SELECTOR_NAV_LINKS + "," + (this._config.target + " " + SELECTOR_LIST_ITEMS + ",") + (this._config.target + " " + SELECTOR_DROPDOWN_ITEMS);\n      this._offsets = [];\n      this._targets = [];\n      this._activeTarget = null;\n      this._scrollHeight = 0;\n      $__default["default"](this._scrollElement).on(EVENT_SCROLL, function (event) {\n        return _this._process(event);\n      });\n      this.refresh();\n\n      this._process();\n    } // Getters\n\n\n    var _proto = ScrollSpy.prototype;\n\n    // Public\n    _proto.refresh = function refresh() {\n      var _this2 = this;\n\n      var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\n      var offsetMethod = this._config.method === \'auto\' ? autoMethod : this._config.method;\n      var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\n      this._offsets = [];\n      this._targets = [];\n      this._scrollHeight = this._getScrollHeight();\n      var targets = [].slice.call(document.querySelectorAll(this._selector));\n      targets.map(function (element) {\n        var target;\n        var targetSelector = Util.getSelectorFromElement(element);\n\n        if (targetSelector) {\n          target = document.querySelector(targetSelector);\n        }\n\n        if (target) {\n          var targetBCR = target.getBoundingClientRect();\n\n          if (targetBCR.width || targetBCR.height) {\n            // TODO (fat): remove sketch reliance on jQuery position/offset\n            return [$__default["default"](target)[offsetMethod]().top + offsetBase, targetSelector];\n          }\n        }\n\n        return null;\n      }).filter(Boolean).sort(function (a, b) {\n        return a[0] - b[0];\n      }).forEach(function (item) {\n        _this2._offsets.push(item[0]);\n\n        _this2._targets.push(item[1]);\n      });\n    };\n\n    _proto.dispose = function dispose() {\n      $__default["default"].removeData(this._element, DATA_KEY$2);\n      $__default["default"](this._scrollElement).off(EVENT_KEY$2);\n      this._element = null;\n      this._scrollElement = null;\n      this._config = null;\n      this._selector = null;\n      this._offsets = null;\n      this._targets = null;\n      this._activeTarget = null;\n      this._scrollHeight = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$1, typeof config === \'object\' && config ? config : {});\n\n      if (typeof config.target !== \'string\' && Util.isElement(config.target)) {\n        var id = $__default["default"](config.target).attr(\'id\');\n\n        if (!id) {\n          id = Util.getUID(NAME$2);\n          $__default["default"](config.target).attr(\'id\', id);\n        }\n\n        config.target = "#" + id;\n      }\n\n      Util.typeCheckConfig(NAME$2, config, DefaultType$1);\n      return config;\n    };\n\n    _proto._getScrollTop = function _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    };\n\n    _proto._getScrollHeight = function _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    };\n\n    _proto._getOffsetHeight = function _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    };\n\n    _proto._process = function _process() {\n      var scrollTop = this._getScrollTop() + this._config.offset;\n\n      var scrollHeight = this._getScrollHeight();\n\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n      if (this._scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n\n      if (scrollTop >= maxScroll) {\n        var target = this._targets[this._targets.length - 1];\n\n        if (this._activeTarget !== target) {\n          this._activate(target);\n        }\n\n        return;\n      }\n\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n        this._activeTarget = null;\n\n        this._clear();\n\n        return;\n      }\n\n      for (var i = this._offsets.length; i--;) {\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === \'undefined\' || scrollTop < this._offsets[i + 1]);\n\n        if (isActiveTarget) {\n          this._activate(this._targets[i]);\n        }\n      }\n    };\n\n    _proto._activate = function _activate(target) {\n      this._activeTarget = target;\n\n      this._clear();\n\n      var queries = this._selector.split(\',\').map(function (selector) {\n        return selector + "[data-target=\\"" + target + "\\"]," + selector + "[href=\\"" + target + "\\"]";\n      });\n\n      var $link = $__default["default"]([].slice.call(document.querySelectorAll(queries.join(\',\'))));\n\n      if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {\n        $link.closest(SELECTOR_DROPDOWN$1).find(SELECTOR_DROPDOWN_TOGGLE$1).addClass(CLASS_NAME_ACTIVE$1);\n        $link.addClass(CLASS_NAME_ACTIVE$1);\n      } else {\n        // Set triggered link as active\n        $link.addClass(CLASS_NAME_ACTIVE$1); // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_LINKS + ", " + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$1); // Handle special case when .nav-link is inside .nav-item\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$1);\n      }\n\n      $__default["default"](this._scrollElement).trigger(EVENT_ACTIVATE, {\n        relatedTarget: target\n      });\n    };\n\n    _proto._clear = function _clear() {\n      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {\n        return node.classList.contains(CLASS_NAME_ACTIVE$1);\n      }).forEach(function (node) {\n        return node.classList.remove(CLASS_NAME_ACTIVE$1);\n      });\n    } // Static\n    ;\n\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default["default"](this).data(DATA_KEY$2);\n\n        var _config = typeof config === \'object\' && config;\n\n        if (!data) {\n          data = new ScrollSpy(this, _config);\n          $__default["default"](this).data(DATA_KEY$2, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(ScrollSpy, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$2;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default$1;\n      }\n    }]);\n\n    return ScrollSpy;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](window).on(EVENT_LOAD_DATA_API, function () {\n    var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));\n    var scrollSpysLength = scrollSpys.length;\n\n    for (var i = scrollSpysLength; i--;) {\n      var $spy = $__default["default"](scrollSpys[i]);\n\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$2] = ScrollSpy._jQueryInterface;\n  $__default["default"].fn[NAME$2].Constructor = ScrollSpy;\n\n  $__default["default"].fn[NAME$2].noConflict = function () {\n    $__default["default"].fn[NAME$2] = JQUERY_NO_CONFLICT$2;\n    return ScrollSpy._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$1 = \'tab\';\n  var VERSION$1 = \'4.6.2\';\n  var DATA_KEY$1 = \'bs.tab\';\n  var EVENT_KEY$1 = "." + DATA_KEY$1;\n  var DATA_API_KEY = \'.data-api\';\n  var JQUERY_NO_CONFLICT$1 = $__default["default"].fn[NAME$1];\n  var CLASS_NAME_DROPDOWN_MENU = \'dropdown-menu\';\n  var CLASS_NAME_ACTIVE = \'active\';\n  var CLASS_NAME_DISABLED = \'disabled\';\n  var CLASS_NAME_FADE$1 = \'fade\';\n  var CLASS_NAME_SHOW$1 = \'show\';\n  var EVENT_HIDE$1 = "hide" + EVENT_KEY$1;\n  var EVENT_HIDDEN$1 = "hidden" + EVENT_KEY$1;\n  var EVENT_SHOW$1 = "show" + EVENT_KEY$1;\n  var EVENT_SHOWN$1 = "shown" + EVENT_KEY$1;\n  var EVENT_CLICK_DATA_API = "click" + EVENT_KEY$1 + DATA_API_KEY;\n  var SELECTOR_DROPDOWN = \'.dropdown\';\n  var SELECTOR_NAV_LIST_GROUP = \'.nav, .list-group\';\n  var SELECTOR_ACTIVE = \'.active\';\n  var SELECTOR_ACTIVE_UL = \'> li > .active\';\n  var SELECTOR_DATA_TOGGLE = \'[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]\';\n  var SELECTOR_DROPDOWN_TOGGLE = \'.dropdown-toggle\';\n  var SELECTOR_DROPDOWN_ACTIVE_CHILD = \'> .dropdown-menu .active\';\n  /**\n   * Class definition\n   */\n\n  var Tab = /*#__PURE__*/function () {\n    function Tab(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Tab.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default["default"](this._element).hasClass(CLASS_NAME_ACTIVE) || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED) || this._element.hasAttribute(\'disabled\')) {\n        return;\n      }\n\n      var target;\n      var previous;\n      var listElement = $__default["default"](this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n\n      if (listElement) {\n        var itemSelector = listElement.nodeName === \'UL\' || listElement.nodeName === \'OL\' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;\n        previous = $__default["default"].makeArray($__default["default"](listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n\n      var hideEvent = $__default["default"].Event(EVENT_HIDE$1, {\n        relatedTarget: this._element\n      });\n      var showEvent = $__default["default"].Event(EVENT_SHOW$1, {\n        relatedTarget: previous\n      });\n\n      if (previous) {\n        $__default["default"](previous).trigger(hideEvent);\n      }\n\n      $__default["default"](this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (selector) {\n        target = document.querySelector(selector);\n      }\n\n      this._activate(this._element, listElement);\n\n      var complete = function complete() {\n        var hiddenEvent = $__default["default"].Event(EVENT_HIDDEN$1, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = $__default["default"].Event(EVENT_SHOWN$1, {\n          relatedTarget: previous\n        });\n        $__default["default"](previous).trigger(hiddenEvent);\n        $__default["default"](_this._element).trigger(shownEvent);\n      };\n\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $__default["default"].removeData(this._element, DATA_KEY$1);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._activate = function _activate(element, container, callback) {\n      var _this2 = this;\n\n      var activeElements = container && (container.nodeName === \'UL\' || container.nodeName === \'OL\') ? $__default["default"](container).find(SELECTOR_ACTIVE_UL) : $__default["default"](container).children(SELECTOR_ACTIVE);\n      var active = activeElements[0];\n      var isTransitioning = callback && active && $__default["default"](active).hasClass(CLASS_NAME_FADE$1);\n\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n\n      if (active && isTransitioning) {\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\n        $__default["default"](active).removeClass(CLASS_NAME_SHOW$1).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\n      if (active) {\n        $__default["default"](active).removeClass(CLASS_NAME_ACTIVE);\n        var dropdownChild = $__default["default"](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];\n\n        if (dropdownChild) {\n          $__default["default"](dropdownChild).removeClass(CLASS_NAME_ACTIVE);\n        }\n\n        if (active.getAttribute(\'role\') === \'tab\') {\n          active.setAttribute(\'aria-selected\', false);\n        }\n      }\n\n      $__default["default"](element).addClass(CLASS_NAME_ACTIVE);\n\n      if (element.getAttribute(\'role\') === \'tab\') {\n        element.setAttribute(\'aria-selected\', true);\n      }\n\n      Util.reflow(element);\n\n      if (element.classList.contains(CLASS_NAME_FADE$1)) {\n        element.classList.add(CLASS_NAME_SHOW$1);\n      }\n\n      var parent = element.parentNode;\n\n      if (parent && parent.nodeName === \'LI\') {\n        parent = parent.parentNode;\n      }\n\n      if (parent && $__default["default"](parent).hasClass(CLASS_NAME_DROPDOWN_MENU)) {\n        var dropdownElement = $__default["default"](element).closest(SELECTOR_DROPDOWN)[0];\n\n        if (dropdownElement) {\n          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));\n          $__default["default"](dropdownToggleList).addClass(CLASS_NAME_ACTIVE);\n        }\n\n        element.setAttribute(\'aria-expanded\', true);\n      }\n\n      if (callback) {\n        callback();\n      }\n    } // Static\n    ;\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $__default["default"](this);\n        var data = $this.data(DATA_KEY$1);\n\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY$1, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tab, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION$1;\n      }\n    }]);\n\n    return Tab;\n  }();\n  /**\n   * Data API implementation\n   */\n\n\n  $__default["default"](document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    event.preventDefault();\n\n    Tab._jQueryInterface.call($__default["default"](this), \'show\');\n  });\n  /**\n   * jQuery\n   */\n\n  $__default["default"].fn[NAME$1] = Tab._jQueryInterface;\n  $__default["default"].fn[NAME$1].Constructor = Tab;\n\n  $__default["default"].fn[NAME$1].noConflict = function () {\n    $__default["default"].fn[NAME$1] = JQUERY_NO_CONFLICT$1;\n    return Tab._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME = \'toast\';\n  var VERSION = \'4.6.2\';\n  var DATA_KEY = \'bs.toast\';\n  var EVENT_KEY = "." + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $__default["default"].fn[NAME];\n  var CLASS_NAME_FADE = \'fade\';\n  var CLASS_NAME_HIDE = \'hide\';\n  var CLASS_NAME_SHOW = \'show\';\n  var CLASS_NAME_SHOWING = \'showing\';\n  var EVENT_CLICK_DISMISS = "click.dismiss" + EVENT_KEY;\n  var EVENT_HIDE = "hide" + EVENT_KEY;\n  var EVENT_HIDDEN = "hidden" + EVENT_KEY;\n  var EVENT_SHOW = "show" + EVENT_KEY;\n  var EVENT_SHOWN = "shown" + EVENT_KEY;\n  var SELECTOR_DATA_DISMISS = \'[data-dismiss="toast"]\';\n  var Default = {\n    animation: true,\n    autohide: true,\n    delay: 500\n  };\n  var DefaultType = {\n    animation: \'boolean\',\n    autohide: \'boolean\',\n    delay: \'number\'\n  };\n  /**\n   * Class definition\n   */\n\n  var Toast = /*#__PURE__*/function () {\n    function Toast(element, config) {\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._timeout = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Toast.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n\n      var showEvent = $__default["default"].Event(EVENT_SHOW);\n      $__default["default"](this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._clearTimeout();\n\n      if (this._config.animation) {\n        this._element.classList.add(CLASS_NAME_FADE);\n      }\n\n      var complete = function complete() {\n        _this._element.classList.remove(CLASS_NAME_SHOWING);\n\n        _this._element.classList.add(CLASS_NAME_SHOW);\n\n        $__default["default"](_this._element).trigger(EVENT_SHOWN);\n\n        if (_this._config.autohide) {\n          _this._timeout = setTimeout(function () {\n            _this.hide();\n          }, _this._config.delay);\n        }\n      };\n\n      this._element.classList.remove(CLASS_NAME_HIDE);\n\n      Util.reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_SHOWING);\n\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto.hide = function hide() {\n      if (!this._element.classList.contains(CLASS_NAME_SHOW)) {\n        return;\n      }\n\n      var hideEvent = $__default["default"].Event(EVENT_HIDE);\n      $__default["default"](this._element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._close();\n    };\n\n    _proto.dispose = function dispose() {\n      this._clearTimeout();\n\n      if (this._element.classList.contains(CLASS_NAME_SHOW)) {\n        this._element.classList.remove(CLASS_NAME_SHOW);\n      }\n\n      $__default["default"](this._element).off(EVENT_CLICK_DISMISS);\n      $__default["default"].removeData(this._element, DATA_KEY);\n      this._element = null;\n      this._config = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default, $__default["default"](this._element).data(), typeof config === \'object\' && config ? config : {});\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this2 = this;\n\n      $__default["default"](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function () {\n        return _this2.hide();\n      });\n    };\n\n    _proto._close = function _close() {\n      var _this3 = this;\n\n      var complete = function complete() {\n        _this3._element.classList.add(CLASS_NAME_HIDE);\n\n        $__default["default"](_this3._element).trigger(EVENT_HIDDEN);\n      };\n\n      this._element.classList.remove(CLASS_NAME_SHOW);\n\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto._clearTimeout = function _clearTimeout() {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    } // Static\n    ;\n\n    Toast._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default["default"](this);\n        var data = $element.data(DATA_KEY);\n\n        var _config = typeof config === \'object\' && config;\n\n        if (!data) {\n          data = new Toast(this, _config);\n          $element.data(DATA_KEY, data);\n        }\n\n        if (typeof config === \'string\') {\n          if (typeof data[config] === \'undefined\') {\n            throw new TypeError("No method named \\"" + config + "\\"");\n          }\n\n          data[config](this);\n        }\n      });\n    };\n\n    _createClass(Toast, null, [{\n      key: "VERSION",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: "DefaultType",\n      get: function get() {\n        return DefaultType;\n      }\n    }, {\n      key: "Default",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Toast;\n  }();\n  /**\n   * jQuery\n   */\n\n\n  $__default["default"].fn[NAME] = Toast._jQueryInterface;\n  $__default["default"].fn[NAME].Constructor = Toast;\n\n  $__default["default"].fn[NAME].noConflict = function () {\n    $__default["default"].fn[NAME] = JQUERY_NO_CONFLICT;\n    return Toast._jQueryInterface;\n  };\n\n  exports.Alert = Alert;\n  exports.Button = Button;\n  exports.Carousel = Carousel;\n  exports.Collapse = Collapse;\n  exports.Dropdown = Dropdown;\n  exports.Modal = Modal;\n  exports.Popover = Popover;\n  exports.Scrollspy = ScrollSpy;\n  exports.Tab = Tab;\n  exports.Toast = Toast;\n  exports.Tooltip = Tooltip;\n  exports.Util = Util;\n\n  Object.defineProperty(exports, \'__esModule\', { value: true });\n\n}));\n//# sourceMappingURL=bootstrap.js.map\n\n\n//# sourceURL=webpack://saasymail/./node_modules/bootstrap/dist/js/bootstrap.js?')},"./node_modules/jquery.cookie/jquery.cookie.js":
/*!*****************************************************!*\
  !*** ./node_modules/jquery.cookie/jquery.cookie.js ***!
  \*****************************************************/(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery Cookie Plugin v1.4.1\n * https://github.com/carhartl/jquery-cookie\n *\n * Copyright 2013 Klaus Hartl\n * Released under the MIT license\n */\n(function (factory) {\n\tif (true) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n}(function ($) {\n\n\tvar pluses = /\\+/g;\n\n\tfunction encode(s) {\n\t\treturn config.raw ? s : encodeURIComponent(s);\n\t}\n\n\tfunction decode(s) {\n\t\treturn config.raw ? s : decodeURIComponent(s);\n\t}\n\n\tfunction stringifyCookieValue(value) {\n\t\treturn encode(config.json ? JSON.stringify(value) : String(value));\n\t}\n\n\tfunction parseCookieValue(s) {\n\t\tif (s.indexOf('\"') === 0) {\n\t\t\t// This is a quoted cookie as according to RFC2068, unescape...\n\t\t\ts = s.slice(1, -1).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\n\t\t}\n\n\t\ttry {\n\t\t\t// Replace server-side written pluses with spaces.\n\t\t\t// If we can't decode the cookie, ignore it, it's unusable.\n\t\t\t// If we can't parse the cookie, ignore it, it's unusable.\n\t\t\ts = decodeURIComponent(s.replace(pluses, ' '));\n\t\t\treturn config.json ? JSON.parse(s) : s;\n\t\t} catch(e) {}\n\t}\n\n\tfunction read(s, converter) {\n\t\tvar value = config.raw ? s : parseCookieValue(s);\n\t\treturn $.isFunction(converter) ? converter(value) : value;\n\t}\n\n\tvar config = $.cookie = function (key, value, options) {\n\n\t\t// Write\n\n\t\tif (value !== undefined && !$.isFunction(value)) {\n\t\t\toptions = $.extend({}, config.defaults, options);\n\n\t\t\tif (typeof options.expires === 'number') {\n\t\t\t\tvar days = options.expires, t = options.expires = new Date();\n\t\t\t\tt.setTime(+t + days * 864e+5);\n\t\t\t}\n\n\t\t\treturn (document.cookie = [\n\t\t\t\tencode(key), '=', stringifyCookieValue(value),\n\t\t\t\toptions.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE\n\t\t\t\toptions.path    ? '; path=' + options.path : '',\n\t\t\t\toptions.domain  ? '; domain=' + options.domain : '',\n\t\t\t\toptions.secure  ? '; secure' : ''\n\t\t\t].join(''));\n\t\t}\n\n\t\t// Read\n\n\t\tvar result = key ? undefined : {};\n\n\t\t// To prevent the for loop in the first place assign an empty array\n\t\t// in case there are no cookies at all. Also prevents odd result when\n\t\t// calling $.cookie().\n\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\n\t\tfor (var i = 0, l = cookies.length; i < l; i++) {\n\t\t\tvar parts = cookies[i].split('=');\n\t\t\tvar name = decode(parts.shift());\n\t\t\tvar cookie = parts.join('=');\n\n\t\t\tif (key && key === name) {\n\t\t\t\t// If second argument (value) is a function it's a converter...\n\t\t\t\tresult = read(cookie, value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Prevent storing a cookie that we couldn't decode.\n\t\t\tif (!key && (cookie = read(cookie)) !== undefined) {\n\t\t\t\tresult[name] = cookie;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tconfig.defaults = {};\n\n\t$.removeCookie = function (key, options) {\n\t\tif ($.cookie(key) === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Must not alter options, thus extending a fresh object...\n\t\t$.cookie(key, '', $.extend({}, options, { expires: -1 }));\n\t\treturn !$.cookie(key);\n\t};\n\n}));\n\n\n//# sourceURL=webpack://saasymail/./node_modules/jquery.cookie/jquery.cookie.js?")},"./node_modules/owl.carousel/dist/owl.carousel.js":
/*!********************************************************!*\
  !*** ./node_modules/owl.carousel/dist/owl.carousel.js ***!
  \********************************************************/()=>{eval("/**\n * Owl Carousel v2.3.4\n * Copyright 2013-2018 David Deutsch\n * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE\n */\n/**\n * Owl carousel\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates a carousel.\n\t * @class The Owl Carousel.\n\t * @public\n\t * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n\t * @param {Object} [options] - The options\n\t */\n\tfunction Owl(element, options) {\n\n\t\t/**\n\t\t * Current settings for the carousel.\n\t\t * @public\n\t\t */\n\t\tthis.settings = null;\n\n\t\t/**\n\t\t * Current options set by the caller including defaults.\n\t\t * @public\n\t\t */\n\t\tthis.options = $.extend({}, Owl.Defaults, options);\n\n\t\t/**\n\t\t * Plugin element.\n\t\t * @public\n\t\t */\n\t\tthis.$element = $(element);\n\n\t\t/**\n\t\t * Proxied event handlers.\n\t\t * @protected\n\t\t */\n\t\tthis._handlers = {};\n\n\t\t/**\n\t\t * References to the running plugins of this carousel.\n\t\t * @protected\n\t\t */\n\t\tthis._plugins = {};\n\n\t\t/**\n\t\t * Currently suppressed events to prevent them from being retriggered.\n\t\t * @protected\n\t\t */\n\t\tthis._supress = {};\n\n\t\t/**\n\t\t * Absolute current position.\n\t\t * @protected\n\t\t */\n\t\tthis._current = null;\n\n\t\t/**\n\t\t * Animation speed in milliseconds.\n\t\t * @protected\n\t\t */\n\t\tthis._speed = null;\n\n\t\t/**\n\t\t * Coordinates of all items in pixel.\n\t\t * @todo The name of this member is missleading.\n\t\t * @protected\n\t\t */\n\t\tthis._coordinates = [];\n\n\t\t/**\n\t\t * Current breakpoint.\n\t\t * @todo Real media queries would be nice.\n\t\t * @protected\n\t\t */\n\t\tthis._breakpoint = null;\n\n\t\t/**\n\t\t * Current width of the plugin element.\n\t\t */\n\t\tthis._width = null;\n\n\t\t/**\n\t\t * All real items.\n\t\t * @protected\n\t\t */\n\t\tthis._items = [];\n\n\t\t/**\n\t\t * All cloned items.\n\t\t * @protected\n\t\t */\n\t\tthis._clones = [];\n\n\t\t/**\n\t\t * Merge values of all items.\n\t\t * @todo Maybe this could be part of a plugin.\n\t\t * @protected\n\t\t */\n\t\tthis._mergers = [];\n\n\t\t/**\n\t\t * Widths of all items.\n\t\t */\n\t\tthis._widths = [];\n\n\t\t/**\n\t\t * Invalidated parts within the update process.\n\t\t * @protected\n\t\t */\n\t\tthis._invalidated = {};\n\n\t\t/**\n\t\t * Ordered list of workers for the update process.\n\t\t * @protected\n\t\t */\n\t\tthis._pipe = [];\n\n\t\t/**\n\t\t * Current state information for the drag operation.\n\t\t * @todo #261\n\t\t * @protected\n\t\t */\n\t\tthis._drag = {\n\t\t\ttime: null,\n\t\t\ttarget: null,\n\t\t\tpointer: null,\n\t\t\tstage: {\n\t\t\t\tstart: null,\n\t\t\t\tcurrent: null\n\t\t\t},\n\t\t\tdirection: null\n\t\t};\n\n\t\t/**\n\t\t * Current state information and their tags.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis._states = {\n\t\t\tcurrent: {},\n\t\t\ttags: {\n\t\t\t\t'initializing': [ 'busy' ],\n\t\t\t\t'animating': [ 'busy' ],\n\t\t\t\t'dragging': [ 'interacting' ]\n\t\t\t}\n\t\t};\n\n\t\t$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {\n\t\t\tthis._handlers[handler] = $.proxy(this[handler], this);\n\t\t}, this));\n\n\t\t$.each(Owl.Plugins, $.proxy(function(key, plugin) {\n\t\t\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)]\n\t\t\t\t= new plugin(this);\n\t\t}, this));\n\n\t\t$.each(Owl.Workers, $.proxy(function(priority, worker) {\n\t\t\tthis._pipe.push({\n\t\t\t\t'filter': worker.filter,\n\t\t\t\t'run': $.proxy(worker.run, this)\n\t\t\t});\n\t\t}, this));\n\n\t\tthis.setup();\n\t\tthis.initialize();\n\t}\n\n\t/**\n\t * Default options for the carousel.\n\t * @public\n\t */\n\tOwl.Defaults = {\n\t\titems: 3,\n\t\tloop: false,\n\t\tcenter: false,\n\t\trewind: false,\n\t\tcheckVisibility: true,\n\n\t\tmouseDrag: true,\n\t\ttouchDrag: true,\n\t\tpullDrag: true,\n\t\tfreeDrag: false,\n\n\t\tmargin: 0,\n\t\tstagePadding: 0,\n\n\t\tmerge: false,\n\t\tmergeFit: true,\n\t\tautoWidth: false,\n\n\t\tstartPosition: 0,\n\t\trtl: false,\n\n\t\tsmartSpeed: 250,\n\t\tfluidSpeed: false,\n\t\tdragEndSpeed: false,\n\n\t\tresponsive: {},\n\t\tresponsiveRefreshRate: 200,\n\t\tresponsiveBaseElement: window,\n\n\t\tfallbackEasing: 'swing',\n\t\tslideTransition: '',\n\n\t\tinfo: false,\n\n\t\tnestedItemSelector: false,\n\t\titemElement: 'div',\n\t\tstageElement: 'div',\n\n\t\trefreshClass: 'owl-refresh',\n\t\tloadedClass: 'owl-loaded',\n\t\tloadingClass: 'owl-loading',\n\t\trtlClass: 'owl-rtl',\n\t\tresponsiveClass: 'owl-responsive',\n\t\tdragClass: 'owl-drag',\n\t\titemClass: 'owl-item',\n\t\tstageClass: 'owl-stage',\n\t\tstageOuterClass: 'owl-stage-outer',\n\t\tgrabClass: 'owl-grab'\n\t};\n\n\t/**\n\t * Enumeration for width.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n\tOwl.Width = {\n\t\tDefault: 'default',\n\t\tInner: 'inner',\n\t\tOuter: 'outer'\n\t};\n\n\t/**\n\t * Enumeration for types.\n\t * @public\n\t * @readonly\n\t * @enum {String}\n\t */\n\tOwl.Type = {\n\t\tEvent: 'event',\n\t\tState: 'state'\n\t};\n\n\t/**\n\t * Contains all registered plugins.\n\t * @public\n\t */\n\tOwl.Plugins = {};\n\n\t/**\n\t * List of workers involved in the update process.\n\t */\n\tOwl.Workers = [ {\n\t\tfilter: [ 'width', 'settings' ],\n\t\trun: function() {\n\t\t\tthis._width = this.$element.width();\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tcache.current = this._items && this._items[this.relative(this._current)];\n\t\t}\n\t}, {\n\t\tfilter: [ 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tthis.$stage.children('.cloned').remove();\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar margin = this.settings.margin || '',\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\trtl = this.settings.rtl,\n\t\t\t\tcss = {\n\t\t\t\t\t'width': 'auto',\n\t\t\t\t\t'margin-left': rtl ? margin : '',\n\t\t\t\t\t'margin-right': rtl ? '' : margin\n\t\t\t\t};\n\n\t\t\t!grid && this.$stage.children().css(css);\n\n\t\t\tcache.css = css;\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n\t\t\t\tmerge = null,\n\t\t\t\titerator = this._items.length,\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\twidths = [];\n\n\t\t\tcache.items = {\n\t\t\t\tmerge: false,\n\t\t\t\twidth: width\n\t\t\t};\n\n\t\t\twhile (iterator--) {\n\t\t\t\tmerge = this._mergers[iterator];\n\t\t\t\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n\t\t\t\tcache.items.merge = merge > 1 || cache.items.merge;\n\n\t\t\t\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n\t\t\t}\n\n\t\t\tthis._widths = widths;\n\t\t}\n\t}, {\n\t\tfilter: [ 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar clones = [],\n\t\t\t\titems = this._items,\n\t\t\t\tsettings = this.settings,\n\t\t\t\t// TODO: Should be computed from number of min width items in stage\n\t\t\t\tview = Math.max(settings.items * 2, 4),\n\t\t\t\tsize = Math.ceil(items.length / 2) * 2,\n\t\t\t\trepeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n\t\t\t\tappend = '',\n\t\t\t\tprepend = '';\n\n\t\t\trepeat /= 2;\n\n\t\t\twhile (repeat > 0) {\n\t\t\t\t// Switch to only using appended clones\n\t\t\t\tclones.push(this.normalize(clones.length / 2, true));\n\t\t\t\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\n\t\t\t\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n\t\t\t\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n\t\t\t\trepeat -= 1;\n\t\t\t}\n\n\t\t\tthis._clones = clones;\n\n\t\t\t$(append).addClass('cloned').appendTo(this.$stage);\n\t\t\t$(prepend).addClass('cloned').prependTo(this.$stage);\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t\tsize = this._clones.length + this._items.length,\n\t\t\t\titerator = -1,\n\t\t\t\tprevious = 0,\n\t\t\t\tcurrent = 0,\n\t\t\t\tcoordinates = [];\n\n\t\t\twhile (++iterator < size) {\n\t\t\t\tprevious = coordinates[iterator - 1] || 0;\n\t\t\t\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\n\t\t\t\tcoordinates.push(previous + current * rtl);\n\t\t\t}\n\n\t\t\tthis._coordinates = coordinates;\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar padding = this.settings.stagePadding,\n\t\t\t\tcoordinates = this._coordinates,\n\t\t\t\tcss = {\n\t\t\t\t\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n\t\t\t\t\t'padding-left': padding || '',\n\t\t\t\t\t'padding-right': padding || ''\n\t\t\t\t};\n\n\t\t\tthis.$stage.css(css);\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tvar iterator = this._coordinates.length,\n\t\t\t\tgrid = !this.settings.autoWidth,\n\t\t\t\titems = this.$stage.children();\n\n\t\t\tif (grid && cache.items.merge) {\n\t\t\t\twhile (iterator--) {\n\t\t\t\t\tcache.css.width = this._widths[this.relative(iterator)];\n\t\t\t\t\titems.eq(iterator).css(cache.css);\n\t\t\t\t}\n\t\t\t} else if (grid) {\n\t\t\t\tcache.css.width = cache.items.width;\n\t\t\t\titems.css(cache.css);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tfilter: [ 'items' ],\n\t\trun: function() {\n\t\t\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'items', 'settings' ],\n\t\trun: function(cache) {\n\t\t\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n\t\t\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n\t\t\tthis.reset(cache.current);\n\t\t}\n\t}, {\n\t\tfilter: [ 'position' ],\n\t\trun: function() {\n\t\t\tthis.animate(this.coordinates(this._current));\n\t\t}\n\t}, {\n\t\tfilter: [ 'width', 'position', 'items', 'settings' ],\n\t\trun: function() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t\tpadding = this.settings.stagePadding * 2,\n\t\t\t\tbegin = this.coordinates(this.current()) + padding,\n\t\t\t\tend = begin + this.width() * rtl,\n\t\t\t\tinner, outer, matches = [], i, n;\n\n\t\t\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\n\t\t\t\tinner = this._coordinates[i - 1] || 0;\n\t\t\t\touter = Math.abs(this._coordinates[i]) + padding * rtl;\n\n\t\t\t\tif ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))\n\t\t\t\t\t|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {\n\t\t\t\t\tmatches.push(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.$stage.children('.active').removeClass('active');\n\t\t\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n\t\t\tthis.$stage.children('.center').removeClass('center');\n\t\t\tif (this.settings.center) {\n\t\t\t\tthis.$stage.children().eq(this.current()).addClass('center');\n\t\t\t}\n\t\t}\n\t} ];\n\n\t/**\n\t * Create the stage DOM element\n\t */\n\tOwl.prototype.initializeStage = function() {\n\t\tthis.$stage = this.$element.find('.' + this.settings.stageClass);\n\n\t\t// if the stage is already in the DOM, grab it and skip stage initialization\n\t\tif (this.$stage.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.$element.addClass(this.options.loadingClass);\n\n\t\t// create stage\n\t\tthis.$stage = $('<' + this.settings.stageElement + '>', {\n\t\t\t\"class\": this.settings.stageClass\n\t\t}).wrap( $( '<div/>', {\n\t\t\t\"class\": this.settings.stageOuterClass\n\t\t}));\n\n\t\t// append stage\n\t\tthis.$element.append(this.$stage.parent());\n\t};\n\n\t/**\n\t * Create item DOM elements\n\t */\n\tOwl.prototype.initializeItems = function() {\n\t\tvar $items = this.$element.find('.owl-item');\n\n\t\t// if the items are already in the DOM, grab them and skip item initialization\n\t\tif ($items.length) {\n\t\t\tthis._items = $items.get().map(function(item) {\n\t\t\t\treturn $(item);\n\t\t\t});\n\n\t\t\tthis._mergers = this._items.map(function() {\n\t\t\t\treturn 1;\n\t\t\t});\n\n\t\t\tthis.refresh();\n\n\t\t\treturn;\n\t\t}\n\n\t\t// append content\n\t\tthis.replace(this.$element.children().not(this.$stage.parent()));\n\n\t\t// check visibility\n\t\tif (this.isVisible()) {\n\t\t\t// update view\n\t\t\tthis.refresh();\n\t\t} else {\n\t\t\t// invalidate width\n\t\t\tthis.invalidate('width');\n\t\t}\n\n\t\tthis.$element\n\t\t\t.removeClass(this.options.loadingClass)\n\t\t\t.addClass(this.options.loadedClass);\n\t};\n\n\t/**\n\t * Initializes the carousel.\n\t * @protected\n\t */\n\tOwl.prototype.initialize = function() {\n\t\tthis.enter('initializing');\n\t\tthis.trigger('initialize');\n\n\t\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n\t\tif (this.settings.autoWidth && !this.is('pre-loading')) {\n\t\t\tvar imgs, nestedSelector, width;\n\t\t\timgs = this.$element.find('img');\n\t\t\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n\t\t\twidth = this.$element.children(nestedSelector).width();\n\n\t\t\tif (imgs.length && width <= 0) {\n\t\t\t\tthis.preloadAutoWidthImages(imgs);\n\t\t\t}\n\t\t}\n\n\t\tthis.initializeStage();\n\t\tthis.initializeItems();\n\n\t\t// register event handlers\n\t\tthis.registerEventHandlers();\n\n\t\tthis.leave('initializing');\n\t\tthis.trigger('initialized');\n\t};\n\n\t/**\n\t * @returns {Boolean} visibility of $element\n\t *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to\n\t *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does\n\t */\n\tOwl.prototype.isVisible = function() {\n\t\treturn this.settings.checkVisibility\n\t\t\t? this.$element.is(':visible')\n\t\t\t: true;\n\t};\n\n\t/**\n\t * Setups the current settings.\n\t * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n\t * @todo Support for media queries by using `matchMedia` would be nice.\n\t * @public\n\t */\n\tOwl.prototype.setup = function() {\n\t\tvar viewport = this.viewport(),\n\t\t\toverwrites = this.options.responsive,\n\t\t\tmatch = -1,\n\t\t\tsettings = null;\n\n\t\tif (!overwrites) {\n\t\t\tsettings = $.extend({}, this.options);\n\t\t} else {\n\t\t\t$.each(overwrites, function(breakpoint) {\n\t\t\t\tif (breakpoint <= viewport && breakpoint > match) {\n\t\t\t\t\tmatch = Number(breakpoint);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tsettings = $.extend({}, this.options, overwrites[match]);\n\t\t\tif (typeof settings.stagePadding === 'function') {\n\t\t\t\tsettings.stagePadding = settings.stagePadding();\n\t\t\t}\n\t\t\tdelete settings.responsive;\n\n\t\t\t// responsive class\n\t\t\tif (settings.responsiveClass) {\n\t\t\t\tthis.$element.attr('class',\n\t\t\t\t\tthis.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.trigger('change', { property: { name: 'settings', value: settings } });\n\t\tthis._breakpoint = match;\n\t\tthis.settings = settings;\n\t\tthis.invalidate('settings');\n\t\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\n\t};\n\n\t/**\n\t * Updates option logic if necessery.\n\t * @protected\n\t */\n\tOwl.prototype.optionsLogic = function() {\n\t\tif (this.settings.autoWidth) {\n\t\t\tthis.settings.stagePadding = false;\n\t\t\tthis.settings.merge = false;\n\t\t}\n\t};\n\n\t/**\n\t * Prepares an item before add.\n\t * @todo Rename event parameter `content` to `item`.\n\t * @protected\n\t * @returns {jQuery|HTMLElement} - The item container.\n\t */\n\tOwl.prototype.prepare = function(item) {\n\t\tvar event = this.trigger('prepare', { content: item });\n\n\t\tif (!event.data) {\n\t\t\tevent.data = $('<' + this.settings.itemElement + '/>')\n\t\t\t\t.addClass(this.options.itemClass).append(item)\n\t\t}\n\n\t\tthis.trigger('prepared', { content: event.data });\n\n\t\treturn event.data;\n\t};\n\n\t/**\n\t * Updates the view.\n\t * @public\n\t */\n\tOwl.prototype.update = function() {\n\t\tvar i = 0,\n\t\t\tn = this._pipe.length,\n\t\t\tfilter = $.proxy(function(p) { return this[p] }, this._invalidated),\n\t\t\tcache = {};\n\n\t\twhile (i < n) {\n\t\t\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n\t\t\t\tthis._pipe[i].run(cache);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tthis._invalidated = {};\n\n\t\t!this.is('valid') && this.enter('valid');\n\t};\n\n\t/**\n\t * Gets the width of the view.\n\t * @public\n\t * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n\t * @returns {Number} - The width of the view in pixel.\n\t */\n\tOwl.prototype.width = function(dimension) {\n\t\tdimension = dimension || Owl.Width.Default;\n\t\tswitch (dimension) {\n\t\t\tcase Owl.Width.Inner:\n\t\t\tcase Owl.Width.Outer:\n\t\t\t\treturn this._width;\n\t\t\tdefault:\n\t\t\t\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\n\t\t}\n\t};\n\n\t/**\n\t * Refreshes the carousel primarily for adaptive purposes.\n\t * @public\n\t */\n\tOwl.prototype.refresh = function() {\n\t\tthis.enter('refreshing');\n\t\tthis.trigger('refresh');\n\n\t\tthis.setup();\n\n\t\tthis.optionsLogic();\n\n\t\tthis.$element.addClass(this.options.refreshClass);\n\n\t\tthis.update();\n\n\t\tthis.$element.removeClass(this.options.refreshClass);\n\n\t\tthis.leave('refreshing');\n\t\tthis.trigger('refreshed');\n\t};\n\n\t/**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n\tOwl.prototype.onThrottledResize = function() {\n\t\twindow.clearTimeout(this.resizeTimer);\n\t\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n\t};\n\n\t/**\n\t * Checks window `resize` event.\n\t * @protected\n\t */\n\tOwl.prototype.onResize = function() {\n\t\tif (!this._items.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._width === this.$element.width()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.isVisible()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.enter('resizing');\n\n\t\tif (this.trigger('resize').isDefaultPrevented()) {\n\t\t\tthis.leave('resizing');\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.invalidate('width');\n\n\t\tthis.refresh();\n\n\t\tthis.leave('resizing');\n\t\tthis.trigger('resized');\n\t};\n\n\t/**\n\t * Registers event handlers.\n\t * @todo Check `msPointerEnabled`\n\t * @todo #261\n\t * @protected\n\t */\n\tOwl.prototype.registerEventHandlers = function() {\n\t\tif ($.support.transition) {\n\t\t\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n\t\t}\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\tthis.on(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tif (this.settings.mouseDrag) {\n\t\t\tthis.$element.addClass(this.options.dragClass);\n\t\t\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });\n\t\t}\n\n\t\tif (this.settings.touchDrag){\n\t\t\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n\t\t}\n\t};\n\n\t/**\n\t * Handles `touchstart` and `mousedown` events.\n\t * @todo Horizontal swipe threshold as option\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragStart = function(event) {\n\t\tvar stage = null;\n\n\t\tif (event.which === 3) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ($.support.transform) {\n\t\t\tstage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n\t\t\tstage = {\n\t\t\t\tx: stage[stage.length === 16 ? 12 : 4],\n\t\t\t\ty: stage[stage.length === 16 ? 13 : 5]\n\t\t\t};\n\t\t} else {\n\t\t\tstage = this.$stage.position();\n\t\t\tstage = {\n\t\t\t\tx: this.settings.rtl ?\n\t\t\t\t\tstage.left + this.$stage.width() - this.width() + this.settings.margin :\n\t\t\t\t\tstage.left,\n\t\t\t\ty: stage.top\n\t\t\t};\n\t\t}\n\n\t\tif (this.is('animating')) {\n\t\t\t$.support.transform ? this.animate(stage.x) : this.$stage.stop()\n\t\t\tthis.invalidate('position');\n\t\t}\n\n\t\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n\t\tthis.speed(0);\n\n\t\tthis._drag.time = new Date().getTime();\n\t\tthis._drag.target = $(event.target);\n\t\tthis._drag.stage.start = stage;\n\t\tthis._drag.stage.current = stage;\n\t\tthis._drag.pointer = this.pointer(event);\n\n\t\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n\t\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {\n\t\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\n\n\t\t\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n\t\t\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\n\t\t\tthis.enter('dragging');\n\t\t\tthis.trigger('drag');\n\t\t}, this));\n\t};\n\n\t/**\n\t * Handles the `touchmove` and `mousemove` events.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragMove = function(event) {\n\t\tvar minimum = null,\n\t\t\tmaximum = null,\n\t\t\tpull = null,\n\t\t\tdelta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t\tstage = this.difference(this._drag.stage.start, delta);\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tif (this.settings.loop) {\n\t\t\tminimum = this.coordinates(this.minimum());\n\t\t\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\n\t\t\tstage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;\n\t\t} else {\n\t\t\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n\t\t\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n\t\t\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n\t\t\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n\t\t}\n\n\t\tthis._drag.stage.current = stage;\n\n\t\tthis.animate(stage.x);\n\t};\n\n\t/**\n\t * Handles the `touchend` and `mouseup` events.\n\t * @todo #261\n\t * @todo Threshold for click event\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onDragEnd = function(event) {\n\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t\tstage = this._drag.stage.current,\n\t\t\tdirection = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n\t\t$(document).off('.owl.core');\n\n\t\tthis.$element.removeClass(this.options.grabClass);\n\n\t\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n\t\t\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n\t\t\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n\t\t\tthis.invalidate('position');\n\t\t\tthis.update();\n\n\t\t\tthis._drag.direction = direction;\n\n\t\t\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n\t\t\t\tthis._drag.target.one('click.owl.core', function() { return false; });\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.leave('dragging');\n\t\tthis.trigger('dragged');\n\t};\n\n\t/**\n\t * Gets absolute position of the closest item for a coordinate.\n\t * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n\t * @protected\n\t * @param {Number} coordinate - The coordinate in pixel.\n\t * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n\t * @return {Number} - The absolute position of the closest item.\n\t */\n\tOwl.prototype.closest = function(coordinate, direction) {\n\t\tvar position = -1,\n\t\t\tpull = 30,\n\t\t\twidth = this.width(),\n\t\t\tcoordinates = this.coordinates();\n\n\t\tif (!this.settings.freeDrag) {\n\t\t\t// check closest item\n\t\t\t$.each(coordinates, $.proxy(function(index, value) {\n\t\t\t\t// on a left pull, check on current index\n\t\t\t\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n\t\t\t\t\tposition = index;\n\t\t\t\t// on a right pull, check on previous index\n\t\t\t\t// to do so, subtract width from value and set position = index + 1\n\t\t\t\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n\t\t\t\t\tposition = index + 1;\n\t\t\t\t} else if (this.op(coordinate, '<', value)\n\t\t\t\t\t&& this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {\n\t\t\t\t\tposition = direction === 'left' ? index + 1 : index;\n\t\t\t\t}\n\t\t\t\treturn position === -1;\n\t\t\t}, this));\n\t\t}\n\n\t\tif (!this.settings.loop) {\n\t\t\t// non loop boundries\n\t\t\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\n\t\t\t\tposition = coordinate = this.minimum();\n\t\t\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n\t\t\t\tposition = coordinate = this.maximum();\n\t\t\t}\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Animates the stage.\n\t * @todo #270\n\t * @public\n\t * @param {Number} coordinate - The coordinate in pixels.\n\t */\n\tOwl.prototype.animate = function(coordinate) {\n\t\tvar animate = this.speed() > 0;\n\n\t\tthis.is('animating') && this.onTransitionEnd();\n\n\t\tif (animate) {\n\t\t\tthis.enter('animating');\n\t\t\tthis.trigger('translate');\n\t\t}\n\n\t\tif ($.support.transform3d && $.support.transition) {\n\t\t\tthis.$stage.css({\n\t\t\t\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\n\t\t\t\ttransition: (this.speed() / 1000) + 's' + (\n\t\t\t\t\tthis.settings.slideTransition ? ' ' + this.settings.slideTransition : ''\n\t\t\t\t)\n\t\t\t});\n\t\t} else if (animate) {\n\t\t\tthis.$stage.animate({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n\t\t} else {\n\t\t\tthis.$stage.css({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Checks whether the carousel is in a specific state or not.\n\t * @param {String} state - The state to check.\n\t * @returns {Boolean} - The flag which indicates if the carousel is busy.\n\t */\n\tOwl.prototype.is = function(state) {\n\t\treturn this._states.current[state] && this._states.current[state] > 0;\n\t};\n\n\t/**\n\t * Sets the absolute position of the current item.\n\t * @public\n\t * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n\t * @returns {Number} - The absolute position of the current item.\n\t */\n\tOwl.prototype.current = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._current;\n\t\t}\n\n\t\tif (this._items.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tposition = this.normalize(position);\n\n\t\tif (this._current !== position) {\n\t\t\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\n\n\t\t\tif (event.data !== undefined) {\n\t\t\t\tposition = this.normalize(event.data);\n\t\t\t}\n\n\t\t\tthis._current = position;\n\n\t\t\tthis.invalidate('position');\n\n\t\t\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\n\t\t}\n\n\t\treturn this._current;\n\t};\n\n\t/**\n\t * Invalidates the given part of the update routine.\n\t * @param {String} [part] - The part to invalidate.\n\t * @returns {Array.<String>} - The invalidated parts.\n\t */\n\tOwl.prototype.invalidate = function(part) {\n\t\tif ($.type(part) === 'string') {\n\t\t\tthis._invalidated[part] = true;\n\t\t\tthis.is('valid') && this.leave('valid');\n\t\t}\n\t\treturn $.map(this._invalidated, function(v, i) { return i });\n\t};\n\n\t/**\n\t * Resets the absolute position of the current item.\n\t * @public\n\t * @param {Number} position - The absolute position of the new item.\n\t */\n\tOwl.prototype.reset = function(position) {\n\t\tposition = this.normalize(position);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._speed = 0;\n\t\tthis._current = position;\n\n\t\tthis.suppress([ 'translate', 'translated' ]);\n\n\t\tthis.animate(this.coordinates(position));\n\n\t\tthis.release([ 'translate', 'translated' ]);\n\t};\n\n\t/**\n\t * Normalizes an absolute or a relative position of an item.\n\t * @public\n\t * @param {Number} position - The absolute or relative position to normalize.\n\t * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n\t * @returns {Number} - The normalized position.\n\t */\n\tOwl.prototype.normalize = function(position, relative) {\n\t\tvar n = this._items.length,\n\t\t\tm = relative ? 0 : this._clones.length;\n\n\t\tif (!this.isNumeric(position) || n < 1) {\n\t\t\tposition = undefined;\n\t\t} else if (position < 0 || position >= n + m) {\n\t\t\tposition = ((position - m / 2) % n + n) % n + m / 2;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Converts an absolute position of an item into a relative one.\n\t * @public\n\t * @param {Number} position - The absolute position to convert.\n\t * @returns {Number} - The converted position.\n\t */\n\tOwl.prototype.relative = function(position) {\n\t\tposition -= this._clones.length / 2;\n\t\treturn this.normalize(position, true);\n\t};\n\n\t/**\n\t * Gets the maximum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n\tOwl.prototype.maximum = function(relative) {\n\t\tvar settings = this.settings,\n\t\t\tmaximum = this._coordinates.length,\n\t\t\titerator,\n\t\t\treciprocalItemsWidth,\n\t\t\telementWidth;\n\n\t\tif (settings.loop) {\n\t\t\tmaximum = this._clones.length / 2 + this._items.length - 1;\n\t\t} else if (settings.autoWidth || settings.merge) {\n\t\t\titerator = this._items.length;\n\t\t\tif (iterator) {\n\t\t\t\treciprocalItemsWidth = this._items[--iterator].width();\n\t\t\t\telementWidth = this.$element.width();\n\t\t\t\twhile (iterator--) {\n\t\t\t\t\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n\t\t\t\t\tif (reciprocalItemsWidth > elementWidth) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaximum = iterator + 1;\n\t\t} else if (settings.center) {\n\t\t\tmaximum = this._items.length - 1;\n\t\t} else {\n\t\t\tmaximum = this._items.length - settings.items;\n\t\t}\n\n\t\tif (relative) {\n\t\t\tmaximum -= this._clones.length / 2;\n\t\t}\n\n\t\treturn Math.max(maximum, 0);\n\t};\n\n\t/**\n\t * Gets the minimum position for the current item.\n\t * @public\n\t * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n\t * @returns {Number}\n\t */\n\tOwl.prototype.minimum = function(relative) {\n\t\treturn relative ? 0 : this._clones.length / 2;\n\t};\n\n\t/**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n\tOwl.prototype.items = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._items.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._items[position];\n\t};\n\n\t/**\n\t * Gets an item at the specified relative position.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n\t */\n\tOwl.prototype.mergers = function(position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._mergers.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._mergers[position];\n\t};\n\n\t/**\n\t * Gets the absolute positions of clones for an item.\n\t * @public\n\t * @param {Number} [position] - The relative position of the item.\n\t * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n\t */\n\tOwl.prototype.clones = function(position) {\n\t\tvar odd = this._clones.length / 2,\n\t\t\teven = odd + this._items.length,\n\t\t\tmap = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._clones, function(v, i) { return map(i) });\n\t\t}\n\n\t\treturn $.map(this._clones, function(v, i) { return v === position ? map(i) : null });\n\t};\n\n\t/**\n\t * Sets the current animation speed.\n\t * @public\n\t * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n\t * @returns {Number} - The current animation speed in milliseconds.\n\t */\n\tOwl.prototype.speed = function(speed) {\n\t\tif (speed !== undefined) {\n\t\t\tthis._speed = speed;\n\t\t}\n\n\t\treturn this._speed;\n\t};\n\n\t/**\n\t * Gets the coordinate of an item.\n\t * @todo The name of this method is missleanding.\n\t * @public\n\t * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n\t * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n\t */\n\tOwl.prototype.coordinates = function(position) {\n\t\tvar multiplier = 1,\n\t\t\tnewPosition = position - 1,\n\t\t\tcoordinate;\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._coordinates, $.proxy(function(coordinate, index) {\n\t\t\t\treturn this.coordinates(index);\n\t\t\t}, this));\n\t\t}\n\n\t\tif (this.settings.center) {\n\t\t\tif (this.settings.rtl) {\n\t\t\t\tmultiplier = -1;\n\t\t\t\tnewPosition = position + 1;\n\t\t\t}\n\n\t\t\tcoordinate = this._coordinates[position];\n\t\t\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n\t\t} else {\n\t\t\tcoordinate = this._coordinates[newPosition] || 0;\n\t\t}\n\n\t\tcoordinate = Math.ceil(coordinate);\n\n\t\treturn coordinate;\n\t};\n\n\t/**\n\t * Calculates the speed for a translation.\n\t * @protected\n\t * @param {Number} from - The absolute position of the start item.\n\t * @param {Number} to - The absolute position of the target item.\n\t * @param {Number} [factor=undefined] - The time factor in milliseconds.\n\t * @returns {Number} - The time in milliseconds for the translation.\n\t */\n\tOwl.prototype.duration = function(from, to, factor) {\n\t\tif (factor === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));\n\t};\n\n\t/**\n\t * Slides to the specified item.\n\t * @public\n\t * @param {Number} position - The position of the item.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.to = function(position, speed) {\n\t\tvar current = this.current(),\n\t\t\trevert = null,\n\t\t\tdistance = position - this.relative(current),\n\t\t\tdirection = (distance > 0) - (distance < 0),\n\t\t\titems = this._items.length,\n\t\t\tminimum = this.minimum(),\n\t\t\tmaximum = this.maximum();\n\n\t\tif (this.settings.loop) {\n\t\t\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\n\t\t\t\tdistance += direction * -1 * items;\n\t\t\t}\n\n\t\t\tposition = current + distance;\n\t\t\trevert = ((position - minimum) % items + items) % items + minimum;\n\n\t\t\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n\t\t\t\tcurrent = revert - distance;\n\t\t\t\tposition = revert;\n\t\t\t\tthis.reset(current);\n\t\t\t}\n\t\t} else if (this.settings.rewind) {\n\t\t\tmaximum += 1;\n\t\t\tposition = (position % maximum + maximum) % maximum;\n\t\t} else {\n\t\t\tposition = Math.max(minimum, Math.min(maximum, position));\n\t\t}\n\n\t\tthis.speed(this.duration(current, position, speed));\n\t\tthis.current(position);\n\n\t\tif (this.isVisible()) {\n\t\t\tthis.update();\n\t\t}\n\t};\n\n\t/**\n\t * Slides to the next item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.next = function(speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) + 1, speed);\n\t};\n\n\t/**\n\t * Slides to the previous item.\n\t * @public\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t */\n\tOwl.prototype.prev = function(speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) - 1, speed);\n\t};\n\n\t/**\n\t * Handles the end of an animation.\n\t * @protected\n\t * @param {Event} event - The event arguments.\n\t */\n\tOwl.prototype.onTransitionEnd = function(event) {\n\n\t\t// if css2 animation then event object is undefined\n\t\tif (event !== undefined) {\n\t\t\tevent.stopPropagation();\n\n\t\t\t// Catch only owl-stage transitionEnd event\n\t\t\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.leave('animating');\n\t\tthis.trigger('translated');\n\t};\n\n\t/**\n\t * Gets viewport width.\n\t * @protected\n\t * @return {Number} - The width in pixel.\n\t */\n\tOwl.prototype.viewport = function() {\n\t\tvar width;\n\t\tif (this.options.responsiveBaseElement !== window) {\n\t\t\twidth = $(this.options.responsiveBaseElement).width();\n\t\t} else if (window.innerWidth) {\n\t\t\twidth = window.innerWidth;\n\t\t} else if (document.documentElement && document.documentElement.clientWidth) {\n\t\t\twidth = document.documentElement.clientWidth;\n\t\t} else {\n\t\t\tconsole.warn('Can not detect viewport width.');\n\t\t}\n\t\treturn width;\n\t};\n\n\t/**\n\t * Replaces the current content.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The new content.\n\t */\n\tOwl.prototype.replace = function(content) {\n\t\tthis.$stage.empty();\n\t\tthis._items = [];\n\n\t\tif (content) {\n\t\t\tcontent = (content instanceof jQuery) ? content : $(content);\n\t\t}\n\n\t\tif (this.settings.nestedItemSelector) {\n\t\t\tcontent = content.find('.' + this.settings.nestedItemSelector);\n\t\t}\n\n\t\tcontent.filter(function() {\n\t\t\treturn this.nodeType === 1;\n\t\t}).each($.proxy(function(index, item) {\n\t\t\titem = this.prepare(item);\n\t\t\tthis.$stage.append(item);\n\t\t\tthis._items.push(item);\n\t\t\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}, this));\n\n\t\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n\t\tthis.invalidate('items');\n\t};\n\n\t/**\n\t * Adds an item.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {HTMLElement|jQuery|String} content - The item content to add.\n\t * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n\t */\n\tOwl.prototype.add = function(content, position) {\n\t\tvar current = this.relative(this._current);\n\n\t\tposition = position === undefined ? this._items.length : this.normalize(position, true);\n\t\tcontent = content instanceof jQuery ? content : $(content);\n\n\t\tthis.trigger('add', { content: content, position: position });\n\n\t\tcontent = this.prepare(content);\n\n\t\tif (this._items.length === 0 || position === this._items.length) {\n\t\t\tthis._items.length === 0 && this.$stage.append(content);\n\t\t\tthis._items.length !== 0 && this._items[position - 1].after(content);\n\t\t\tthis._items.push(content);\n\t\t\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t} else {\n\t\t\tthis._items[position].before(content);\n\t\t\tthis._items.splice(position, 0, content);\n\t\t\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}\n\n\t\tthis._items[current] && this.reset(this._items[current].index());\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('added', { content: content, position: position });\n\t};\n\n\t/**\n\t * Removes an item by its position.\n\t * @todo Use `item` instead of `content` for the event arguments.\n\t * @public\n\t * @param {Number} position - The relative position of the item to remove.\n\t */\n\tOwl.prototype.remove = function(position) {\n\t\tposition = this.normalize(position, true);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trigger('remove', { content: this._items[position], position: position });\n\n\t\tthis._items[position].remove();\n\t\tthis._items.splice(position, 1);\n\t\tthis._mergers.splice(position, 1);\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('removed', { content: null, position: position });\n\t};\n\n\t/**\n\t * Preloads images with auto width.\n\t * @todo Replace by a more generic approach\n\t * @protected\n\t */\n\tOwl.prototype.preloadAutoWidthImages = function(images) {\n\t\timages.each($.proxy(function(i, element) {\n\t\t\tthis.enter('pre-loading');\n\t\t\telement = $(element);\n\t\t\t$(new Image()).one('load', $.proxy(function(e) {\n\t\t\t\telement.attr('src', e.target.src);\n\t\t\t\telement.css('opacity', 1);\n\t\t\t\tthis.leave('pre-loading');\n\t\t\t\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\n\t\t\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n\t\t}, this));\n\t};\n\n\t/**\n\t * Destroys the carousel.\n\t * @public\n\t */\n\tOwl.prototype.destroy = function() {\n\n\t\tthis.$element.off('.owl.core');\n\t\tthis.$stage.off('.owl.core');\n\t\t$(document).off('.owl.core');\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\twindow.clearTimeout(this.resizeTimer);\n\t\t\tthis.off(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tfor (var i in this._plugins) {\n\t\t\tthis._plugins[i].destroy();\n\t\t}\n\n\t\tthis.$stage.children('.cloned').remove();\n\n\t\tthis.$stage.unwrap();\n\t\tthis.$stage.children().contents().unwrap();\n\t\tthis.$stage.children().unwrap();\n\t\tthis.$stage.remove();\n\t\tthis.$element\n\t\t\t.removeClass(this.options.refreshClass)\n\t\t\t.removeClass(this.options.loadingClass)\n\t\t\t.removeClass(this.options.loadedClass)\n\t\t\t.removeClass(this.options.rtlClass)\n\t\t\t.removeClass(this.options.dragClass)\n\t\t\t.removeClass(this.options.grabClass)\n\t\t\t.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), ''))\n\t\t\t.removeData('owl.carousel');\n\t};\n\n\t/**\n\t * Operators to calculate right-to-left and left-to-right.\n\t * @protected\n\t * @param {Number} [a] - The left side operand.\n\t * @param {String} [o] - The operator.\n\t * @param {Number} [b] - The right side operand.\n\t */\n\tOwl.prototype.op = function(a, o, b) {\n\t\tvar rtl = this.settings.rtl;\n\t\tswitch (o) {\n\t\t\tcase '<':\n\t\t\t\treturn rtl ? a > b : a < b;\n\t\t\tcase '>':\n\t\t\t\treturn rtl ? a < b : a > b;\n\t\t\tcase '>=':\n\t\t\t\treturn rtl ? a <= b : a >= b;\n\t\t\tcase '<=':\n\t\t\t\treturn rtl ? a >= b : a <= b;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n\t * Attaches to an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The event handler to attach.\n\t * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n\t */\n\tOwl.prototype.on = function(element, event, listener, capture) {\n\t\tif (element.addEventListener) {\n\t\t\telement.addEventListener(event, listener, capture);\n\t\t} else if (element.attachEvent) {\n\t\t\telement.attachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n\t * Detaches from an internal event.\n\t * @protected\n\t * @param {HTMLElement} element - The event source.\n\t * @param {String} event - The event name.\n\t * @param {Function} listener - The attached event handler to detach.\n\t * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n\t */\n\tOwl.prototype.off = function(element, event, listener, capture) {\n\t\tif (element.removeEventListener) {\n\t\t\telement.removeEventListener(event, listener, capture);\n\t\t} else if (element.detachEvent) {\n\t\t\telement.detachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n\t * Triggers a public event.\n\t * @todo Remove `status`, `relatedTarget` should be used instead.\n\t * @protected\n\t * @param {String} name - The event name.\n\t * @param {*} [data=null] - The event data.\n\t * @param {String} [namespace=carousel] - The event namespace.\n\t * @param {String} [state] - The state which is associated with the event.\n\t * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n\t * @returns {Event} - The event arguments.\n\t */\n\tOwl.prototype.trigger = function(name, data, namespace, state, enter) {\n\t\tvar status = {\n\t\t\titem: { count: this._items.length, index: this.current() }\n\t\t}, handler = $.camelCase(\n\t\t\t$.grep([ 'on', name, namespace ], function(v) { return v })\n\t\t\t\t.join('-').toLowerCase()\n\t\t), event = $.Event(\n\t\t\t[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),\n\t\t\t$.extend({ relatedTarget: this }, status, data)\n\t\t);\n\n\t\tif (!this._supress[name]) {\n\t\t\t$.each(this._plugins, function(name, plugin) {\n\t\t\t\tif (plugin.onTrigger) {\n\t\t\t\t\tplugin.onTrigger(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.register({ type: Owl.Type.Event, name: name });\n\t\t\tthis.$element.trigger(event);\n\n\t\t\tif (this.settings && typeof this.settings[handler] === 'function') {\n\t\t\t\tthis.settings[handler].call(this, event);\n\t\t\t}\n\t\t}\n\n\t\treturn event;\n\t};\n\n\t/**\n\t * Enters a state.\n\t * @param name - The state name.\n\t */\n\tOwl.prototype.enter = function(name) {\n\t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n\t\t\tif (this._states.current[name] === undefined) {\n\t\t\t\tthis._states.current[name] = 0;\n\t\t\t}\n\n\t\t\tthis._states.current[name]++;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Leaves a state.\n\t * @param name - The state name.\n\t */\n\tOwl.prototype.leave = function(name) {\n\t\t$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {\n\t\t\tthis._states.current[name]--;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Registers an event or state.\n\t * @public\n\t * @param {Object} object - The event or state to register.\n\t */\n\tOwl.prototype.register = function(object) {\n\t\tif (object.type === Owl.Type.Event) {\n\t\t\tif (!$.event.special[object.name]) {\n\t\t\t\t$.event.special[object.name] = {};\n\t\t\t}\n\n\t\t\tif (!$.event.special[object.name].owl) {\n\t\t\t\tvar _default = $.event.special[object.name]._default;\n\t\t\t\t$.event.special[object.name]._default = function(e) {\n\t\t\t\t\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n\t\t\t\t\t\treturn _default.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\treturn e.namespace && e.namespace.indexOf('owl') > -1;\n\t\t\t\t};\n\t\t\t\t$.event.special[object.name].owl = true;\n\t\t\t}\n\t\t} else if (object.type === Owl.Type.State) {\n\t\t\tif (!this._states.tags[object.name]) {\n\t\t\t\tthis._states.tags[object.name] = object.tags;\n\t\t\t} else {\n\t\t\t\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n\t\t\t}\n\n\t\t\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {\n\t\t\t\treturn $.inArray(tag, this._states.tags[object.name]) === i;\n\t\t\t}, this));\n\t\t}\n\t};\n\n\t/**\n\t * Suppresses events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to suppress.\n\t */\n\tOwl.prototype.suppress = function(events) {\n\t\t$.each(events, $.proxy(function(index, event) {\n\t\t\tthis._supress[event] = true;\n\t\t}, this));\n\t};\n\n\t/**\n\t * Releases suppressed events.\n\t * @protected\n\t * @param {Array.<String>} events - The events to release.\n\t */\n\tOwl.prototype.release = function(events) {\n\t\t$.each(events, $.proxy(function(index, event) {\n\t\t\tdelete this._supress[event];\n\t\t}, this));\n\t};\n\n\t/**\n\t * Gets unified pointer coordinates from event.\n\t * @todo #261\n\t * @protected\n\t * @param {Event} - The `mousedown` or `touchstart` event.\n\t * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n\t */\n\tOwl.prototype.pointer = function(event) {\n\t\tvar result = { x: null, y: null };\n\n\t\tevent = event.originalEvent || event || window.event;\n\n\t\tevent = event.touches && event.touches.length ?\n\t\t\tevent.touches[0] : event.changedTouches && event.changedTouches.length ?\n\t\t\t\tevent.changedTouches[0] : event;\n\n\t\tif (event.pageX) {\n\t\t\tresult.x = event.pageX;\n\t\t\tresult.y = event.pageY;\n\t\t} else {\n\t\t\tresult.x = event.clientX;\n\t\t\tresult.y = event.clientY;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Determines if the input is a Number or something that can be coerced to a Number\n\t * @protected\n\t * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n\t * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n\t */\n\tOwl.prototype.isNumeric = function(number) {\n\t\treturn !isNaN(parseFloat(number));\n\t};\n\n\t/**\n\t * Gets the difference of two vectors.\n\t * @todo #261\n\t * @protected\n\t * @param {Object} - The first vector.\n\t * @param {Object} - The second vector.\n\t * @returns {Object} - The difference.\n\t */\n\tOwl.prototype.difference = function(first, second) {\n\t\treturn {\n\t\t\tx: first.x - second.x,\n\t\t\ty: first.y - second.y\n\t\t};\n\t};\n\n\t/**\n\t * The jQuery Plugin for the Owl Carousel\n\t * @todo Navigation plugin `next` and `prev`\n\t * @public\n\t */\n\t$.fn.owlCarousel = function(option) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\t\treturn this.each(function() {\n\t\t\tvar $this = $(this),\n\t\t\t\tdata = $this.data('owl.carousel');\n\n\t\t\tif (!data) {\n\t\t\t\tdata = new Owl(this, typeof option == 'object' && option);\n\t\t\t\t$this.data('owl.carousel', data);\n\n\t\t\t\t$.each([\n\t\t\t\t\t'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'\n\t\t\t\t], function(i, event) {\n\t\t\t\t\tdata.register({ type: Owl.Type.Event, name: event });\n\t\t\t\t\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {\n\t\t\t\t\t\tif (e.namespace && e.relatedTarget !== this) {\n\t\t\t\t\t\t\tthis.suppress([ event ]);\n\t\t\t\t\t\t\tdata[event].apply(this, [].slice.call(arguments, 1));\n\t\t\t\t\t\t\tthis.release([ event ]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, data));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof option == 'string' && option.charAt(0) !== '_') {\n\t\t\t\tdata[option].apply(data, args);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * The constructor for the jQuery Plugin\n\t * @public\n\t */\n\t$.fn.owlCarousel.Constructor = Owl;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoRefresh Plugin\n * @version 2.3.4\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the auto refresh plugin.\n\t * @class The Auto Refresh Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar AutoRefresh = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Refresh interval.\n\t\t * @protected\n\t\t * @type {number}\n\t\t */\n\t\tthis._interval = null;\n\n\t\t/**\n\t\t * Whether the element is currently visible or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._visible = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoRefresh) {\n\t\t\t\t\tthis.watch();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoRefresh.Defaults = {\n\t\tautoRefresh: true,\n\t\tautoRefreshInterval: 500\n\t};\n\n\t/**\n\t * Watches the element.\n\t */\n\tAutoRefresh.prototype.watch = function() {\n\t\tif (this._interval) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = this._core.isVisible();\n\t\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n\t};\n\n\t/**\n\t * Refreshes the element.\n\t */\n\tAutoRefresh.prototype.refresh = function() {\n\t\tif (this._core.isVisible() === this._visible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = !this._visible;\n\n\t\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\n\n\t\tthis._visible && (this._core.invalidate('width') && this._core.refresh());\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tAutoRefresh.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\twindow.clearInterval(this._interval);\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the lazy plugin.\n\t * @class The Lazy Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Lazy = function(carousel) {\n\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Already loaded items.\n\t\t * @protected\n\t\t * @type {Array.<jQuery>}\n\t\t */\n\t\tthis._loaded = [];\n\n\t\t/**\n\t\t * Event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this._core.settings || !this._core.settings.lazyLoad) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ((e.property && e.property.name == 'position') || e.type == 'initialized') {\n\t\t\t\t\tvar settings = this._core.settings,\n\t\t\t\t\t\tn = (settings.center && Math.ceil(settings.items / 2) || settings.items),\n\t\t\t\t\t\ti = ((settings.center && n * -1) || 0),\n\t\t\t\t\t\tposition = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n\t\t\t\t\t\tclones = this._core.clones().length,\n\t\t\t\t\t\tload = $.proxy(function(i, v) { this.load(v) }, this);\n\t\t\t\t\t//TODO: Need documentation for this new option\n\t\t\t\t\tif (settings.lazyLoadEager > 0) {\n\t\t\t\t\t\tn += settings.lazyLoadEager;\n\t\t\t\t\t\t// If the carousel is looping also preload images that are to the \"left\"\n\t\t\t\t\t\tif (settings.loop) {\n              position -= settings.lazyLoadEager;\n              n++;\n            }\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (i++ < n) {\n\t\t\t\t\t\tthis.load(clones / 2 + this._core.relative(position));\n\t\t\t\t\t\tclones && $.each(this._core.clones(this._core.relative(position)), load);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set the default options\n\t\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n\t\t// register event handler\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tLazy.Defaults = {\n\t\tlazyLoad: false,\n\t\tlazyLoadEager: 0\n\t};\n\n\t/**\n\t * Loads all resources of an item at the specified position.\n\t * @param {Number} position - The absolute position of the item.\n\t * @protected\n\t */\n\tLazy.prototype.load = function(position) {\n\t\tvar $item = this._core.$stage.children().eq(position),\n\t\t\t$elements = $item && $item.find('.owl-lazy');\n\n\t\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t$elements.each($.proxy(function(index, element) {\n\t\t\tvar $element = $(element), image,\n                url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src') || $element.attr('data-srcset');\n\n\t\t\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n\t\t\tif ($element.is('img')) {\n\t\t\t\t$element.one('load.owl.lazy', $.proxy(function() {\n\t\t\t\t\t$element.css('opacity', 1);\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this)).attr('src', url);\n            } else if ($element.is('source')) {\n                $element.one('load.owl.lazy', $.proxy(function() {\n                    this._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n                }, this)).attr('srcset', url);\n\t\t\t} else {\n\t\t\t\timage = new Image();\n\t\t\t\timage.onload = $.proxy(function() {\n\t\t\t\t\t$element.css({\n\t\t\t\t\t\t'background-image': 'url(\"' + url + '\")',\n\t\t\t\t\t\t'opacity': '1'\n\t\t\t\t\t});\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this);\n\t\t\t\timage.src = url;\n\t\t\t}\n\t\t}, this));\n\n\t\tthis._loaded.push($item.get(0));\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tLazy.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis._core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the auto height plugin.\n\t * @class The Auto Height Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar AutoHeight = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\tthis._previousHeight = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.property.name === 'position'){\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'loaded.owl.lazy': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight\n\t\t\t\t\t&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t\tthis._intervalId = null;\n\t\tvar refThis = this;\n\n\t\t// These changes have been taken from a PR by gavrochelegnou proposed in #1575\n\t\t// and have been made compatible with the latest jQuery version\n\t\t$(window).on('load', function() {\n\t\t\tif (refThis._core.settings.autoHeight) {\n\t\t\t\trefThis.update();\n\t\t\t}\n\t\t});\n\n\t\t// Autoresize the height of the carousel when window is resized\n\t\t// When carousel has images, the height is dependent on the width\n\t\t// and should also change on resize\n\t\t$(window).resize(function() {\n\t\t\tif (refThis._core.settings.autoHeight) {\n\t\t\t\tif (refThis._intervalId != null) {\n\t\t\t\t\tclearTimeout(refThis._intervalId);\n\t\t\t\t}\n\n\t\t\t\trefThis._intervalId = setTimeout(function() {\n\t\t\t\t\trefThis.update();\n\t\t\t\t}, 250);\n\t\t\t}\n\t\t});\n\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoHeight.Defaults = {\n\t\tautoHeight: false,\n\t\tautoHeightClass: 'owl-height'\n\t};\n\n\t/**\n\t * Updates the view.\n\t */\n\tAutoHeight.prototype.update = function() {\n\t\tvar start = this._core._current,\n\t\t\tend = start + this._core.settings.items,\n\t\t\tlazyLoadEnabled = this._core.settings.lazyLoad,\n\t\t\tvisible = this._core.$stage.children().toArray().slice(start, end),\n\t\t\theights = [],\n\t\t\tmaxheight = 0;\n\n\t\t$.each(visible, function(index, item) {\n\t\t\theights.push($(item).height());\n\t\t});\n\n\t\tmaxheight = Math.max.apply(null, heights);\n\n\t\tif (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {\n\t\t\tmaxheight = this._previousHeight;\n\t\t}\n\n\t\tthis._previousHeight = maxheight;\n\n\t\tthis._core.$stage.parent()\n\t\t\t.height(maxheight)\n\t\t\t.addClass(this._core.settings.autoHeightClass);\n\t};\n\n\tAutoHeight.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] !== 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the video plugin.\n\t * @class The Video Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Video = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Cache all video URLs.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._videos = {};\n\n\t\t/**\n\t\t * Current playing item.\n\t\t * @protected\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis._playing = null;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @todo The cloned content removale is too late\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'resize.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.is('resizing')) {\n\t\t\t\t\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position' && this._playing) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar $element = $(e.content).find('.owl-video');\n\n\t\t\t\tif ($element.length) {\n\t\t\t\t\t$element.css('display', 'none');\n\t\t\t\t\tthis.fetch($element, $(e.content));\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {\n\t\t\tthis.play(e);\n\t\t}, this));\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tVideo.Defaults = {\n\t\tvideo: false,\n\t\tvideoHeight: false,\n\t\tvideoWidth: false\n\t};\n\n\t/**\n\t * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {jQuery} item - The item containing the video.\n\t */\n\tVideo.prototype.fetch = function(target, item) {\n\t\t\tvar type = (function() {\n\t\t\t\t\tif (target.attr('data-vimeo-id')) {\n\t\t\t\t\t\treturn 'vimeo';\n\t\t\t\t\t} else if (target.attr('data-vzaar-id')) {\n\t\t\t\t\t\treturn 'vzaar'\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 'youtube';\n\t\t\t\t\t}\n\t\t\t\t})(),\n\t\t\t\tid = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n\t\t\t\twidth = target.attr('data-width') || this._core.settings.videoWidth,\n\t\t\t\theight = target.attr('data-height') || this._core.settings.videoHeight,\n\t\t\t\turl = target.attr('href');\n\n\t\tif (url) {\n\n\t\t\t/*\n\t\t\t\t\tParses the id's out of the following urls (and probably more):\n\t\t\t\t\thttps://www.youtube.com/watch?v=:id\n\t\t\t\t\thttps://youtu.be/:id\n\t\t\t\t\thttps://vimeo.com/:id\n\t\t\t\t\thttps://vimeo.com/channels/:channel/:id\n\t\t\t\t\thttps://vimeo.com/groups/:group/videos/:id\n\t\t\t\t\thttps://app.vzaar.com/videos/:id\n\n\t\t\t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n\t\t\t*/\n\n\t\t\tid = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com|be\\-nocookie\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n\t\t\tif (id[3].indexOf('youtu') > -1) {\n\t\t\t\ttype = 'youtube';\n\t\t\t} else if (id[3].indexOf('vimeo') > -1) {\n\t\t\t\ttype = 'vimeo';\n\t\t\t} else if (id[3].indexOf('vzaar') > -1) {\n\t\t\t\ttype = 'vzaar';\n\t\t\t} else {\n\t\t\t\tthrow new Error('Video URL not supported.');\n\t\t\t}\n\t\t\tid = id[6];\n\t\t} else {\n\t\t\tthrow new Error('Missing video URL.');\n\t\t}\n\n\t\tthis._videos[url] = {\n\t\t\ttype: type,\n\t\t\tid: id,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\titem.attr('data-video', url);\n\n\t\tthis.thumbnail(target, this._videos[url]);\n\t};\n\n\t/**\n\t * Creates video thumbnail.\n\t * @protected\n\t * @param {jQuery} target - The target containing the video data.\n\t * @param {Object} info - The video info object.\n\t * @see `fetch`\n\t */\n\tVideo.prototype.thumbnail = function(target, video) {\n\t\tvar tnLink,\n\t\t\ticon,\n\t\t\tpath,\n\t\t\tdimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',\n\t\t\tcustomTn = target.find('img'),\n\t\t\tsrcType = 'src',\n\t\t\tlazyClass = '',\n\t\t\tsettings = this._core.settings,\n\t\t\tcreate = function(path) {\n\t\t\t\ticon = '<div class=\"owl-video-play-icon\"></div>';\n\n\t\t\t\tif (settings.lazyLoad) {\n\t\t\t\t\ttnLink = $('<div/>',{\n\t\t\t\t\t\t\"class\": 'owl-video-tn ' + lazyClass,\n\t\t\t\t\t\t\"srcType\": path\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttnLink = $( '<div/>', {\n\t\t\t\t\t\t\"class\": \"owl-video-tn\",\n\t\t\t\t\t\t\"style\": 'opacity:1;background-image:url(' + path + ')'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\ttarget.after(tnLink);\n\t\t\t\ttarget.after(icon);\n\t\t\t};\n\n\t\t// wrap video content into owl-video-wrapper div\n\t\ttarget.wrap( $( '<div/>', {\n\t\t\t\"class\": \"owl-video-wrapper\",\n\t\t\t\"style\": dimensions\n\t\t}));\n\n\t\tif (this._core.settings.lazyLoad) {\n\t\t\tsrcType = 'data-src';\n\t\t\tlazyClass = 'owl-lazy';\n\t\t}\n\n\t\t// custom thumbnail\n\t\tif (customTn.length) {\n\t\t\tcreate(customTn.attr(srcType));\n\t\t\tcustomTn.remove();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (video.type === 'youtube') {\n\t\t\tpath = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n\t\t\tcreate(path);\n\t\t} else if (video.type === 'vimeo') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tpath = data[0].thumbnail_large;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (video.type === 'vzaar') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vzaar.com/api/videos/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tpath = data.framegrab_url;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Stops the current video.\n\t * @public\n\t */\n\tVideo.prototype.stop = function() {\n\t\tthis._core.trigger('stop', null, 'video');\n\t\tthis._playing.find('.owl-video-frame').remove();\n\t\tthis._playing.removeClass('owl-video-playing');\n\t\tthis._playing = null;\n\t\tthis._core.leave('playing');\n\t\tthis._core.trigger('stopped', null, 'video');\n\t};\n\n\t/**\n\t * Starts the current video.\n\t * @public\n\t * @param {Event} event - The event arguments.\n\t */\n\tVideo.prototype.play = function(event) {\n\t\tvar target = $(event.target),\n\t\t\titem = target.closest('.' + this._core.settings.itemClass),\n\t\t\tvideo = this._videos[item.attr('data-video')],\n\t\t\twidth = video.width || '100%',\n\t\t\theight = video.height || this._core.$stage.height(),\n\t\t\thtml,\n\t\t\tiframe;\n\n\t\tif (this._playing) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('playing');\n\t\tthis._core.trigger('play', null, 'video');\n\n\t\titem = this._core.items(this._core.relative(item.index()));\n\n\t\tthis._core.reset(item.index());\n\n\t\thtml = $( '<iframe frameborder=\"0\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>' );\n\t\thtml.attr( 'height', height );\n\t\thtml.attr( 'width', width );\n\t\tif (video.type === 'youtube') {\n\t\t\thtml.attr( 'src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id );\n\t\t} else if (video.type === 'vimeo') {\n\t\t\thtml.attr( 'src', '//player.vimeo.com/video/' + video.id + '?autoplay=1' );\n\t\t} else if (video.type === 'vzaar') {\n\t\t\thtml.attr( 'src', '//view.vzaar.com/' + video.id + '/player?autoplay=true' );\n\t\t}\n\n\t\tiframe = $(html).wrap( '<div class=\"owl-video-frame\" />' ).insertAfter(item.find('.owl-video'));\n\n\t\tthis._playing = item.addClass('owl-video-playing');\n\t};\n\n\t/**\n\t * Checks whether an video is currently in full screen mode or not.\n\t * @todo Bad style because looks like a readonly method but changes members.\n\t * @protected\n\t * @returns {Boolean}\n\t */\n\tVideo.prototype.isInFullScreen = function() {\n\t\tvar element = document.fullscreenElement || document.mozFullScreenElement ||\n\t\t\t\tdocument.webkitFullscreenElement;\n\n\t\treturn element && $(element).parent().hasClass('owl-video-frame');\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tVideo.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tthis._core.$element.off('click.owl.video');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the animate plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n\tvar Animate = function(scope) {\n\t\tthis.core = scope;\n\t\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\n\t\tthis.swapping = true;\n\t\tthis.previous = undefined;\n\t\tthis.next = undefined;\n\n\t\tthis.handlers = {\n\t\t\t'change.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.previous = this.core.current();\n\t\t\t\t\tthis.next = e.property.value;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.swapping = e.type == 'translated';\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'translate.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n\t\t\t\t\tthis.swap();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\tthis.core.$element.on(this.handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAnimate.Defaults = {\n\t\tanimateOut: false,\n\t\tanimateIn: false\n\t};\n\n\t/**\n\t * Toggles the animation classes whenever an translations starts.\n\t * @protected\n\t * @returns {Boolean|undefined}\n\t */\n\tAnimate.prototype.swap = function() {\n\n\t\tif (this.core.settings.items !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!$.support.animation || !$.support.transition) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.core.speed(0);\n\n\t\tvar left,\n\t\t\tclear = $.proxy(this.clear, this),\n\t\t\tprevious = this.core.$stage.children().eq(this.previous),\n\t\t\tnext = this.core.$stage.children().eq(this.next),\n\t\t\tincoming = this.core.settings.animateIn,\n\t\t\toutgoing = this.core.settings.animateOut;\n\n\t\tif (this.core.current() === this.previous) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (outgoing) {\n\t\t\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n\t\t\tprevious.one($.support.animation.end, clear)\n\t\t\t\t.css( { 'left': left + 'px' } )\n\t\t\t\t.addClass('animated owl-animated-out')\n\t\t\t\t.addClass(outgoing);\n\t\t}\n\n\t\tif (incoming) {\n\t\t\tnext.one($.support.animation.end, clear)\n\t\t\t\t.addClass('animated owl-animated-in')\n\t\t\t\t.addClass(incoming);\n\t\t}\n\t};\n\n\tAnimate.prototype.clear = function(e) {\n\t\t$(e.target).css( { 'left': '' } )\n\t\t\t.removeClass('animated owl-animated-out owl-animated-in')\n\t\t\t.removeClass(this.core.settings.animateIn)\n\t\t\t.removeClass(this.core.settings.animateOut);\n\t\tthis.core.onTransitionEnd();\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tAnimate.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis.core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author Artus Kolanowski\n * @author David Deutsch\n * @author Tom De CaluwÃ©\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\t/**\n\t * Creates the autoplay plugin.\n\t * @class The Autoplay Plugin\n\t * @param {Owl} scope - The Owl Carousel\n\t */\n\tvar Autoplay = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * The autoplay timeout id.\n\t\t * @type {Number}\n\t\t */\n\t\tthis._call = null;\n\n\t\t/**\n\t\t * Depending on the state of the plugin, this variable contains either\n\t\t * the start time of the timer or the current timer value if it's\n\t\t * paused. Since we start in a paused state we initialize the timer\n\t\t * value.\n\t\t * @type {Number}\n\t\t */\n\t\tthis._time = 0;\n\n\t\t/**\n\t\t * Stores the timeout currently used.\n\t\t * @type {Number}\n\t\t */\n\t\tthis._timeout = 0;\n\n\t\t/**\n\t\t * Indicates whenever the autoplay is paused.\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._paused = true;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'settings') {\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis.play();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t}\n\t\t\t\t} else if (e.namespace && e.property.name === 'position' && this._paused) {\n\t\t\t\t\t// Reset the timer. This code is triggered when the position\n\t\t\t\t\t// of the carousel was changed through user interaction.\n\t\t\t\t\tthis._time = 0;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoplay) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'play.owl.autoplay': $.proxy(function(e, t, s) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.play(t, s);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'stop.owl.autoplay': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseover.owl.autoplay': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseleave.owl.autoplay': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchstart.owl.core': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchend.owl.core': $.proxy(function() {\n\t\t\t\tif (this._core.settings.autoplayHoverPause) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tAutoplay.Defaults = {\n\t\tautoplay: false,\n\t\tautoplayTimeout: 5000,\n\t\tautoplayHoverPause: false,\n\t\tautoplaySpeed: false\n\t};\n\n\t/**\n\t * Transition to the next slide and set a timeout for the next transition.\n\t * @private\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t */\n\tAutoplay.prototype._next = function(speed) {\n\t\tthis._call = window.setTimeout(\n\t\t\t$.proxy(this._next, this, speed),\n\t\t\tthis._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()\n\t\t);\n\n\t\tif (this._core.is('interacting') || document.hidden) {\n\t\t\treturn;\n\t\t}\n\t\tthis._core.next(speed || this._core.settings.autoplaySpeed);\n\t}\n\n\t/**\n\t * Reads the current timer value when the timer is playing.\n\t * @public\n\t */\n\tAutoplay.prototype.read = function() {\n\t\treturn new Date().getTime() - this._time;\n\t};\n\n\t/**\n\t * Starts the autoplay.\n\t * @public\n\t * @param {Number} [timeout] - The interval before the next animation starts.\n\t * @param {Number} [speed] - The animation speed for the animations.\n\t */\n\tAutoplay.prototype.play = function(timeout, speed) {\n\t\tvar elapsed;\n\n\t\tif (!this._core.is('rotating')) {\n\t\t\tthis._core.enter('rotating');\n\t\t}\n\n\t\ttimeout = timeout || this._core.settings.autoplayTimeout;\n\n\t\t// Calculate the elapsed time since the last transition. If the carousel\n\t\t// wasn't playing this calculation will yield zero.\n\t\telapsed = Math.min(this._time % (this._timeout || timeout), timeout);\n\n\t\tif (this._paused) {\n\t\t\t// Start the clock.\n\t\t\tthis._time = this.read();\n\t\t\tthis._paused = false;\n\t\t} else {\n\t\t\t// Clear the active timeout to allow replacement.\n\t\t\twindow.clearTimeout(this._call);\n\t\t}\n\n\t\t// Adjust the origin of the timer to match the new timeout value.\n\t\tthis._time += this.read() % timeout - elapsed;\n\n\t\tthis._timeout = timeout;\n\t\tthis._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);\n\t};\n\n\t/**\n\t * Stops the autoplay.\n\t * @public\n\t */\n\tAutoplay.prototype.stop = function() {\n\t\tif (this._core.is('rotating')) {\n\t\t\t// Reset the clock.\n\t\t\tthis._time = 0;\n\t\t\tthis._paused = true;\n\n\t\t\twindow.clearTimeout(this._call);\n\t\t\tthis._core.leave('rotating');\n\t\t}\n\t};\n\n\t/**\n\t * Pauses the autoplay.\n\t * @public\n\t */\n\tAutoplay.prototype.pause = function() {\n\t\tif (this._core.is('rotating') && !this._paused) {\n\t\t\t// Pause the clock.\n\t\t\tthis._time = this.read();\n\t\t\tthis._paused = true;\n\n\t\t\twindow.clearTimeout(this._call);\n\t\t}\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t */\n\tAutoplay.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\tthis.stop();\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.3.4\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n\t * Creates the navigation plugin.\n\t * @class The Navigation Plugin\n\t * @param {Owl} carousel - The Owl Carousel.\n\t */\n\tvar Navigation = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Indicates whether the plugin is initialized or not.\n\t\t * @protected\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis._initialized = false;\n\n\t\t/**\n\t\t * The current paging indexes.\n\t\t * @protected\n\t\t * @type {Array}\n\t\t */\n\t\tthis._pages = [];\n\n\t\t/**\n\t\t * All DOM elements of the user interface.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._controls = {};\n\n\t\t/**\n\t\t * Markup for an indicator.\n\t\t * @protected\n\t\t * @type {Array.<String>}\n\t\t */\n\t\tthis._templates = [];\n\n\t\t/**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n\t\t * Overridden methods of the carousel.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._overrides = {\n\t\t\tnext: this._core.next,\n\t\t\tprev: this._core.prev,\n\t\t\tto: this._core.to\n\t\t};\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' +\n\t\t\t\t\t\t$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'added.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 0, this._templates.pop());\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'remove.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 1);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.draw();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && !this._initialized) {\n\t\t\t\t\tthis._core.trigger('initialize', null, 'navigation');\n\t\t\t\t\tthis.initialize();\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._initialized = true;\n\t\t\t\t\tthis._core.trigger('initialized', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._initialized) {\n\t\t\t\t\tthis._core.trigger('refresh', null, 'navigation');\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._core.trigger('refreshed', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis.$element.on(this._handlers);\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t * @todo Rename `slideBy` to `navBy`\n\t */\n\tNavigation.Defaults = {\n\t\tnav: false,\n\t\tnavText: [\n\t\t\t'<span aria-label=\"' + 'Previous' + '\">&#x2039;</span>',\n\t\t\t'<span aria-label=\"' + 'Next' + '\">&#x203a;</span>'\n\t\t],\n\t\tnavSpeed: false,\n\t\tnavElement: 'button type=\"button\" role=\"presentation\"',\n\t\tnavContainer: false,\n\t\tnavContainerClass: 'owl-nav',\n\t\tnavClass: [\n\t\t\t'owl-prev',\n\t\t\t'owl-next'\n\t\t],\n\t\tslideBy: 1,\n\t\tdotClass: 'owl-dot',\n\t\tdotsClass: 'owl-dots',\n\t\tdots: true,\n\t\tdotsEach: false,\n\t\tdotsData: false,\n\t\tdotsSpeed: false,\n\t\tdotsContainer: false\n\t};\n\n\t/**\n\t * Initializes the layout of the plugin and extends the carousel.\n\t * @protected\n\t */\n\tNavigation.prototype.initialize = function() {\n\t\tvar override,\n\t\t\tsettings = this._core.settings;\n\n\t\t// create DOM structure for relative navigation\n\t\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer)\n\t\t\t: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$previous = $('<' + settings.navElement + '>')\n\t\t\t.addClass(settings.navClass[0])\n\t\t\t.html(settings.navText[0])\n\t\t\t.prependTo(this._controls.$relative)\n\t\t\t.on('click', $.proxy(function(e) {\n\t\t\t\tthis.prev(settings.navSpeed);\n\t\t\t}, this));\n\t\tthis._controls.$next = $('<' + settings.navElement + '>')\n\t\t\t.addClass(settings.navClass[1])\n\t\t\t.html(settings.navText[1])\n\t\t\t.appendTo(this._controls.$relative)\n\t\t\t.on('click', $.proxy(function(e) {\n\t\t\t\tthis.next(settings.navSpeed);\n\t\t\t}, this));\n\n\t\t// create DOM structure for absolute navigation\n\t\tif (!settings.dotsData) {\n\t\t\tthis._templates = [ $('<button role=\"button\">')\n\t\t\t\t.addClass(settings.dotClass)\n\t\t\t\t.append($('<span>'))\n\t\t\t\t.prop('outerHTML') ];\n\t\t}\n\n\t\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)\n\t\t\t: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$absolute.on('click', 'button', $.proxy(function(e) {\n\t\t\tvar index = $(e.target).parent().is(this._controls.$absolute)\n\t\t\t\t? $(e.target).index() : $(e.target).parent().index();\n\n\t\t\te.preventDefault();\n\n\t\t\tthis.to(index, settings.dotsSpeed);\n\t\t}, this));\n\n\t\t/*$el.on('focusin', function() {\n\t\t\t$(document).off(\".carousel\");\n\n\t\t\t$(document).on('keydown.carousel', function(e) {\n\t\t\t\tif(e.keyCode == 37) {\n\t\t\t\t\t$el.trigger('prev.owl')\n\t\t\t\t}\n\t\t\t\tif(e.keyCode == 39) {\n\t\t\t\t\t$el.trigger('next.owl')\n\t\t\t\t}\n\t\t\t});\n\t\t});*/\n\n\t\t// override public methods of the carousel\n\t\tfor (override in this._overrides) {\n\t\t\tthis._core[override] = $.proxy(this[override], this);\n\t\t}\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @protected\n\t */\n\tNavigation.prototype.destroy = function() {\n\t\tvar handler, control, property, override, settings;\n\t\tsettings = this._core.settings;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (control in this._controls) {\n\t\t\tif (control === '$relative' && settings.navContainer) {\n\t\t\t\tthis._controls[control].html('');\n\t\t\t} else {\n\t\t\t\tthis._controls[control].remove();\n\t\t\t}\n\t\t}\n\t\tfor (override in this.overides) {\n\t\t\tthis._core[override] = this._overrides[override];\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t/**\n\t * Updates the internal state.\n\t * @protected\n\t */\n\tNavigation.prototype.update = function() {\n\t\tvar i, j, k,\n\t\t\tlower = this._core.clones().length / 2,\n\t\t\tupper = lower + this._core.items().length,\n\t\t\tmaximum = this._core.maximum(true),\n\t\t\tsettings = this._core.settings,\n\t\t\tsize = settings.center || settings.autoWidth || settings.dotsData\n\t\t\t\t? 1 : settings.dotsEach || settings.items;\n\n\t\tif (settings.slideBy !== 'page') {\n\t\t\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\n\t\t}\n\n\t\tif (settings.dots || settings.slideBy == 'page') {\n\t\t\tthis._pages = [];\n\n\t\t\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\n\t\t\t\tif (j >= size || j === 0) {\n\t\t\t\t\tthis._pages.push({\n\t\t\t\t\t\tstart: Math.min(maximum, i - lower),\n\t\t\t\t\t\tend: i - lower + size - 1\n\t\t\t\t\t});\n\t\t\t\t\tif (Math.min(maximum, i - lower) === maximum) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj = 0, ++k;\n\t\t\t\t}\n\t\t\t\tj += this._core.mergers(this._core.relative(i));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Draws the user interface.\n\t * @todo The option `dotsData` wont work.\n\t * @protected\n\t */\n\tNavigation.prototype.draw = function() {\n\t\tvar difference,\n\t\t\tsettings = this._core.settings,\n\t\t\tdisabled = this._core.items().length <= settings.items,\n\t\t\tindex = this._core.relative(this._core.current()),\n\t\t\tloop = settings.loop || settings.rewind;\n\n\t\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n\t\tif (settings.nav) {\n\t\t\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n\t\t\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n\t\t}\n\n\t\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n\t\tif (settings.dots) {\n\t\t\tdifference = this._pages.length - this._controls.$absolute.children().length;\n\n\t\t\tif (settings.dotsData && difference !== 0) {\n\t\t\t\tthis._controls.$absolute.html(this._templates.join(''));\n\t\t\t} else if (difference > 0) {\n\t\t\t\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n\t\t\t} else if (difference < 0) {\n\t\t\t\tthis._controls.$absolute.children().slice(difference).remove();\n\t\t\t}\n\n\t\t\tthis._controls.$absolute.find('.active').removeClass('active');\n\t\t\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n\t\t}\n\t};\n\n\t/**\n\t * Extends event data.\n\t * @protected\n\t * @param {Event} event - The event object which gets thrown.\n\t */\n\tNavigation.prototype.onTrigger = function(event) {\n\t\tvar settings = this._core.settings;\n\n\t\tevent.page = {\n\t\t\tindex: $.inArray(this.current(), this._pages),\n\t\t\tcount: this._pages.length,\n\t\t\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData\n\t\t\t\t? 1 : settings.dotsEach || settings.items)\n\t\t};\n\t};\n\n\t/**\n\t * Gets the current page position of the carousel.\n\t * @protected\n\t * @returns {Number}\n\t */\n\tNavigation.prototype.current = function() {\n\t\tvar current = this._core.relative(this._core.current());\n\t\treturn $.grep(this._pages, $.proxy(function(page, index) {\n\t\t\treturn page.start <= current && page.end >= current;\n\t\t}, this)).pop();\n\t};\n\n\t/**\n\t * Gets the current succesor/predecessor position.\n\t * @protected\n\t * @returns {Number}\n\t */\n\tNavigation.prototype.getPosition = function(successor) {\n\t\tvar position, length,\n\t\t\tsettings = this._core.settings;\n\n\t\tif (settings.slideBy == 'page') {\n\t\t\tposition = $.inArray(this.current(), this._pages);\n\t\t\tlength = this._pages.length;\n\t\t\tsuccessor ? ++position : --position;\n\t\t\tposition = this._pages[((position % length) + length) % length].start;\n\t\t} else {\n\t\t\tposition = this._core.relative(this._core.current());\n\t\t\tlength = this._core.items().length;\n\t\t\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n\t * Slides to the next item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n\tNavigation.prototype.next = function(speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n\t};\n\n\t/**\n\t * Slides to the previous item or page.\n\t * @public\n\t * @param {Number} [speed=false] - The time in milliseconds for the transition.\n\t */\n\tNavigation.prototype.prev = function(speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n\t};\n\n\t/**\n\t * Slides to the specified item or page.\n\t * @public\n\t * @param {Number} position - The position of the item or page.\n\t * @param {Number} [speed] - The time in milliseconds for the transition.\n\t * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n\t */\n\tNavigation.prototype.to = function(position, speed, standard) {\n\t\tvar length;\n\n\t\tif (!standard && this._pages.length) {\n\t\t\tlength = this._pages.length;\n\t\t\t$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);\n\t\t} else {\n\t\t\t$.proxy(this._overrides.to, this._core)(position, speed);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.3.4\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n\t * Creates the hash plugin.\n\t * @class The Hash Plugin\n\t * @param {Owl} carousel - The Owl Carousel\n\t */\n\tvar Hash = function(carousel) {\n\t\t/**\n\t\t * Reference to the core.\n\t\t * @protected\n\t\t * @type {Owl}\n\t\t */\n\t\tthis._core = carousel;\n\n\t\t/**\n\t\t * Hash index for the items.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._hashes = {};\n\n\t\t/**\n\t\t * The carousel element.\n\t\t * @type {jQuery}\n\t\t */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n\t\t * All event handlers.\n\t\t * @protected\n\t\t * @type {Object}\n\t\t */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\n\t\t\t\t\t$(window).trigger('hashchange.owl.navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n\t\t\t\t\tif (!hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._hashes[hash] = e.content;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function(e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position') {\n\t\t\t\t\tvar current = this._core.items(this._core.relative(this._core.current())),\n\t\t\t\t\t\thash = $.map(this._hashes, function(item, hash) {\n\t\t\t\t\t\t\treturn item === current ? hash : null;\n\t\t\t\t\t\t}).join();\n\n\t\t\t\t\tif (!hash || window.location.hash.slice(1) === hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\twindow.location.hash = hash;\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n\t\t// register the event handlers\n\t\tthis.$element.on(this._handlers);\n\n\t\t// register event listener for hash navigation\n\t\t$(window).on('hashchange.owl.navigation', $.proxy(function(e) {\n\t\t\tvar hash = window.location.hash.substring(1),\n\t\t\t\titems = this._core.$stage.children(),\n\t\t\t\tposition = this._hashes[hash] && items.index(this._hashes[hash]);\n\n\t\t\tif (position === undefined || position === this._core.current()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._core.to(this._core.relative(position), false, true);\n\t\t}, this));\n\t};\n\n\t/**\n\t * Default options.\n\t * @public\n\t */\n\tHash.Defaults = {\n\t\tURLhashListener: false\n\t};\n\n\t/**\n\t * Destroys the plugin.\n\t * @public\n\t */\n\tHash.prototype.destroy = function() {\n\t\tvar handler, property;\n\n\t\t$(window).off('hashchange.owl.navigation');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Support Plugin\n *\n * @version 2.3.4\n * @author Vivid Planet Software GmbH\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n\tvar style = $('<support>').get(0).style,\n\t\tprefixes = 'Webkit Moz O ms'.split(' '),\n\t\tevents = {\n\t\t\ttransition: {\n\t\t\t\tend: {\n\t\t\t\t\tWebkitTransition: 'webkitTransitionEnd',\n\t\t\t\t\tMozTransition: 'transitionend',\n\t\t\t\t\tOTransition: 'oTransitionEnd',\n\t\t\t\t\ttransition: 'transitionend'\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation: {\n\t\t\t\tend: {\n\t\t\t\t\tWebkitAnimation: 'webkitAnimationEnd',\n\t\t\t\t\tMozAnimation: 'animationend',\n\t\t\t\t\tOAnimation: 'oAnimationEnd',\n\t\t\t\t\tanimation: 'animationend'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttests = {\n\t\t\tcsstransforms: function() {\n\t\t\t\treturn !!test('transform');\n\t\t\t},\n\t\t\tcsstransforms3d: function() {\n\t\t\t\treturn !!test('perspective');\n\t\t\t},\n\t\t\tcsstransitions: function() {\n\t\t\t\treturn !!test('transition');\n\t\t\t},\n\t\t\tcssanimations: function() {\n\t\t\t\treturn !!test('animation');\n\t\t\t}\n\t\t};\n\n\tfunction test(property, prefixed) {\n\t\tvar result = false,\n\t\t\tupper = property.charAt(0).toUpperCase() + property.slice(1);\n\n\t\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {\n\t\t\tif (style[property] !== undefined) {\n\t\t\t\tresult = prefixed ? property : true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tfunction prefixed(property) {\n\t\treturn test(property, true);\n\t}\n\n\tif (tests.csstransitions()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transition = new String(prefixed('transition'))\n\t\t$.support.transition.end = events.transition.end[ $.support.transition ];\n\t}\n\n\tif (tests.cssanimations()) {\n\t\t/* jshint -W053 */\n\t\t$.support.animation = new String(prefixed('animation'))\n\t\t$.support.animation.end = events.animation.end[ $.support.animation ];\n\t}\n\n\tif (tests.csstransforms()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transform = new String(prefixed('transform'));\n\t\t$.support.transform3d = tests.csstransforms3d();\n\t}\n\n})(window.Zepto || window.jQuery, window, document);\n\n\n//# sourceURL=webpack://saasymail/./node_modules/owl.carousel/dist/owl.carousel.js?")},"./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n  var round = Math.round,\n      floor = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\" â€” or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popper);\n//# sourceMappingURL=popper.js.map\n\n\n//# sourceURL=webpack://saasymail/./node_modules/popper.js/dist/esm/popper.js?")},jquery:
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/e=>{"use strict";e.exports=jQuery}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];return void 0!==n||(n=__webpack_module_cache__[e]={exports:{}},__webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__)),n.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./build/scripts/home.js")})();
//# sourceMappingURL=home.js.map
